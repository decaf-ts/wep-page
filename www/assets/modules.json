[
  {
    "name": "decoration",
    "title": "decoration",
    "description": "# Description\n\n@decaf-ts/decoration provides two complementary capabilities:\n\n- A small, builder-style API (Decoration) to define and apply decorators that can vary by \"flavour\" (for example, different frameworks or environments) while keeping a stable key-based API.\n- A centralized runtime Metadata store (Metadata) for reading and writing structured information about classes and their members, using reflect-metadata for design-time type hints.\n\nThis module aims to standardize how decorators are composed, discovered, and executed across contexts, and how metadata is stored and queried during runtime.\n\nMain building blocks\n\n- Decoration (builder and registry)\n  - You create a decoration pipeline for a key (for(\"component\"), for example).\n  - For the default flavour (\"decaf\"), you define the base decorators with define(...).\n  - For other flavours (e.g., \"vue\", \"nest\"), you can either override the base decorators (define for that flavour) or extend them with extras (extend(...)).\n  - At runtime, a global flavour resolver (setFlavourResolver) decides which flavour to apply to a given target. If that flavour has overrides, they are used; otherwise, the default base decorators are applied. Any flavour-specific extras and default extras are appended.\n  - The result of apply() is a decorator function whose name encodes the flavour and key to aid debugging.\n\n- Decorator utilities\n  - metadata(key, value): writes arbitrary metadata on a class or member.\n  - prop(): captures the Reflect design:type for a property and records it in Metadata under properties.<prop>.\n  - apply(...decorators): composes multiple decorators of different kinds and applies them in sequence.\n  - propMetadata(key, value): convenience factory that performs both metadata(key, value) and prop().\n  - description(text): stores a human-friendly description for a class or property under description.class or description.<prop>.\n\n- Metadata store\n  - Static convenience API backed by a singleton instance. It maps each class constructor to a structured metadata object.\n  - Keys are nested (e.g., \"properties.name\", \"description.class\") and navigated using a splitter (default \".\").\n  - When mirroring is enabled (default), the internal metadata object is also defined on the constructor under a stable, non-enumerable key (DecorationKeys.REFLECT) for quick inspection.\n  - Helper methods:\n    - properties(ctor): list known property names that have recorded type info.\n    - description(ctor, prop?): read description for class or a property.\n    - type(ctor, prop): read the recorded design type for a property.\n    - get/set(ctor, key): low-level access to arbitrary paths.\n\nConstants and types\n\n- DefaultFlavour: the default flavour identifier (\"decaf\").\n- ObjectKeySplitter: delimiter for nested metadata keys (\".\").\n- DecorationKeys: well-known metadata keys (REFLECT, PROPERTIES, CLASS, DESCRIPTION, design:type, etc.).\n- DefaultMetadata: the default metadata shape used as a base.\n- BasicMetadata / Constructor: utility types that describe metadata structure and a class constructor signature.\n\nDesign highlights\n\n- Composable and flavour-aware: The Decoration builder allows different environments or frameworks to contribute distinct decorator behavior under the same semantic key. This is useful when building adapters (e.g., Angular vs React components) without changing user code imports.\n- Predictable application order: Default decorators are applied first (or a flavour-specific override is used), followed by extras. Extras can come from the default flavour and/or the resolved flavour.\n- Introspectable metadata: The Metadata store makes it straightforward to record and query runtime facts about models, properties, and behavior. This is especially helpful for ORMs, serializers, validators, and UI bindings.\n",
    "summary": "Description @decaf-ts/decoration provides two complementary capabilities: - A small, builder-style API Decoration to define and apply decorators that can vary by \"flavour\" for example, different frame…",
    "examples": [
      {
        "lang": "ts",
        "code": "import { Decoration } from \"@decaf-ts/decoration\";\n\nconst markAsComponent: ClassDecorator = (target) => {\n  (target as any).__isComponent = true;\n};\n\nconst tagFactory = (tag: string): ClassDecorator => (target) => {\n  (target as any).__tag = tag;\n};\n\nconst component = () =>\n  Decoration.for(\"component\")\n    .define({ decorator: tagFactory, args: [\"base\"] }, markAsComponent)\n    .apply();\n\n@component()\nclass DefaultComponent {}\n\n(DefaultComponent as any).__isComponent; // true\n(DefaultComponent as any).__tag; // \"base\"\n",
        "context": "1. Register base decorators for the default flavour",
        "source": "howto",
        "title": "Use Decorators",
        "details": "1. Register base decorators for the default flavour"
      },
      {
        "lang": "ts",
        "code": "// Register the same base behaviour as above.\nconst baseComponent = () =>\n  Decoration.for(\"component\")\n    .define(((target: any) => target) as ClassDecorator)\n    .apply();\n\n@baseComponent()\nclass BaseComponent {}\n\nDecoration.setFlavourResolver(() => \"web\");\n\nconst decorate = () =>\n  Decoration.flavouredAs(\"web\")\n    .for(\"component\")\n    .extend({\n      decorator: (platform: string): ClassDecorator => (target) => {\n        (target as any).__platform = platform;\n      },\n      args: [\"web\"],\n    })\n    .apply();\n\n@decorate()\nclass WebComponent {}\n\n(WebComponent as any).__platform; // \"web\"\n",
        "context": "2. Extend base decorators with flavour-specific extras",
        "source": "howto",
        "title": "Use Decorators",
        "details": "2. Extend base decorators with flavour-specific extras"
      },
      {
        "lang": "ts",
        "code": "const base = () =>\n  Decoration.for(\"component\")\n    .define(((target: any) => {\n      (target as any).__base = true;\n    }) as ClassDecorator)\n    .apply();\n\n@base()\nclass BaseBehaviour {}\n\nDecoration.setFlavourResolver(() => \"mobile\");\n\nconst mobileComponent = () =>\n  Decoration.flavouredAs(\"mobile\")\n    .for(\"component\")\n    .define(((target: any) => {\n      (target as any).__mobile = true;\n    }) as ClassDecorator)\n    .apply();\n\n@mobileComponent()\nclass MobileComponent {}\n\n(MobileComponent as any).__base; // undefined – overridden\n(MobileComponent as any).__mobile; // true\n",
        "context": "3. Override decorators for an alternate flavour",
        "source": "howto",
        "title": "Use Decorators",
        "details": "3. Override decorators for an alternate flavour"
      },
      {
        "lang": "ts",
        "code": "const base = Decoration.for(\"guarded\");\n\n// Missing key before define/extend\nexpect(() => (new Decoration() as any).define(() => () => undefined)).toThrow();\n\n// Multiple overridable decorators are rejected\nconst overridable = {\n  decorator: (() => ((target: any) => target)) as any,\n  args: [],\n};\nexpect(() => base.define(overridable as any, overridable as any)).toThrow();\n\n// Extending the default flavour is blocked\nexpect(() => Decoration.for(\"guarded\").extend(((t: any) => t) as any)).toThrow();\n",
        "context": "The builder throws when misused; tests assert these guards and you can rely on them in your own code.",
        "source": "howto",
        "title": "The Builder Throws When Misused Tests",
        "details": "The builder throws when misused; tests assert these guards and you can rely on them in your own code."
      },
      {
        "lang": "ts",
        "code": "import { metadata, Metadata } from \"@decaf-ts/decoration\";\n\n@metadata(\"role\", \"entity\")\nclass User {}\n\nMetadata.get(User, \"role\"); // \"entity\"\n",
        "context": "metadatakey, value",
        "source": "howto",
        "title": "Metadatakey Value",
        "details": "metadatakey, value"
      },
      {
        "lang": "ts",
        "code": "import { prop, Metadata } from \"@decaf-ts/decoration\";\n\nclass Article {\n  @prop()\n  title!: string;\n}\n\nMetadata.type(Article, \"title\") === String; // true\n",
        "context": "prop",
        "source": "howto",
        "title": "Prop",
        "details": "prop"
      },
      {
        "lang": "ts",
        "code": "import { apply } from \"@decaf-ts/decoration\";\n\nconst logClass: ClassDecorator = (target) => {\n  console.log(\"class\", (target as any).name);\n};\n\nconst withLogging = () => apply(logClass);\nconst logProperty = () => apply((_, key) => console.log(\"prop\", String(key)));\n\n@withLogging()\nclass Box {\n  @logProperty()\n  size!: number;\n}\n",
        "context": "apply...decorators",
        "source": "howto",
        "title": "Use Decorators",
        "details": "apply...decorators"
      },
      {
        "lang": "ts",
        "code": "import { propMetadata, Metadata } from \"@decaf-ts/decoration\";\n\nclass Product {\n  @propMetadata(\"column\", \"price\")\n  price!: number;\n}\n\nMetadata.get(Product, \"column\"); // \"price\"\nMetadata.type(Product, \"price\") === Number; // true\n",
        "context": "propMetadatakey, value",
        "source": "howto",
        "title": "Propmetadatakey Value",
        "details": "propMetadatakey, value"
      },
      {
        "lang": "ts",
        "code": "import { description, Metadata } from \"@decaf-ts/decoration\";\n\n@description(\"User entity\")\nclass User {\n  @description(\"Primary email address\")\n  email!: string;\n}\n\nMetadata.description(User); // \"User entity\"\nMetadata.description<User>(User, \"email\" as keyof User); // \"Primary email address\"\n",
        "context": "descriptiontext",
        "source": "howto",
        "title": "Descriptiontext",
        "details": "descriptiontext"
      },
      {
        "lang": "ts",
        "code": "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Person {\n  name!: string;\n}\n\nMetadata.set(Person, `${DecorationKeys.DESCRIPTION}.class`, \"Person model\");\nMetadata.set(Person, `${DecorationKeys.PROPERTIES}.name`, String);\n\nMetadata.description(Person); // \"Person model\"\nMetadata.properties(Person); // [\"name\"]\n\nconst mirror = Object.getOwnPropertyDescriptor(Person, DecorationKeys.REFLECT);\nmirror?.enumerable; // false\n",
        "context": "Set and read nested values with constructor mirroring",
        "source": "howto",
        "title": "Set And Read Nested Values With",
        "details": "Set and read nested values with constructor mirroring"
      },
      {
        "lang": "ts",
        "code": "(Metadata as any).mirror = false;\n\nMetadata.set(Person, `${DecorationKeys.DESCRIPTION}.class`, \"No mirror\");\nObject.getOwnPropertyDescriptor(Person, DecorationKeys.REFLECT); // undefined\n\n(Metadata as any).mirror = true; // reset when you are done\n",
        "context": "Opt out of mirroring",
        "source": "howto",
        "title": "Opt Out Of Mirroring",
        "details": "Opt out of mirroring"
      },
      {
        "lang": "ts",
        "code": "class Service {\n  get(): string {\n    return \"value\";\n  }\n}\n\nMetadata.set(\n  Service,\n  `${DecorationKeys.METHODS}.get.${DecorationKeys.DESIGN_PARAMS}`,\n  []\n);\nMetadata.set(\n  Service,\n  `${DecorationKeys.METHODS}.get.${DecorationKeys.DESIGN_RETURN}`,\n  String\n);\n\nMetadata.methods(Service); // [\"get\"]\nMetadata.params(Service, \"get\"); // []\nMetadata.return(Service, \"get\") === String; // true\n",
        "context": "Work with method metadata",
        "source": "howto",
        "title": "Work With Method Metadata",
        "details": "Work with method metadata"
      },
      {
        "lang": "ts",
        "code": "Metadata.type(Person, \"name\"); // Reflects design type recorded by @prop()\nMetadata.get(Person); // Full metadata payload for advanced inspection\nMetadata.get(Person, DecorationKeys.CONSTRUCTOR); // Underlying constructor reference\n",
        "context": "Leverage convenience accessors",
        "source": "howto",
        "title": "Leverage Convenience Accessors",
        "details": "Leverage convenience accessors"
      },
      {
        "lang": "ts",
        "code": "import { Metadata } from \"@decaf-ts/decoration\";\n\nMetadata.registerLibrary(\"@decaf-ts/decoration\", \"0.0.6\");\n\nexpect(() =>\n  Metadata.registerLibrary(\"@decaf-ts/decoration\", \"0.0.6\")\n).toThrow(/already/);\n",
        "context": "Prevent duplicate registration of flavour libraries via Metadata.registerLibrary.",
        "source": "howto",
        "title": "Prevent Duplicate Registration Of Flavour Libraries",
        "details": "Prevent duplicate registration of flavour libraries via Metadata.registerLibrary."
      },
      {
        "lang": "ts",
        "code": "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Org {}\n\nMetadata.set(Org, `${DecorationKeys.DESCRIPTION}.class`, \"Organization\");\nMetadata.set(Org, `${DecorationKeys.PROPERTIES}.name`, String);\n\nconsole.log(Metadata.get(Org, `${DecorationKeys.DESCRIPTION}.class`)); // \"Organization\"\nconsole.log(Metadata.type(Org, \"name\") === String); // true\n",
        "context": "Description: Use low-level get/set for arbitrary metadata paths.",
        "source": "howto",
        "title": "Description Use Low Level Get Set",
        "details": "Description: Use low-level get/set for arbitrary metadata paths."
      },
      {
        "lang": "ts",
        "code": "import { Metadata } from \"@decaf-ts/decoration\";\n\nclass File {\n  name!: string;\n  size!: number;\n}\n\nMetadata.set(File, \"properties.name\", String);\nMetadata.set(File, \"properties.size\", Number);\n\nconsole.log(Metadata.properties(File)); // [\"name\", \"size\"]\n",
        "context": "Description: Retrieve the keys that have recorded type info.",
        "source": "howto",
        "title": "Description Retrieve The Keys That Have",
        "details": "Description: Retrieve the keys that have recorded type info."
      },
      {
        "lang": "ts",
        "code": "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Temp {}\n;(Metadata as any).mirror = false; // disable\n\nMetadata.set(Temp, `${DecorationKeys.DESCRIPTION}.class`, \"Temporary\");\n\nconsole.log(Object.getOwnPropertyDescriptor(Temp, DecorationKeys.REFLECT)); // undefined\n// Re-enable when done\n;(Metadata as any).mirror = true;\n",
        "context": "Description: Disable mirroring to the constructor if desired.",
        "source": "howto",
        "title": "Description Disable Mirroring To The Constructor",
        "details": "Description: Disable mirroring to the constructor if desired."
      },
      {
        "lang": "ts",
        "code": "import { DefaultFlavour, ObjectKeySplitter, DecorationKeys } from \"@decaf-ts/decoration\";\n\nconsole.log(DefaultFlavour);     // \"decaf\"\nconsole.log(ObjectKeySplitter);  // \".\"\nconsole.log(DecorationKeys.PROPERTIES); // \"properties\"\n",
        "context": "Description: Access well-known keys and defaults when interacting with metadata.",
        "source": "howto",
        "title": "Description Access Well Known Keys And",
        "details": "Description: Access well-known keys and defaults when interacting with metadata."
      }
    ],
    "base_path": "decoration"
  },
  {
    "name": "logging",
    "title": "logging",
    "description": "# Logging Library — Detailed Description\n\nThe logging package is a lightweight, extensible logging solution for TypeScript projects. It centers on two main constructs:\n- MiniLogger — a minimal, context-aware logger used by default.\n- Logging — a static facade that manages global configuration, creates loggers for classes/functions/strings, and applies optional theming.\n\nIt also offers:\n- A concise set of decorators (log, debug, info, verbose, silly) to instrument methods with consistent logging and optional benchmarking.\n- Pluggable factories so that alternate implementations (e.g., WinstonLogger) can be used without changing call sites.\n- Strong typing for configuration and theming primitives.\n\nCore files and their roles\n- src/types.ts: Type definitions and contracts\n  - Logger: the runtime contract with methods silly, verbose, info, debug, error, for, setConfig.\n  - LoggingConfig: runtime configuration for filtering, formatting, and styling.\n  - LoggerFactory: factory signature returning a Logger for a given context and optional config.\n  - Theme/ThemeOption/ThemeOptionByLogLevel: shape of color and style configuration, optionally varying by LogLevel.\n  - Additional helpers: StringLike, AnyFunction, Class, LoggingContext.\n\n- src/constants.ts: Defaults and enums\n  - LogLevel: error | info | verbose | debug | silly (string values), plus NumericLogLevels for filtering.\n  - LoggingMode: RAW | JSON (current implementation focuses on RAW; JSON is available for adapters like Winston).\n  - DefaultTheme: sensible default colors/styles per component and per log level.\n  - DefaultLoggingConfig: default global configuration (info level, no styling, timestamp on, etc.).\n\n- src/logging.ts: Implementations and static facade\n  - MiniLogger: A small, dependency-light logger that:\n    - Generates formatted log strings (timestamp, log level, context, correlation id, message, stack) according to config.\n    - Supports child loggers via .for(method|config) with a Proxy to overlay per-child config and extend the context (class.method).\n    - Emits to console.log/console.debug/console.error based on level. Verbosity controls .silly output (gated by config.verbose).\n  - Logging: The static entry point that:\n    - Holds global configuration (Logging.getConfig(), Logging.setConfig()).\n    - Creates loggers for arbitrary contexts (Logging.for(object|class|function|string, config?)).\n    - Provides convenience static logging methods (info, debug, error, verbose, silly) delegating to a global logger instance.\n    - Supports theming (Logging.theme) by applying Theme options through styled-string-builder when style=true.\n    - Allows replacing the logger factory (Logging.setFactory) to integrate with other backends (e.g., Winston).\n\n- src/decorators.ts: Method decorators\n  - log(level=info, benchmark=false, verbosity=0): wraps a method to emit a call log and optionally a completion time; supports Promise-returning methods.\n  - debug/info/silly/verbose: concise wrappers around log() for common patterns.\n\n- src/LoggedClass.ts: Base convenience class\n  - LoggedClass exposes a protected this.log getter returning a context-aware Logger built via Logging.for(this), simplifying logging inside class methods.\n\n- src/winston/winston.ts: Optional Winston adapter\n  - WinstonLogger: extends MiniLogger but delegates emission to a configured Winston instance.\n  - WinstonFactory: a LoggerFactory you can install with Logging.setFactory(WinstonFactory) to globally route logs through Winston.\n\nDesign principles\n- Minimal by default: Console output with small surface area and no heavy dependencies (except styled-string-builder when style is enabled).\n- Config-driven: Behavior (level thresholds, verbosity, timestamps, separators, theming) is controlled via LoggingConfig.\n- Context-first: Log context is explicit (\"MyClass\" or \"MyClass.method\"), aiding filtering and debugging.\n- Extensible: Swap logger implementations via a factory; MiniLogger serves as a reference implementation.\n- Safe theming: Logging.theme guards against invalid theme keys and values and logs errors instead of throwing.\n\nKey behaviors\n- Level filtering: NumericLogLevels are used to compare configured level with the message level and decide emission.\n- Verbosity: .silly obeys LoggingConfig.verbose; only messages with <= configured verbosity are emitted.\n- Theming and styling: When style=true, Logging.theme applies Theme rules per component (class, message, logLevel, id, stack, timestamp). Theme can vary per LogLevel via ThemeOptionByLogLevel.\n- Correlation IDs: If correlationId is configured in a logger or child logger, it is included in output for easier traceability.\n\nPublic API surface\n- Classes: MiniLogger, Logging, LoggedClass; WinstonLogger (optional).\n- Decorators: log, debug, info, verbose, silly.\n- Enums/Consts: LogLevel, LoggingMode, NumericLogLevels, DefaultTheme, DefaultLoggingConfig.\n- Types: Logger, LoggingConfig, LoggerFactory, Theme, ThemeOption, ThemeOptionByLogLevel, LoggingContext.\n\nIntended usage\n- Use Logging.setConfig() at application startup to set level/style/timestamps.\n- Create class- or method-scoped loggers via Logging.for(MyClass) or logger.for('method').\n- Adopt LoggedClass to remove boilerplate in classes.\n- Add decorators to methods for automatic call/benchmark logs.\n- For advanced deployments, swap to WinstonFactory.\n",
    "summary": "Logging Library — Detailed Description The logging package is a lightweight, extensible logging solution for TypeScript projects.",
    "examples": [
      {
        "lang": "ts",
        "code": "import { Logging, LogLevel } from \"@decaf-ts/logging\";\n\n// Set global configuration\nLogging.setConfig({\n  level: LogLevel.debug, // allow debug and above\n  style: false,          // plain output (tests use both styled and themeless)\n  timestamp: false,      // omit timestamp for simplicity in this example\n});\n\n// Log using the global logger\nLogging.info(\"Application started\");\nLogging.debug(\"Debug details\");\nLogging.error(\"Something went wrong\");\n\n// Verbosity-controlled logs (silly delegates to verbose internally)\nLogging.setConfig({ verbose: 2 });\nLogging.silly(\"Extra details at verbosity 1\");      // emitted when verbose >= 1\nLogging.verbose(\"Even more details\", 2);            // only with verbose >= 2\n",
        "context": "Basic setup and global logging via Logging Description: Configure global logging and write messages through the static facade, similar to unit tests that verify console output and level filtering.",
        "source": "howto",
        "title": "Configure and Initialize",
        "details": "Basic setup and global logging via Logging Description: Configure global logging and write messages through the static facade, similar to unit tests that verify console output and level filtering."
      },
      {
        "lang": "ts",
        "code": "import { Logging, LogLevel } from \"@decaf-ts/logging\";\n\nLogging.setConfig({ level: LogLevel.debug });\n\n// A class-scoped logger\nconst classLogger = Logging.for(\"UserService\");\nclassLogger.info(\"Fetching users\");\n\n// A child logger for a specific method with temporary config overrides\nconst methodLogger = classLogger.for(\"list\", { style: false });\nmethodLogger.debug(\"Querying repository...\");\n",
        "context": "Create a class-scoped logger and child method logger Description: Create a logger bound to a specific context class and derive a child logger for a method, matching patterns used in tests.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "Create a class-scoped logger and child method logger Description: Create a logger bound to a specific context class and derive a child logger for a method, matching patterns used in tests."
      },
      {
        "lang": "ts",
        "code": "import { MiniLogger, LogLevel, type LoggingConfig } from \"@decaf-ts/logging\";\n\nconst logger = new MiniLogger(\"TestContext\");\nlogger.info(\"Info from MiniLogger\");\n\n// With custom configuration\nconst custom: Partial<LoggingConfig> = { level: LogLevel.debug, verbose: 2 };\nconst customLogger = new MiniLogger(\"TestContext\", custom);\ncustomLogger.debug(\"Debug with custom level\");\n\n// Child logger with correlation id\nconst traced = customLogger.for(\"run\", { correlationId: \"req-123\" });\ntraced.info(\"Tracing this operation\");\n",
        "context": "MiniLogger: direct use and per-instance config Description: Instantiate MiniLogger directly the default implementation behind Logging.setFactory. Tests create MiniLogger with and without custom config.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "MiniLogger: direct use and per-instance config Description: Instantiate MiniLogger directly the default implementation behind Logging.setFactory. Tests create MiniLogger with and without custom config."
      },
      {
        "lang": "ts",
        "code": "import { log, debug, info as infoDecor, verbose as verboseDecor, silly as sillyDecor, LogLevel, Logging } from \"@decaf-ts/logging\";\n\n// Configure logging for demo\nLogging.setConfig({ level: LogLevel.debug, style: false, timestamp: false });\n\nclass AccountService {\n  @log(LogLevel.info) // logs method call with args\n  create(name: string) {\n    return { id: \"1\", name };\n  }\n\n  @debug(true) // logs call and completion time at debug level\n  rebuildIndex() {\n    // heavy work...\n    return true;\n  }\n\n  @info() // convenience wrapper for info level\n  enable() {\n    return true;\n  }\n\n  @verbose(1, true) // verbose with verbosity threshold and benchmark\n  syncAll() {\n    return Promise.resolve(\"ok\");\n  }\n\n  @silly() // very chatty, only emitted when verbose allows\n  ping() {\n    return \"pong\";\n  }\n}\n\nconst svc = new AccountService();\nsvc.create(\"Alice\");\nsvc.rebuildIndex();\nsvc.enable();\nawait svc.syncAll();\nsvc.ping();\n",
        "context": "Decorators: log, debug, info, verbose, silly Description: Instrument methods to log calls and optional benchmarks. Tests validate decorator behavior for call and completion messages.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Decorators: log, debug, info, verbose, silly Description: Instrument methods to log calls and optional benchmarks. Tests validate decorator behavior for call and completion messages."
      },
      {
        "lang": "ts",
        "code": "import { LoggedClass } from \"@your-scope/logging\";\n\nclass UserRepository extends LoggedClass {\n  findById(id: string) {\n    this.log.info(`Finding ${id}`);\n    return { id };\n  }\n}\n\nconst repo = new UserRepository();\nrepo.findById(\"42\");\n",
        "context": "LoggedClass: zero-boilerplate logging inside classes Description: Extend LoggedClass to gain a protected this.log with the correct context class name. Tests use Logging.for to build similar context.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "LoggedClass: zero-boilerplate logging inside classes Description: Extend LoggedClass to gain a protected this.log with the correct context class name. Tests use Logging.for to build similar context."
      },
      {
        "lang": "ts",
        "code": "import { Logging } from \"@your-scope/logging\";\nimport { WinstonFactory } from \"@your-scope/logging/winston/winston\";\n\n// Install Winston as the logger factory\nLogging.setFactory(WinstonFactory);\n\n// Now any logger created will use Winston under the hood\nconst log = Logging.for(\"ApiGateway\");\nlog.info(\"Gateway started\");\n",
        "context": "Winston integration: swap the logger factory Description: Route all logging through WinstonLogger by installing WinstonFactory. This mirrors the optional adapter in src/winston.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "Winston integration: swap the logger factory Description: Route all logging through WinstonLogger by installing WinstonFactory. This mirrors the optional adapter in src/winston."
      },
      {
        "lang": "ts",
        "code": "import { Logging, LogLevel, DefaultTheme, type Theme } from \"@your-scope/logging\";\n\n// Enable styling globally\nLogging.setConfig({ style: true, timestamp: true, context: false });\n\n// Optionally override theme: make debug level yellow (fg:33) and error red+bold\nconst theme: Theme = {\n  ...DefaultTheme,\n  logLevel: {\n    ...DefaultTheme.logLevel,\n    debug: { fg: 33 },\n    error: { fg: 31, style: [\"bold\"] },\n  },\n};\n\n// Apply at runtime by passing to Logging.theme where needed (MiniLogger does this internally)\nconst styled = Logging.theme(\"debug\", \"logLevel\", LogLevel.debug, theme);\n\n// Regular logging picks up style=true and formats output accordingly\nLogging.debug(\"This is a styled debug message\");\n",
        "context": "Theming and styling with Logging.theme and config Description: Enable style and customize theme to colorize parts of the log tests check styled output patterns.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "Theming and styling with Logging.theme and config Description: Enable style and customize theme to colorize parts of the log tests check styled output patterns."
      },
      {
        "lang": "ts",
        "code": "import { Logging } from \"@your-scope/logging\";\n\n// Ad-hoc logger labeled with a reason and optional id (handy for correlation)\nconst jobLog = Logging.because(\"reindex\", \"job-77\");\njobLog.info(\"Starting reindex\");\n",
        "context": "Factory basics and becausereason, id Description: Create ad-hoc, labeled loggers and use factory semantics.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "Factory basics and becausereason, id Description: Create ad-hoc, labeled loggers and use factory semantics."
      },
      {
        "lang": "ts",
        "code": "import type { Logger, LoggingConfig } from \"@your-scope/logging\";\n\nexport interface ServiceDeps {\n  log: Logger;\n  config?: Partial<LoggingConfig>;\n}\n\nexport class PaymentService {\n  constructor(private deps: ServiceDeps) {}\n  charge(amount: number) {\n    this.deps.log.info(`Charging ${amount}`);\n  }\n}\n",
        "context": "Types: Logger and LoggingConfig in your code Description: Use the library’s types for better APIs.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Types: Logger and LoggingConfig in your code Description: Use the library’s types for better APIs."
      }
    ],
    "base_path": "logging"
  },
  {
    "name": "utils",
    "title": "utils",
    "description": "### Description\n\nThe Decaf Utils module is a comprehensive TypeScript utility library designed to standardize APIs across repositories and provide a robust foundation for building command-line interface (CLI) applications. The library is organized into several key components:\n\n#### CLI Module\nThe CLI module provides a structured framework for creating command-line applications:\n- Abstract `Command` class for implementing custom CLI commands with standardized input handling, logging, and execution flow\n- Command option handling with support for common flags like verbose, version, help, etc.\n- Standardized command execution flow with proper error handling\n\n#### Input Module\nThe Input module offers tools for handling user input and command-line arguments:\n- `UserInput` class for creating interactive prompts with various input types (text, number, confirmation, etc.)\n- Support for input validation, formatting, and default values\n- Command-line argument parsing with type checking and validation\n- Methods for repeatedly asking for input until valid responses are received\n\n#### Utils Module\nThe Utils module contains a wide range of utility functions:\n- **File System Operations**: Reading, writing, copying, and deleting files and directories\n- **Package Management**: Retrieving package information, managing dependencies, and version handling\n- **HTTP Utilities**: Simple client for downloading files from URLs\n- **Text Processing**: String interpolation, case conversion (camelCase, snake_case, etc.), and regular expression utilities\n- **Environment Handling**: Working with environment variables and configuration\n\n#### Writers Module\nThe Writers module provides different strategies for handling command output:\n- `OutputWriter` interface defining a standard contract for output handling\n- `StandardOutputWriter` for handling standard command-line output with proper logging\n- `RegexpOutputWriter` for processing output with regular expressions and pattern matching\n\n#### Output Module\nThe Output module offers utilities for formatting and displaying output:\n- Common output formatting functions\n- Banner display capabilities\n\nThis library serves as a light version of the Decaf CLI tool, providing all the essential utilities needed for building robust command-line applications with consistent input handling, output formatting, and error management.\n",
    "summary": "Description The Decaf Utils module is a comprehensive TypeScript utility library designed to standardize APIs across repositories and provide a robust foundation for building command-line interface CL…",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { Command, CommandOptions } from '@decaf-ts/utils';\n\n// Define input options interface\ninterface MyCommandOptions {\n  filename: string;\n  dryRun: boolean;\n}\n\n// Create a custom command class\nclass MyCommand extends Command<MyCommandOptions, string> {\n  constructor() {\n    // Define command options with their configurations\n    const options: CommandOptions<MyCommandOptions> = {\n      filename: {\n        type: 'string',\n        short: 'f',\n        default: 'output.txt'\n      },\n      dryRun: {\n        type: 'boolean',\n        short: 'd',\n        default: false\n      }\n    };\n\n    super('my-command', options);\n  }\n\n  // Override the help method to provide custom help information\n  protected help(): void {\n    this.log.info(`\n      Usage: my-command [options]\n\n      Options:\n        -f, --filename  Specify output filename (default: output.txt)\n        -d, --dryRun    Run without making changes (default: false)\n        -h, --help      Show help information\n        -v, --version   Show version information\n    `);\n  }\n\n  // Implement the run method to define command behavior\n  protected async run(answers: { filename: string; dryRun: boolean }): Promise<string> {\n    this.log.info(`Running command with filename: ${answers.filename}, dryRun: ${answers.dryRun}`);\n\n    // Command implementation here\n\n    return 'Command executed successfully';\n  }\n}\n\n// Execute the command\nasync function main() {\n  const command = new MyCommand();\n  const result = await command.execute();\n  console.log(result);\n}\n\nmain().catch(console.error);\n",
        "context": "The Command class provides a foundation for creating custom CLI commands with standardized input handling and execution flow.",
        "source": "howto",
        "title": "The Command Class Provides A Foundation",
        "details": "The Command class provides a foundation for creating custom CLI commands with standardized input handling and execution flow."
      },
      {
        "lang": "typescript",
        "code": "import { UserInput } from '@decaf-ts/utils';\n\nasync function collectUserInfo() {\n  // Create a text input for name\n  const nameInput = new UserInput('name')\n    .setMessage('What is your name?')\n    .setInitial('User');\n\n  // Create a number input for age with validation\n  const ageInput = new UserInput('age')\n    .setType('number')\n    .setMessage('How old are you?')\n    .setMin(0)\n    .setMax(120)\n    .setValidate(value => {\n      if (value < 18) return 'You must be at least 18 years old';\n      return true;\n    });\n\n  // Create a confirmation input\n  const confirmInput = new UserInput('confirm')\n    .setType('confirm')\n    .setMessage('Is this information correct?')\n    .setInitial(true);\n\n  // Ask for all inputs and get the answers\n  const answers = await UserInput.ask([nameInput, ageInput, confirmInput]);\n\n  console.log(`Hello ${answers.name}, you are ${answers.age} years old.`);\n  console.log(`Information confirmed: ${answers.confirm ? 'Yes' : 'No'}`);\n\n  return answers;\n}\n\ncollectUserInfo().catch(console.error);\n",
        "context": "The UserInput class allows you to create interactive prompts for collecting user input.",
        "source": "howto",
        "title": "The Userinput Class Allows You To",
        "details": "The UserInput class allows you to create interactive prompts for collecting user input."
      },
      {
        "lang": "typescript",
        "code": "import { UserInput } from '@decaf-ts/utils';\n\nasync function quickInputExample() {\n  // Ask for text input\n  const name = await UserInput.askText('name', 'What is your name?', undefined, 'User');\n\n  // Ask for number input\n  const age = await UserInput.askNumber('age', 'How old are you?', 0, 120);\n\n  // Ask for confirmation\n  const confirm = await UserInput.askConfirmation('confirm', 'Is this information correct?', true);\n\n  // Ask for text with validation and retry until valid\n  const email = await UserInput.insistForText(\n    'email',\n    'What is your email address?',\n    (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n    undefined,\n    undefined,\n    false,\n    3 // Maximum 3 attempts\n  );\n\n  console.log(`Name: ${name}, Age: ${age}, Email: ${email}, Confirmed: ${confirm}`);\n}\n\nquickInputExample().catch(console.error);\n",
        "context": "UserInput provides static convenience methods for common input scenarios.",
        "source": "howto",
        "title": "Userinput Provides Static Convenience Methods For",
        "details": "UserInput provides static convenience methods for common input scenarios."
      },
      {
        "lang": "typescript",
        "code": "import { UserInput, ParseArgsOptionsConfig } from '@decaf-ts/utils';\n\n// Define command-line options\nconst options: ParseArgsOptionsConfig = {\n  verbose: {\n    type: 'boolean',\n    short: 'V',\n    default: false\n  },\n  output: {\n    type: 'string',\n    short: 'o',\n    default: 'output.txt'\n  },\n  count: {\n    type: 'string',\n    short: 'c',\n    default: '10'\n  }\n};\n\n// Parse command-line arguments\nconst args = UserInput.parseArgs(options);\n\nconsole.log('Parsed arguments:', args.values);\nconsole.log('Positional arguments:', args.positionals);\n",
        "context": "Parsing Command-Line Arguments",
        "source": "howto",
        "title": "Parsing Command Line Arguments",
        "details": "Parsing Command-Line Arguments"
      },
      {
        "lang": "typescript",
        "code": "import { \n  readFile, \n  writeFile, \n  patchFile, \n  getAllFiles, \n  copyFile, \n  renameFile, \n  deletePath \n} from '@decaf-ts/utils';\n\n// Read a file\nconst content = readFile('./config.json');\nconsole.log('File content:', content);\n\n// Write to a file\nwriteFile('./output.txt', 'Hello, world!');\n\n// Patch a file with replacements\npatchFile('./template.txt', {\n  '{{name}}': 'John Doe',\n  '{{date}}': new Date().toISOString()\n});\n\n// Get all files in a directory\nconst files = getAllFiles('./src', (file) => file.endsWith('.ts'));\nconsole.log('TypeScript files:', files);\n\n// Copy a file\ncopyFile('./source.txt', './destination.txt');\n\n// Rename a file\nrenameFile('./old-name.txt', './new-name.txt');\n\n// Delete a file or directory\ndeletePath('./temp');\n",
        "context": "File System Operations",
        "source": "howto",
        "title": "File System Operations",
        "details": "File System Operations — Instantiates and configures a component."
      },
      {
        "lang": "typescript",
        "code": "import { \n  getPackage, \n  getPackageVersion, \n  setPackageAttribute, \n  getDependencies, \n  installDependencies \n} from '@decaf-ts/utils';\n\n// Get package information\nconst pkg = getPackage();\nconsole.log('Package:', pkg);\n\n// Get package version\nconst version = getPackageVersion();\nconsole.log('Version:', version);\n\n// Set a package attribute\nsetPackageAttribute('version', '1.0.1');\n\n// Get dependencies\nasync function manageDependencies() {\n  const deps = await getDependencies();\n  console.log('Production dependencies:', deps.prod);\n  console.log('Development dependencies:', deps.dev);\n  console.log('Peer dependencies:', deps.peer);\n\n  // Install dependencies\n  await installDependencies({\n    prod: ['lodash', 'axios'],\n    dev: ['typescript', 'jest']\n  });\n}\n\nmanageDependencies().catch(console.error);\n",
        "context": "Package Management",
        "source": "howto",
        "title": "Package Management",
        "details": "Package Management — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { HttpClient } from '@decaf-ts/utils';\n\nasync function downloadExample() {\n  try {\n    // Download a file from a URL\n    const content = await HttpClient.downloadFile('https://example.com/api/data.json');\n    console.log('Downloaded content:', content);\n\n    // Parse JSON content\n    const data = JSON.parse(content);\n    console.log('Parsed data:', data);\n\n    return data;\n  } catch (error) {\n    console.error('Download failed:', error);\n    throw error;\n  }\n}\n\ndownloadExample().catch(console.error);\n",
        "context": "HTTP Utilities",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "HTTP Utilities — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { \n  padEnd, \n  patchPlaceholders, \n  patchString, \n  toCamelCase, \n  toSnakeCase, \n  toKebabCase, \n  toPascalCase, \n  toENVFormat \n} from '@decaf-ts/utils';\n\n// Pad a string\nconst padded = padEnd('Hello', 10, '-');\nconsole.log(padded); // 'Hello-----'\n\n// Replace placeholders\nconst template = 'Hello, ${name}! Today is ${day}.';\nconst filled = patchPlaceholders(template, {\n  name: 'Alice',\n  day: 'Monday'\n});\nconsole.log(filled); // 'Hello, Alice! Today is Monday.'\n\n// Replace strings\nconst patched = patchString('Hello, world!', {\n  'world': 'universe'\n});\nconsole.log(patched); // 'Hello, universe!'\n\n// Case conversion\nconst text = 'hello world';\nconsole.log(toCamelCase(text));   // 'helloWorld'\nconsole.log(toSnakeCase(text));   // 'hello_world'\nconsole.log(toKebabCase(text));   // 'hello-world'\nconsole.log(toPascalCase(text));  // 'HelloWorld'\nconsole.log(toENVFormat(text));   // 'HELLO_WORLD'\n",
        "context": "Text Processing",
        "source": "howto",
        "title": "Text Processing",
        "details": "Text Processing"
      },
      {
        "lang": "typescript",
        "code": "import { StandardOutputWriter } from '@decaf-ts/utils';\n\n// Create a promise executor\nconst executor = {\n  resolve: (value: string) => console.log(`Command succeeded with: ${value}`),\n  reject: (error: Error) => console.error(`Command failed with: ${error.message}`)\n};\n\n// Create a standard output writer\nconst writer = new StandardOutputWriter('ls -la', executor);\n\n// Handle command output\nwriter.data('File list output...');\nwriter.data('file1.txt');\nwriter.data('file2.txt');\n\n// Handle command completion\nwriter.exit(0, ['Command executed successfully']);\n",
        "context": "Using StandardOutputWriter",
        "source": "howto",
        "title": "Using Standardoutputwriter",
        "details": "Using StandardOutputWriter — Instantiates and configures a component."
      },
      {
        "lang": "typescript",
        "code": "import { RegexpOutputWriter } from '@decaf-ts/utils';\n\n// Create a promise executor\nconst executor = {\n  resolve: (value: string) => console.log(`Found version: ${value}`),\n  reject: (error: Error) => console.error(`Error: ${error.message}`)\n};\n\n// Create a regexp output writer that matches version numbers\nconst writer = new RegexpOutputWriter('node --version', executor, /v(\\d+\\.\\d+\\.\\d+)/);\n\n// Process output that contains a version number\nwriter.data('v14.17.0');  // This will automatically resolve with \"v14.17.0\"\n\n// Process error output\nwriter.error('Command not found: node');  // This will be logged as an error\n",
        "context": "Using RegexpOutputWriter",
        "source": "howto",
        "title": "Using Regexpoutputwriter",
        "details": "Using RegexpOutputWriter — Instantiates and configures a component."
      }
    ],
    "base_path": "utils"
  },
  {
    "name": "reflection",
    "title": "reflection",
    "description": "## Description\n\nThe Reflection library is a powerful utility package for TypeScript applications that enhances runtime type inspection and metadata manipulation capabilities. Built on top of the `reflect-metadata` API, it provides a comprehensive set of tools for working with TypeScript's type system at runtime.\n\n### Core Components\n\n#### Reflection Class\nThe central component of the library is the `Reflection` class, which provides methods for:\n\n- **Type Checking**: Validate values against expected types at runtime with `checkType` and `checkTypes` methods\n- **Property Inspection**: Retrieve all properties of an object, including those in the prototype chain with `getAllProperties`\n- **Decorator Management**: Access and manipulate class and property decorators with methods like `getClassDecorators`, `getAllPropertyDecorators`, and `getPropertyDecorators`\n- **Type Extraction**: Extract type information from decorators with `getTypeFromDecorator`\n\n#### Decorator Utilities\nThe library includes decorator factory functions that simplify working with metadata:\n\n- **metadata**: A versatile decorator factory that attaches metadata to classes, methods, or properties\n- **apply**: A utility for applying multiple decorators to a single target in sequence\n\n#### Deep Equality Comparison\nThe `isEqual` function provides sophisticated deep equality checking between any two values with support for:\n\n- Primitive types with special handling for edge cases like NaN and +0/-0\n- Complex objects including Arrays, Maps, Sets, Dates, RegExp, and Error objects\n- TypedArrays with byte-by-byte comparison\n- Property exclusion through the optional `propsToIgnore` parameter\n\n#### Type Definitions\nThe library defines several TypeScript types to provide structure for working with decorators and metadata:\n\n- **DecoratorMetadata**: Represents metadata associated with decorators\n- **ClassDecoratorsList**: Collection of class decorators\n- **PropertyDecoratorList**: Maps property names to their decorators\n- **FullPropertyDecoratorList**: Complete decorator information for properties\n\n### Integration with TypeScript Ecosystem\n\nThe Reflection library is designed to work seamlessly with TypeScript's type system and the `reflect-metadata` API. It enhances TypeScript's compile-time type checking with runtime validation capabilities, making it an essential tool for building robust, type-safe applications.\n\n### Use Cases\n\n- **Runtime Type Validation**: Verify that values conform to expected types during program execution\n- **Framework Development**: Build frameworks that leverage TypeScript's type system at runtime\n- **Object Comparison**: Perform deep equality checks between complex objects\n- **Metadata-Driven Architecture**: Create systems that use metadata to drive behavior\n\nPlease follow the Contributing guide or the developer's guide to contribute to this library. All help is appreciated.\n\nTechnical documentation can be found [here](https://decaf-ts.github.io/reflection/)\n",
    "summary": "Description The Reflection library is a powerful utility package for TypeScript applications that enhances runtime type inspection and metadata manipulation capabilities.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Check if a value is a string\nconst value = \"Hello, world!\";\nconst isString = reflection.checkType(value, String); // Returns true\n\n// Check if a value is a number\nconst num = 42;\nconst isNumber = reflection.checkType(num, Number); // Returns true\n\n// Check if a value is an instance of a class\nclass Person {\n  constructor(public name: string) {}\n}\nconst person = new Person(\"John\");\nconst isPerson = reflection.checkType(person, Person); // Returns true\n",
        "context": "Description: Validate that a value matches an expected type at runtime.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Description: Validate that a value matches an expected type at runtime."
      },
      {
        "lang": "typescript",
        "code": "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Check if a value is either a string or a number\nconst value1 = \"Hello\";\nconst value2 = 42;\n\nconst isStringOrNumber1 = reflection.checkTypes(value1, [String, Number]); // Returns true\nconst isStringOrNumber2 = reflection.checkTypes(value2, [String, Number]); // Returns true\nconst isStringOrNumber3 = reflection.checkTypes(true, [String, Number]); // Returns false\n",
        "context": "Description: Validate that a value matches any of the expected types at runtime.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Description: Validate that a value matches any of the expected types at runtime."
      },
      {
        "lang": "typescript",
        "code": "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\nclass BaseClass {\n  baseProperty = 'base';\n\n  baseMethod() {\n    return 'base method';\n  }\n}\n\nclass DerivedClass extends BaseClass {\n  derivedProperty = 'derived';\n\n  derivedMethod() {\n    return 'derived method';\n  }\n}\n\nconst instance = new DerivedClass();\n\n// Get all properties including those from the prototype chain\nconst allProps = reflection.getAllProperties(instance, true);\nconsole.log(allProps); \n// Output includes: 'baseProperty', 'baseMethod', 'derivedProperty', 'derivedMethod'\n\n// Get only own properties\nconst ownProps = reflection.getAllProperties(instance, false);\nconsole.log(ownProps); \n// Output includes only: 'baseProperty', 'derivedProperty'\n",
        "context": "Description: Retrieve all properties of an object, including those in the prototype chain.",
        "source": "howto",
        "title": "Description Retrieve All Properties Of An",
        "details": "Description: Retrieve all properties of an object, including those in the prototype chain."
      },
      {
        "lang": "typescript",
        "code": "import { Reflection, metadata } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Define some decorators\nconst EntityDecorator = metadata('entity', { name: 'User' });\nconst ValidateDecorator = metadata('validate', { required: true });\n\n// Apply decorators to a class\n@EntityDecorator\n@ValidateDecorator\nclass User {\n  id: number;\n  name: string;\n}\n\n// Get all decorators with 'entity' prefix\nconst entityDecorators = reflection.getClassDecorators('entity', User);\nconsole.log(entityDecorators);\n// Output: [{ key: 'entity', props: { name: 'User' } }]\n",
        "context": "Description: Retrieve decorators applied to a class that match a specific prefix.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Retrieve decorators applied to a class that match a specific prefix."
      },
      {
        "lang": "typescript",
        "code": "import { Reflection, metadata } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Define some property decorators\nconst ColumnDecorator = metadata('column', { type: 'varchar' });\nconst ValidateDecorator = metadata('validate', { required: true });\n\nclass User {\n  @ColumnDecorator\n  @ValidateDecorator\n  name: string;\n}\n\n// Get all decorators with 'column' prefix for the 'name' property\nconst columnDecorators = reflection.getPropertyDecorators('column', User, 'name');\nconsole.log(columnDecorators);\n// Output: [{ key: 'column', props: { type: 'varchar' } }]\n",
        "context": "Description: Retrieve decorators applied to a property that match a specific prefix.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Retrieve decorators applied to a property that match a specific prefix."
      },
      {
        "lang": "typescript",
        "code": "import { metadata } from '@decaf-ts/reflection';\n\n// Create a decorator for marking a class as an entity\nconst Entity = (name: string) => metadata('entity', { name });\n\n// Create a decorator for marking a property as a column\nconst Column = (options: { type: string, nullable?: boolean }) => \n  metadata('column', options);\n\n// Apply decorators\n@Entity('users')\nclass User {\n  @Column({ type: 'int', nullable: false })\n  id: number;\n\n  @Column({ type: 'varchar', nullable: true })\n  name: string;\n}\n\n// The metadata can later be retrieved using Reflection methods\n",
        "context": "Description: Create and apply a decorator that attaches metadata to a class, method, or property.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Create and apply a decorator that attaches metadata to a class, method, or property."
      },
      {
        "lang": "typescript",
        "code": "import { apply, metadata } from '@decaf-ts/reflection';\n\n// Create individual decorators\nconst Required = metadata('validate', { required: true });\nconst MaxLength = (length: number) => metadata('validate', { maxLength: length });\nconst Email = metadata('validate', { isEmail: true });\n\n// Create a composite decorator using apply\nconst ValidEmail = apply(\n  Required,\n  MaxLength(100),\n  Email\n);\n\nclass User {\n  // Apply multiple validations with a single decorator\n  @ValidEmail\n  email: string;\n}\n\n// This is equivalent to:\n// @Required\n// @MaxLength(100)\n// @Email\n// email: string;\n",
        "context": "Description: Apply multiple decorators to a single target in a single decorator.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Apply multiple decorators to a single target in a single decorator."
      },
      {
        "lang": "typescript",
        "code": "import { isEqual } from '@decaf-ts/reflection';\n\n// Compare primitive values\nconsole.log(isEqual(1, 1)); // true\nconsole.log(isEqual('hello', 'hello')); // true\nconsole.log(isEqual(1, '1')); // false (different types)\n\n// Compare objects\nconst obj1 = { name: 'John', age: 30 };\nconst obj2 = { name: 'John', age: 30 };\nconst obj3 = { name: 'Jane', age: 30 };\n\nconsole.log(isEqual(obj1, obj2)); // true\nconsole.log(isEqual(obj1, obj3)); // false\n\n// Compare with ignored properties\nconst user1 = { id: 1, name: 'John', createdAt: new Date('2023-01-01') };\nconst user2 = { id: 2, name: 'John', createdAt: new Date('2023-02-01') };\n\n// Compare ignoring 'id' and 'createdAt'\nconsole.log(isEqual(user1, user2, 'id', 'createdAt')); // true\n\n// Compare complex structures\nconst complex1 = {\n  data: [1, 2, 3],\n  metadata: new Map([['key1', 'value1']]),\n  date: new Date('2023-01-01')\n};\n\nconst complex2 = {\n  data: [1, 2, 3],\n  metadata: new Map([['key1', 'value1']]),\n  date: new Date('2023-01-01')\n};\n\nconsole.log(isEqual(complex1, complex2)); // true\n",
        "context": "Description: Compare two objects deeply to determine if they are equal, with the ability to ignore specific properties.",
        "source": "howto",
        "title": "Description Compare Two Objects Deeply To",
        "details": "Description: Compare two objects deeply to determine if they are equal, with the ability to ignore specific properties."
      },
      {
        "lang": "typescript",
        "code": "import { ReflectionKeys, metadata } from '@decaf-ts/reflection';\nimport 'reflect-metadata';\n\n// Define a class with a property\nclass User {\n  name: string;\n}\n\n// Access the type metadata\nconst typeMetadata = Reflect.getMetadata(ReflectionKeys.TYPE, User.prototype, 'name');\nconsole.log(typeMetadata === String); // true (if emitDecoratorMetadata is enabled)\n\n// Define a custom decorator that uses ReflectionKeys\nfunction TypedProperty() {\n  return (target: any, propertyKey: string) => {\n    const type = Reflect.getMetadata(ReflectionKeys.TYPE, target, propertyKey);\n    console.log(`Property ${propertyKey} has type: ${type.name}`);\n  };\n}\n\nclass Product {\n  @TypedProperty()\n  price: number;\n}\n// Output: \"Property price has type: Number\"\n",
        "context": "Description: Use the predefined metadata keys for accessing type information.",
        "source": "howto",
        "title": "Description Use The Predefined Metadata Keys",
        "details": "Description: Use the predefined metadata keys for accessing type information."
      },
      {
        "lang": "typescript",
        "code": "import { Reflection, metadata, apply } from '@decaf-ts/reflection';\n\n// Create validation decorators\nconst Required = metadata('validate', { required: true });\nconst MinLength = (min: number) => metadata('validate', { minLength: min });\nconst MaxLength = (max: number) => metadata('validate', { maxLength: max });\nconst Email = metadata('validate', { isEmail: true });\n\n// Create a validator class\nclass Validator {\n  private reflection = new Reflection();\n\n  validate(instance: any): { isValid: boolean, errors: string[] } {\n    const errors: string[] = [];\n    const constructor = instance.constructor;\n\n    // Get all properties with validation decorators\n    const decoratedProps = this.reflection.getAllPropertyDecorators(constructor, ['validate']);\n\n    for (const propName in decoratedProps) {\n      const value = instance[propName];\n      const validators = decoratedProps[propName];\n\n      for (const validator of validators) {\n        const props = validator.props as Record<string, any>;\n\n        // Check required\n        if (props.required && (value === undefined || value === null || value === '')) {\n          errors.push(`${propName} is required`);\n        }\n\n        // Skip other validations if value is not present\n        if (value === undefined || value === null) continue;\n\n        // Check minLength\n        if (props.minLength && typeof value === 'string' && value.length < props.minLength) {\n          errors.push(`${propName} must be at least ${props.minLength} characters`);\n        }\n\n        // Check maxLength\n        if (props.maxLength && typeof value === 'string' && value.length > props.maxLength) {\n          errors.push(`${propName} must be at most ${props.maxLength} characters`);\n        }\n\n        // Check email\n        if (props.isEmail && typeof value === 'string') {\n          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n          if (!emailRegex.test(value)) {\n            errors.push(`${propName} must be a valid email address`);\n          }\n        }\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// Use the validation system\nclass User {\n  @Required\n  id: number;\n\n  @apply(Required, MinLength(3), MaxLength(50))\n  name: string;\n\n  @apply(Required, Email)\n  email: string;\n}\n\nconst validator = new Validator();\n\n// Valid user\nconst validUser = new User();\nvalidUser.id = 1;\nvalidUser.name = \"John Doe\";\nvalidUser.email = \"john@example.com\";\nconsole.log(validator.validate(validUser)); \n// { isValid: true, errors: [] }\n\n// Invalid user\nconst invalidUser = new User();\ninvalidUser.name = \"Jo\";\ninvalidUser.email = \"not-an-email\";\nconsole.log(validator.validate(invalidUser));\n// { \n//   isValid: false, \n//   errors: [\n//     'id is required',\n//     'name must be at least 3 characters',\n//     'email must be a valid email address'\n//   ] \n// }\n",
        "context": "Description: Create a validation system using reflection and decorators.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Description: Create a validation system using reflection and decorators."
      }
    ],
    "base_path": "reflection"
  },
  {
    "name": "decorator-validation",
    "title": "decorator-validation",
    "description": "# Decorator Validation – Detailed Description\n\nDecorator Validation is a TypeScript library that centers on two complementary pillars:\n\n1) Declarative validation via decorators\n- A rich set of property decorators such as @required, @min, @max, @minLength, @maxLength, @pattern, @email, @url, @type, @equals, @greaterThan, @greaterThanOrEqual, @lessThan, @lessThanOrEqual, @step, @list, @diff, @date, @password, as well as an async() flag helper.\n- Each decorator writes strongly-typed metadata using reflect-metadata and a common Validation metadata keying convention, so validators can later interpret the rules consistently.\n- Decorators are defined in src/validation/decorators.ts and are backed by concrete Validator classes in src/validation/Validators/* that implement the actual validation logic.\n\n2) A model system tailored for validation, building, hashing, and serialization\n- Models are ordinary classes marked with @model() (src/model/decorators.ts). The decorator replaces the constructor, binds the model prototype utilities, runs a global builder (if registered), and tags reflection metadata for identification.\n- Additional class-level decorators configure algorithms:\n  - @hashedBy(algorithm, ...args) to define model hashing implementation.\n  - @serializedBy(serializer, ...args) to define serialization strategy.\n  - @description(text) to attach human-readable documentation to a class, property, or method.\n- The Model class (src/model/Model.ts) provides:\n  - A ModelRegistryManager for registering and retrieving model constructors by name, enabling rebuild/deserialize flows.\n  - Validation integration (model/validation.ts) that runs the registered validators against metadata collected by decorators.\n  - Utility methods and metadata helpers to identify models, fetch metadata, compare instances, and orchestrate hashing/serialization strategies.\n\nCore runtime architecture\n- Validation namespace (src/validation/Validation.ts):\n  - Manages a pluggable IValidatorRegistry so custom Validator implementations can be registered, migrated, and queried.\n  - Exposes helper utilities: Validation.key(key) for reflect-metadata keying, Validation.keys() to list available validator keys, register(...) and get(...) to manage validators, decorator registration to link a metadata key to its decorator for dynamic use.\n- Validator classes (src/validation/Validators/*):\n  - BaseValidator.ts defines common behaviors; concrete validators (RequiredValidator, MinValidator, PatternValidator, etc.) implement validate and message/typing logic.\n  - ValidatorRegistry.ts stores Validator instances keyed by ValidationKeys constants.\n  - constants.ts defines DEFAULT_ERROR_MESSAGES, DEFAULT_PATTERNS, and ValidationKeys (e.g., REQUIRED, MIN, MAX...).\n  - decorators.ts contains decorator sugar for directly registering standard validators and building metadata using Decoration/Reflection utilities.\n- Utilities (src/utils/*):\n  - strings, dates, types, serialization, hashing, registry, decorators, Decoration helper, and a PathProxy to traverse nested properties and apply metadata.\n\nIntent of the library\n- Provide a cohesive, decorator-first developer experience for enforcing validation constraints on model classes.\n- Ensure that validation, model lifecycle (build/serialize/hash), and metadata are consistent and extensible through registries.\n- Allow advanced composition (custom validators, alternative registries), and integration into automation flows (MCP tools).\n\nDesign principles\n- Declarative over imperative: Constraints live next to the properties they validate.\n- Extensibility: Registries and helper factories allow swapping implementations without changing consumer code.\n- Type safety: Metadata and decorators are typed; validators advertise supported types; utility functions use narrow types where practical.\n- Separation of concerns: Decorators express intent; Validator classes implement behavior; Model provides lifecycle utilities.\n",
    "summary": "Decorator Validation – Detailed Description Decorator Validation is a TypeScript library that centers on two complementary pillars: 1 Declarative validation via decorators - A rich set of property dec…",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { model, Model, ModelArg } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass User extends Model {\n  @prop()\n  id!: string;\n  @prop()\n  name!: string;\n  \n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nconst u = new User();\n",
        "context": "@model Description: Marks a class as a model. The constructor is wrapped to bind model utilities and run a global builder if any.",
        "source": "howto",
        "title": "Model Description Marks A Class As",
        "details": "@model Description: Marks a class as a model. The constructor is wrapped to bind model utilities and run a global builder if any."
      },
      {
        "lang": "typescript",
        "code": "import { required, Model, model, ModelArg } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Child extends Model {\n  @required()\n  name!: string;\n  \n  constructor(arg?: ModelArg<Child>) {\n    super(arg);\n  }\n}\n\n@model()\nclass Parent extends Model {\n  @required()\n  name!: string;\n  @required()\n  child!: Child;\n  constructor(arg?: ModelArg<Parent>) {\n    super(arg);\n  }\n}\n// Default builder is Model.fromModel\n\nlet parent = new Parent({\n  child: {\n    name: \"child\"\n  }\n})\n\nparent.child instanceof Child; // true\n\nModel.setBuilder(Model.fromObject);\n\nparent = new Parent({\n  child: {\n    name: \"child\"\n  }\n})\n\nparent.child instanceof Child; // false\n",
        "context": "You can change between builder functions by using:",
        "source": "howto",
        "title": "You Can Change Between Builder Functions",
        "details": "You can change between builder functions by using:"
      },
      {
        "lang": "typescript",
        "code": "import { model, hashedBy, ModelArg, prop } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@hashedBy(\"sha256\", \"utf8\")\nclass FileInfo extends Model {\n  @prop()\n  path!: string;\n  @prop()\n  size!: number;\n  \n  constructor(arg?: ModelArg<FileInfo>) {\n    super(arg)\n  }\n}\n",
        "context": "@hashedByalgorithm, ...args Description: Declares which hashing strategy to use when hashing model instances.",
        "source": "howto",
        "title": "Database Access",
        "details": "@hashedByalgorithm, ...args Description: Declares which hashing strategy to use when hashing model instances."
      },
      {
        "lang": "typescript",
        "code": "import { prop, ModelArg, model, serializedBy } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@serializedBy(\"json\")\nclass Settings extends Model {\n  @prop()\n  theme!: string;\n  @prop()\n  locale!: string;\n  \n  constructor(arg?: ModelArg<Settings>){\n    super(arg)\n  }\n}\n",
        "context": "@serializedByserializer, ...args Description: Declares which serializer to use for deserializing model instances.",
        "source": "howto",
        "title": "Database Access",
        "details": "@serializedByserializer, ...args Description: Declares which serializer to use for deserializing model instances."
      },
      {
        "lang": "typescript",
        "code": "import { model, description, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@description(\"Represents an application user\")\nclass User extends Model {\n  @description(\"Unique identifier\")\n  id!: string;\n  // ...\n}\n",
        "context": "@descriptiontext Description: Applies textual documentation metadata to a class, property, or method.",
        "source": "howto",
        "title": "Descriptiontext Description Applies Textual Documentation Metadata",
        "details": "@descriptiontext Description: Applies textual documentation metadata to a class, property, or method."
      },
      {
        "lang": "typescript",
        "code": "import { Model, required, model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass User extends Model {\n  @required()\n  username!: string;\n  //...\n}\n",
        "context": "@requiredmessage? Description: Field must be present and non-empty.",
        "source": "howto",
        "title": "Requiredmessage Description Field Must Be Present",
        "details": "@requiredmessage? Description: Field must be present and non-empty."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { min } from \"@decaf-ts/decorator-validation\";\nimport { max } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Product extends Model {\n  @min(0)\n  @max(1000)\n  price!: number;\n}\n",
        "context": "@minvalue, message? and @maxvalue, message? Description: Numeric or date boundaries.",
        "source": "howto",
        "title": "Minvalue Message And Maxvalue Message Description",
        "details": "@minvalue, message? and @maxvalue, message? Description: Numeric or date boundaries."
      },
      {
        "lang": "typescript",
        "code": "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { minLength, maxLength } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Credentials extends Model {\n  @minLength(8)\n  @maxLength(64)\n  password!: string;\n}\n",
        "context": "@minLengthn, message? and @maxLengthn, message? Description: String length boundaries.",
        "source": "howto",
        "title": "Minlengthn Message And Maxlengthn Message Description",
        "details": "@minLengthn, message? and @maxLengthn, message? Description: String length boundaries."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { pattern, model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Vehicle extends Model {\n  @pattern(/^[A-Z]{2}-\\d{2}-[A-Z]{2}$/)\n  plate!: string;\n}\n",
        "context": "@patternregex | string, message? Description: String must match a pattern.",
        "source": "howto",
        "title": "Patternregex String Message Description String Must",
        "details": "@patternregex | string, message? Description: String must match a pattern."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { email } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Contact extends Model {\n  @email()\n  email!: string;\n}\n",
        "context": "@emailmessage? Description: Must be a valid email.",
        "source": "howto",
        "title": "Emailmessage Description Must Be A Valid",
        "details": "@emailmessage? Description: Must be a valid email."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { url } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Link extends Model {\n  @url()\n  href!: string;\n}\n",
        "context": "@urlmessage? Description: Must be a valid URL.",
        "source": "howto",
        "title": "Urlmessage Description Must Be A Valid",
        "details": "@urlmessage? Description: Must be a valid URL."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { type } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Measurement extends Model {\n  @type(Number)\n  value!: number;\n}\n",
        "context": "@typeT, message? Description: Enforces a runtime type match e.g., Number, String, Date.",
        "source": "howto",
        "title": "Typet Message Description Enforces A Runtime",
        "details": "@typeT, message? Description: Enforces a runtime type match e.g., Number, String, Date."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { equals } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Confirmation extends Model {\n  password!: string;\n  @equals(\":password\")\n  confirm!: string;\n}\n",
        "context": "@equalsotherValueOrPath, message? Description: Value must equal the provided value or another property.",
        "source": "howto",
        "title": "Equalsothervalueorpath Message Description Value Must Equal",
        "details": "@equalsotherValueOrPath, message? Description: Value must equal the provided value or another property."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Range extends Model {\n  @greaterThan(0)\n  @lessThanOrEqual(100)\n  ratio!: number;\n}\n",
        "context": "@greaterThanx / @greaterThanOrEqualx / @lessThanx / @lessThanOrEqualx Description: Numeric or date comparisons.",
        "source": "howto",
        "title": "Greaterthanx Greaterthanorequalx Lessthanx Lessthanorequalx Description Numeric",
        "details": "@greaterThanx / @greaterThanOrEqualx / @lessThanx / @lessThanOrEqualx Description: Numeric or date comparisons."
      },
      {
        "lang": "typescript",
        "code": "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { step } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Slider extends Model {\n  @step(0.5)\n  value!: number;\n}\n",
        "context": "@stepstep, message? Description: Numeric step constraints.",
        "source": "howto",
        "title": "Stepstep Message Description Numeric Step Constraints",
        "details": "@stepstep, message? Description: Numeric step constraints."
      },
      {
        "lang": "typescript",
        "code": "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { list } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass ThemeSettingm extends Model {\n  @list([\"light\", \"dark\", \"system\"]) \n  theme!: \"light\" | \"dark\" | \"system\";\n}\n",
        "context": "@listvalues, message? Description: Constrains value to be one of the provided list.",
        "source": "howto",
        "title": "Listvalues Message Description Constrains Value To",
        "details": "@listvalues, message? Description: Constrains value to be one of the provided list."
      },
      {
        "lang": "typescript",
        "code": "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { diff } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Credentials extends Model {\n  username!: string;\n  @diff(\":username\")\n  password!: string;\n}\n",
        "context": "@diffpropertyPath, message? Description: Must be different from another property.",
        "source": "howto",
        "title": "Diffpropertypath Message Description Must Be Different",
        "details": "@diffpropertyPath, message? Description: Must be different from another property."
      },
      {
        "lang": "typescript",
        "code": "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { date } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Booking extends Model {\n  @date({ min: new Date(\"2025-01-01\"), max: new Date(\"2025-12-31\") })\n  start!: Date;\n}\n",
        "context": "@date{ min?, max? }, message? Description: Date constraints for a date-typed field.",
        "source": "howto",
        "title": "Date Min Max Message Description Date",
        "details": "@date{ min?, max? }, message? Description: Date constraints for a date-typed field."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { password, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Account extends Model{\n  @password({ minLength: 10 })\n  password!: string;\n}\n",
        "context": "@passwordoptions?, message? Description: Password strength constraints e.g., min length, uppercase, digits, symbols depending on validator configuration.",
        "source": "howto",
        "title": "Passwordoptions Message Description Password Strength Constraints",
        "details": "@passwordoptions?, message? Description: Password strength constraints e.g., min length, uppercase, digits, symbols depending on validator configuration."
      },
      {
        "lang": "typescript",
        "code": "import { model } from \"@decaf-ts/decorator-validation\";\nimport { async } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@async()\nclass Signup {\n  // fields that may use async validators\n}\n",
        "context": "async Description: Marks a model as involving async validation rules decorator flag helper.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "async Description: Marks a model as involving async validation rules decorator flag helper."
      },
      {
        "lang": "typescript",
        "code": "import { model, required, email, validate, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Contact extends Model {\n  @required()\n  @email()\n  email!: string;\n  \n  constructor(arg?: ModelArg<Contact>) {\n    super(arg);\n  }\n}\n\nconst c = new Contact({\n  email: \"not-an-email\"\n});\n\nlet errs = c.hasErrors(); // resolves to a list of errors or undefined\n\n@async()\n@model()\nclass User extends Model {\n  @required()\n  @email()\n  email!: string;\n  \n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nconst u = new User({\n  email: \"not-an-email\"\n})\n\nerrs = await u.hasErrors(); // resolves to a list of errors or undefined\n\n",
        "context": "Running validation Use the model validation utilities to evaluate rules defined by decorators.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Running validation Use the model validation utilities to evaluate rules defined by decorators."
      },
      {
        "lang": "typescript",
        "code": "import { Validation, ValidatorRegistry } from \"@decaf-ts/decorator-validation\";\n\nconst custom = new ValidatorRegistry();\nValidation.setRegistry(custom, v => v); // trivial migration\n",
        "context": "Validation.setRegistryregistry, migration? Description: Swap the active validator registry and optionally migrate validators.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Validation.setRegistryregistry, migration? Description: Swap the active validator registry and optionally migrate validators."
      },
      {
        "lang": "typescript",
        "code": "import { Validation, Validator, validator } from \"@decaf-ts/decorator-validation\";\n\n@validator(\"ALWAYS_OK\")\nclass AlwaysOk extends Validator {\n  hasErrors(...args: any[]) { return []; }\n}\n\nValidation.register(new AlwaysOk());\n",
        "context": "Validation.register...validators Description: Register one or more Validator implementations or definitions.",
        "source": "howto",
        "title": "Configure and Initialize",
        "details": "Validation.register...validators Description: Register one or more Validator implementations or definitions."
      }
    ],
    "base_path": "decorator-validation"
  },
  {
    "name": "injectable-decorators",
    "title": "injectable-decorators",
    "description": "### Description\n\nThe `injectable-decorators` library is a standalone module that provides a lightweight and flexible dependency injection system for TypeScript applications. It is designed to simplify the management of dependencies between components in your application through the use of TypeScript decorators.\n\n#### Core Components\n\n1. **Injectables Registry**\n   - The central component that manages all injectable objects\n   - Maintains a cache of singleton instances\n   - Provides methods for registering, retrieving, and building injectable objects\n   - Can be customized with a different implementation if needed\n\n2. **Decorators**\n   - `@injectable()`: Class decorator that marks a class as available for dependency injection\n     - Transforms the class into a singleton that can be retrieved from the registry\n     - Supports optional category naming for minification safety\n     - Allows for custom callbacks after instance creation\n   - `@inject()`: Property decorator that injects a dependency into a class property\n     - Automatically resolves the dependency type from TypeScript's type system\n     - Supports custom transformers to modify the injected instance\n     - Implements lazy loading - dependencies are only instantiated when accessed\n\n3. **Reflection Utilities**\n   - Uses TypeScript's reflection metadata to determine property types\n   - Provides utilities for working with type information in decorators\n\n#### Key Features\n\n- **Singleton Management**: Injectables are typically managed as singletons, ensuring consistent state across your application.\n- **Lazy Loading**: Dependencies are only instantiated when they are actually accessed, simplifying the injection order and improving performance.\n- **Type Safety**: Leverages TypeScript's type system to ensure type safety in injected dependencies.\n- **Minification Support**: Provides options to specify explicit names for injectables to handle minification scenarios.\n- **Custom Transformations**: Supports transforming injectable instances before they're injected into target objects.\n- **Selective Reset**: Ability to selectively reset specific injectables in the registry based on name patterns.\n\n#### Design Philosophy\n\nThe library follows a minimalist approach, focusing on providing essential dependency injection capabilities without unnecessary complexity. It's designed to be:\n\n- **Lightweight**: Small footprint with minimal dependencies\n- **Flexible**: Adaptable to different application architectures\n- **Intuitive**: Simple API that follows natural TypeScript patterns\n- **Non-intrusive**: Minimal impact on your existing code structure\n\nUnlike more complex DI frameworks, this library doesn't require extensive configuration or setup. The developer is responsible for initially decorating classes and properties, but the library handles the instantiation and injection process automatically.\n",
    "summary": "Description The injectable-decorators library is a standalone module that provides a lightweight and flexible dependency injection system for TypeScript applications.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { injectable, Injectables } from 'injectable-decorators';\n\n@injectable()\nclass InitialObject {\n  doSomething() { return 5; }\n}\n\nconst obj = new InitialObject();\nconst same = Injectables.get(InitialObject);\n// obj and same refer to the same instance (singleton by default)\n",
        "context": "Description: Define a class with @injectable so it becomes available through the central registry. Creating with new returns the instance managed by the registry.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: Define a class with @injectable so it becomes available through the central registry. Creating with new returns the instance managed by the registry."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { injectable, inject, Injectables } from 'injectable-decorators';\n\n@injectable()\nclass SomeService { value = 5; }\n\nclass Controller {\n  @inject()\n  service!: SomeService; // non-null assertion because it's set outside the constructor\n}\n\nconst c = new Controller();\nconsole.log(c.service.value); // 5\nconsole.log(c.service === Injectables.get(SomeService)); // true\n",
        "context": "Description: Use @inject on a typed property. The instance is created lazily when the property is first accessed and cached thereafter.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: Use @inject on a typed property. The instance is created lazily when the property is first accessed and cached thereafter."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { injectable, inject, singleton } from 'injectable-decorators';\n\n@singleton()\nclass AAA { a = 'aaa'; }\n\n@injectable('AAA')\nclass BBB extends AAA { b = 'bbb'; }\n\nconst b = new BBB();\n\nclass Host {\n  @inject()\n  repo!: AAA; // resolves to the instance registered under category 'AAA'\n}\n\nconst h = new Host();\nconsole.log(h.repo === b); // true\n",
        "context": "Description: Provide a stable name when class names may change e.g., minification or to upcast through a base type.",
        "source": "howto",
        "title": "Description Provide A Stable Name When",
        "details": "Description: Provide a stable name when class names may change e.g., minification or to upcast through a base type."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { inject, singleton } from 'injectable-decorators';\n\nclass DDD { a = 'aaa'; }\n\n@singleton('EEE')\nclass CCC extends DDD { b = 'bbb'; }\n\nconst instance = new CCC();\n\nclass Holder {\n  @inject('EEE')\n  repo!: CCC;\n}\n\nconst h = new Holder();\nconsole.log(h.repo === instance); // true\n",
        "context": "Description: When a different string category was used at registration, pass that string to @inject.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: When a different string category was used at registration, pass that string to @inject."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { injectable, inject } from 'injectable-decorators';\n\nclass Token {}\n\n@injectable(Token, { callback: (original) => original })\nclass Impl {\n  id = 1;\n}\n\nclass UsesImpl {\n  @inject(Token)\n  object!: Impl; // injects the instance registered under Token (Impl instance)\n}\n\nconst u = new UsesImpl();\nconsole.log(u.object instanceof Impl); // true\n",
        "context": "Description: You can register an injectable using another constructor as the category, then inject it by that constructor.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: You can register an injectable using another constructor as the category, then inject it by that constructor."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { onDemand, inject } from 'injectable-decorators';\n\n@onDemand()\nclass FreshObject {\n  constructor(public a?: string, public b?: string) {}\n}\n\nclass ParentA {\n  @inject()\n  fresh!: FreshObject; // new instance per parent\n}\n\nclass ParentB {\n  @inject({ args: ['x', 'y'] })\n  fresh!: FreshObject; // passes constructor args to on-demand instance\n}\n\nconst p1 = new ParentA();\nconst p2 = new ParentA();\nconsole.log(p1.fresh !== p2.fresh); // true\n\nconst p3 = new ParentB();\nconsole.log([p3.fresh.a, p3.fresh.b]); // ['x','y']\n",
        "context": "Description: Use @onDemand so each injection produces a fresh instance. You can pass args for construction via @inject{ args }.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: Use @onDemand so each injection produces a fresh instance. You can pass args for construction via @inject{ args }."
      },
      {
        "lang": "typescript",
        "code": "import 'reflect-metadata';\nimport { injectable, inject } from 'injectable-decorators';\n\n@injectable('SomeOtherObject')\nclass SomeOtherObject { value() { return 10; } }\n\nclass Controller {\n  @inject({ transformer: (obj: SomeOtherObject, c: Controller) => '1' })\n  repo!: SomeOtherObject | string;\n}\n\nconst c = new Controller();\nconsole.log(c.repo); // '1'\n",
        "context": "Description: Modify the resolved instance before assignment using a transformer.",
        "source": "howto",
        "title": "Description Modify The Resolved Instance Before",
        "details": "Description: Modify the resolved instance before assignment using a transformer."
      },
      {
        "lang": "typescript",
        "code": "import { Injectables, InjectableRegistryImp } from 'injectable-decorators';\n\n// ensure something is registered\nInjectables.get('SomeOtherObject');\n\n// swap to a fresh registry\nInjectables.setRegistry(new InjectableRegistryImp());\nconsole.log(Injectables.get('SomeOtherObject')); // undefined\n\n// reset to a new empty default registry\nInjectables.reset();\n",
        "context": "Description: Reset clears all registrations. Swapping the registry replaces the storage, losing previous entries.",
        "source": "howto",
        "title": "Description Reset Clears All Registrations Swapping",
        "details": "Description: Reset clears all registrations. Swapping the registry replaces the storage, losing previous entries."
      },
      {
        "lang": "typescript",
        "code": "import { singleton, onDemand } from 'injectable-decorators';\n\n@singleton()\nclass OneOnly {}\n\n@onDemand()\nclass Many {}\n",
        "context": "Description: Prefer @singleton to force single instance, or @onDemand for new instance per retrieval.",
        "source": "howto",
        "title": "Description Prefer Singleton To Force Single",
        "details": "Description: Prefer @singleton to force single instance, or @onDemand for new instance per retrieval."
      },
      {
        "lang": "typescript",
        "code": "import { getInjectKey } from 'injectable-decorators';\n\nconsole.log(getInjectKey('injectable')); // \"inject.db.injectable\"\nconsole.log(getInjectKey('inject'));     // \"inject.db.inject\"\n",
        "context": "Description: Generate reflection keys and understand default config.",
        "source": "howto",
        "title": "Description Generate Reflection Keys And Understand",
        "details": "Description: Generate reflection keys and understand default config."
      }
    ],
    "base_path": "injectable-decorators"
  },
  {
    "name": "as-zod",
    "title": "as-zod",
    "description": "### Description\n\nEasy two-way conversion from Models to Zod\n\nversions `^0.0.1` are for zod 3.x. `^1.0.0` for zod 4.x",
    "summary": "Description Easy two-way conversion from Models to Zod versions ^0.0.1 are for zod 3.x. ^1.0.0 for zod 4.x",
    "examples": [],
    "base_path": "as-zod"
  },
  {
    "name": "db-decorators",
    "title": "db-decorators",
    "description": "\n### DB-Decorators\n\nThe db-decorators library is a powerful TypeScript framework for database operations that leverages decorators to simplify database interactions. It provides a comprehensive solution for implementing the repository pattern with built-in support for model definition, validation, identity management, and operation hooks.\n\n#### Key Features\n\n1. **Repository Pattern Implementation**\n  - Abstract `BaseRepository` class providing the foundation for CRUD operations\n  - Concrete `Repository` class with validation support\n  - Support for bulk operations through the `BulkCrudOperator` interface\n\n2. **Model Management**\n  - Model definition with TypeScript decorators\n  - Identity management with the `@id()` decorator\n  - Property composition with `@composed()` and `@composedFromKeys()` decorators\n  - Versioning support with the `@version()` decorator\n  - Transient properties with the `@transient()` decorator\n\n3. **Operation Hooks**\n  - Pre-operation hooks with `@on()`, `@onCreate()`, `@onUpdate()`, etc.\n  - Post-operation hooks with `@after()`, `@afterCreate()`, `@afterUpdate()`, etc.\n  - Custom operation handlers through the `Operations` registry\n\n4. **Context Management**\n  - Hierarchical context chains with parent-child relationships\n  - Context accumulation for state management\n  - Operation-specific context creation\n\n5. **Validation**\n  - Integration with decorator-validation library\n  - Automatic validation during CRUD operations\n  - Custom validation rules through decorators\n\nThe library is designed to be extensible and adaptable to different database backends, providing a consistent API regardless of the underlying storage mechanism.\n",
    "summary": "DB-Decorators The db-decorators library is a powerful TypeScript framework for database operations that leverages decorators to simplify database interactions.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, hash, version, transient } from \"@decaf-ts/db-decorators\";\nimport { required, minLength, email as emailValidator } from \"@decaf-ts/decorator-validation\";\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  @minLength(3)\n  name: string;\n\n  @required()\n  @emailValidator()\n  email: string;\n\n  @required()\n  @minLength(8)\n  @hash()\n  password: string;\n\n  @version()\n  version: number;\n\n  @transient()\n  temporaryData: any;\n}\n",
        "context": "Description: Create a User model with ID, name, email, and password fields. The ID is marked as required and readonly, the password is hashed, and the email is required.",
        "source": "howto",
        "title": "Description Create A User Model With",
        "details": "Description: Create a User model with ID, name, email, and password fields. The ID is marked as required and readonly, the password is hashed, and the email is required."
      },
      {
        "lang": "typescript",
        "code": "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, composed, composedFromKeys } from \"@decaf-ts/db-decorators\";\nimport { required } from \"@decaf-ts/decorator-validation\";\n\nclass Product extends Model {\n  @id()\n  id: string;\n\n  @required()\n  category: string;\n\n  @required()\n  name: string;\n\n  @required()\n  variant: string;\n\n  @composed(['category', 'name', 'variant'], '-')\n  sku: string;\n\n  @composedFromKeys(['category', 'name'], '_', true, 'PROD_', '_KEY')\n  productKey: string;\n}\n",
        "context": "Description: Create a Product model with a SKU that is automatically composed from other properties.",
        "source": "howto",
        "title": "Description Create A Product Model With",
        "details": "Description: Create a Product model with a SKU that is automatically composed from other properties."
      },
      {
        "lang": "typescript",
        "code": "import { Repository } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(User);\n  }\n\n  async create(model: User, ...args: any[]): Promise<User> {\n    // Implementation for creating a user in the database\n    console.log(`Creating user: ${model.name}`);\n    // Assign an ID if not already present\n    if (!model.id) {\n      model.id = Date.now().toString();\n    }\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation for reading a user from the database\n    console.log(`Reading user with ID: ${key}`);\n    return new User({ id: key, name: \"Example User\", email: \"user@example.com\" });\n  }\n\n  async update(model: User, ...args: any[]): Promise<User> {\n    // Implementation for updating a user in the database\n    console.log(`Updating user: ${model.name}`);\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation for deleting a user from the database\n    console.log(`Deleting user with ID: ${key}`);\n    const user = await this.read(key);\n    return user;\n  }\n}\n",
        "context": "Description: Create a repository for the User model that implements the required CRUD operations.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Create a repository for the User model that implements the required CRUD operations."
      },
      {
        "lang": "typescript",
        "code": "import { Repository } from \"@decaf-ts/db-decorators\";\nimport { Product } from \"./models/Product\";\n\nclass ProductRepository extends Repository<Product> {\n  constructor() {\n    super(Product);\n  }\n\n  // Implement required CRUD methods\n  async create(model: Product, ...args: any[]): Promise<Product> {\n    // Implementation\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<Product> {\n    // Implementation\n    return new Product({ id: key });\n  }\n\n  async update(model: Product, ...args: any[]): Promise<Product> {\n    // Implementation\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<Product> {\n    // Implementation\n    return await this.read(key);\n  }\n\n  // Override bulk methods for optimized implementation\n  async createAll(models: Product[], ...args: any[]): Promise<Product[]> {\n    console.log(`Bulk creating ${models.length} products`);\n    // Custom implementation for bulk creation\n    return models.map(model => {\n      if (!model.id) {\n        model.id = Date.now().toString();\n      }\n      return model;\n    });\n  }\n\n  async readAll(keys: string[] | number[], ...args: any[]): Promise<Product[]> {\n    console.log(`Bulk reading ${keys.length} products`);\n    // Custom implementation for bulk reading\n    return keys.map(key => new Product({ id: key }));\n  }\n}\n",
        "context": "Description: Implement bulk operations for efficient batch processing of multiple models.",
        "source": "howto",
        "title": "Description Implement Bulk Operations For Efficient",
        "details": "Description: Implement bulk operations for efficient batch processing of multiple models."
      },
      {
        "lang": "typescript",
        "code": "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, onCreate, onUpdate, onCreateUpdate } from \"@decaf-ts/db-decorators\";\nimport { required } from \"@decaf-ts/decorator-validation\";\n\n// Handler function for setting creation timestamp\nfunction setCreationTimestamp(repo, context, data, key, model) {\n  model[key] = new Date().toISOString();\n}\n\n// Handler function for setting update timestamp\nfunction setUpdateTimestamp(repo, context, data, key, model) {\n  model[key] = new Date().toISOString();\n}\n\n// Handler function for normalizing email\nfunction normalizeEmail(repo, context, data, key, model) {\n  if (model[key]) {\n    model[key] = model[key].toLowerCase().trim();\n  }\n}\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  name: string;\n\n  @required()\n  @onCreateUpdate(normalizeEmail)\n  email: string;\n\n  @onCreate(setCreationTimestamp)\n  createdAt: string;\n\n  @onUpdate(setUpdateTimestamp)\n  updatedAt: string;\n}\n",
        "context": "Description: Use operation hooks to transform property values during database operations.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Use operation hooks to transform property values during database operations."
      },
      {
        "lang": "typescript",
        "code": "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, afterCreate, afterUpdate, afterDelete } from \"@decaf-ts/db-decorators\";\n\n// Handler function for logging after creation\nfunction logCreation(repo, context, data, key, model) {\n  console.log(`User created: ${model.id} - ${model.name}`);\n}\n\n// Handler function for logging after update\nfunction logUpdate(repo, context, data, key, model) {\n  console.log(`User updated: ${model.id} - ${model.name}`);\n}\n\n// Handler function for logging after deletion\nfunction logDeletion(repo, context, data, key, model) {\n  console.log(`User deleted: ${model.id} - ${model.name}`);\n}\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  name: string;\n\n  @required()\n  email: string;\n\n  @afterCreate(logCreation)\n  @afterUpdate(logUpdate)\n  @afterDelete(logDeletion)\n  _log: any; // This property is just a placeholder for the decorators\n}\n",
        "context": "Description: Use post-operation hooks to perform actions after database operations.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Use post-operation hooks to perform actions after database operations."
      },
      {
        "lang": "typescript",
        "code": "import { Context, Repository } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(User);\n  }\n\n  // Implement required CRUD methods\n  async create(model: User, ...args: any[]): Promise<User> {\n    // Implementation\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation\n    return new User({ id: key });\n  }\n\n  async update(model: User, ...args: any[]): Promise<User> {\n    // Implementation\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation\n    return await this.read(key);\n  }\n\n  // Example of using context\n  async createWithAudit(model: User, userId: string): Promise<User> {\n    // Create a context with audit information\n    const context = new Context().accumulate({\n      auditUser: userId,\n      auditTimestamp: new Date(),\n      skipValidation: false\n    });\n\n    // Pass the context to the create method\n    return this.create(model, context);\n  }\n}\n\n// Usage\nconst userRepo = new UserRepository();\nconst newUser = new User({ name: \"John Doe\", email: \"john@example.com\" });\nconst createdUser = await userRepo.createWithAudit(newUser, \"admin123\");\n",
        "context": "Description: Create and use contexts to manage operation state and configuration.",
        "source": "howto",
        "title": "Description Create And Use Contexts To",
        "details": "Description: Create and use contexts to manage operation state and configuration."
      },
      {
        "lang": "typescript",
        "code": "import { Context, OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\n// Create a parent context\nconst parentContext = new Context().accumulate({\n  transactionId: \"tx123\",\n  batchOperation: true\n});\n\n// Create a child context for a specific operation\nconst childContext = parentContext.child<User, Context<any>>(\n  OperationKeys.CREATE,\n  User\n).accumulate({\n  operationId: \"op456\",\n  validationLevel: \"strict\"\n});\n\n// Access values from the context hierarchy\nconsole.log(childContext.get(\"transactionId\")); // \"tx123\" (inherited from parent)\nconsole.log(childContext.get(\"operationId\")); // \"op456\" (from child)\n",
        "context": "Description: Create hierarchical contexts for complex operations.",
        "source": "howto",
        "title": "Description Create Hierarchical Contexts For Complex",
        "details": "Description: Create hierarchical contexts for complex operations."
      },
      {
        "lang": "typescript",
        "code": "import { User } from \"./models/User\";\nimport { UserRepository } from \"./repositories/UserRepository\";\n\nasync function userCrudExample() {\n  const userRepo = new UserRepository();\n\n  // Create a new user\n  const newUser = new User({\n    name: \"Alice Smith\",\n    email: \"alice@example.com\",\n    password: \"securePassword123\"\n  });\n  const createdUser = await userRepo.create(newUser);\n  console.log(\"Created user:\", createdUser);\n\n  // Read a user\n  const userId = createdUser.id;\n  const retrievedUser = await userRepo.read(userId);\n  console.log(\"Retrieved user:\", retrievedUser);\n\n  // Update a user\n  retrievedUser.name = \"Alice Johnson\";\n  const updatedUser = await userRepo.update(retrievedUser);\n  console.log(\"Updated user:\", updatedUser);\n\n  // Delete a user\n  const deletedUser = await userRepo.delete(userId);\n  console.log(\"Deleted user:\", deletedUser);\n}\n",
        "context": "Description: Perform basic CRUD operations using a repository.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Perform basic CRUD operations using a repository."
      },
      {
        "lang": "typescript",
        "code": "import { Product } from \"./models/Product\";\nimport { ProductRepository } from \"./repositories/ProductRepository\";\n\nasync function productBulkExample() {\n  const productRepo = new ProductRepository();\n\n  // Create multiple products\n  const products = [\n    new Product({ category: \"Electronics\", name: \"Laptop\", variant: \"15-inch\" }),\n    new Product({ category: \"Electronics\", name: \"Laptop\", variant: \"13-inch\" }),\n    new Product({ category: \"Electronics\", name: \"Smartphone\", variant: \"Pro\" })\n  ];\n  const createdProducts = await productRepo.createAll(products);\n  console.log(\"Created products:\", createdProducts);\n\n  // Read multiple products\n  const productIds = createdProducts.map(p => p.id);\n  const retrievedProducts = await productRepo.readAll(productIds);\n  console.log(\"Retrieved products:\", retrievedProducts);\n\n  // Update multiple products\n  const updatedProducts = retrievedProducts.map(p => {\n    p.name = p.name + \" (Updated)\";\n    return p;\n  });\n  const savedProducts = await productRepo.updateAll(updatedProducts);\n  console.log(\"Updated products:\", savedProducts);\n\n  // Delete multiple products\n  const deletedProducts = await productRepo.deleteAll(productIds);\n  console.log(\"Deleted products:\", deletedProducts);\n}\n",
        "context": "Description: Perform bulk operations for efficient batch processing.",
        "source": "howto",
        "title": "Description Perform Bulk Operations For Efficient",
        "details": "Description: Perform bulk operations for efficient batch processing."
      },
      {
        "lang": "typescript",
        "code": "import { Model, ModelErrorDefinition } from \"@decaf-ts/decorator-validation\";\nimport { id } from \"@decaf-ts/db-decorators\";\nimport { required, minLength, maxLength, email, pattern } from \"@decaf-ts/decorator-validation\";\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  name: string;\n\n  @required()\n  @email()\n  emailAddress: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/, \n    \"Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character\")\n  password: string;\n\n  // Manual validation example\n  hasErrors(): ModelErrorDefinition | undefined {\n    const errors = super.hasErrors();\n    \n    // Add custom validation logic\n    if (this.name && this.name.includes('admin') && !this.emailAddress.includes('admin')) {\n      if (!errors) {\n        return {\n          name: [\"Admin users must have an admin email address\"]\n        };\n      }\n      errors.name = errors.name || [];\n      errors.name.push(\"Admin users must have an admin email address\");\n    }\n    \n    return errors;\n  }\n}\n\n// Usage in a repository\nclass UserRepository extends Repository<User> {\n  // ... other methods\n  \n  async create(model: User, ...args: any[]): Promise<User> {\n    // The Repository class will automatically validate the model\n    // and throw a ValidationError if validation fails\n    \n    // Custom validation can also be performed\n    const errors = model.hasErrors();\n    if (errors) {\n      throw new ValidationError(errors.toString());\n    }\n    \n    // Proceed with creation if validation passes\n    return model;\n  }\n}\n",
        "context": "Description: Validate models during CRUD operations to ensure data integrity.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Description: Validate models during CRUD operations to ensure data integrity."
      },
      {
        "lang": "typescript",
        "code": "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id } from \"@decaf-ts/db-decorators\";\nimport { findPrimaryKey, findModelId } from \"@decaf-ts/db-decorators\";\n\nclass Document extends Model {\n  @id()\n  documentId: string;\n  \n  title: string;\n  content: string;\n}\n\n// Create a document instance\nconst doc = new Document({\n  documentId: \"doc-123\",\n  title: \"Sample Document\",\n  content: \"This is a sample document.\"\n});\n\n// Find the primary key property\nconst pkInfo = findPrimaryKey(doc);\nconsole.log(\"Primary key property:\", pkInfo.id); // \"documentId\"\nconsole.log(\"Primary key metadata:\", pkInfo.props);\n\n// Get the primary key value\nconst docId = findModelId(doc);\nconsole.log(\"Document ID:\", docId); // \"doc-123\"\n\n// Try to get ID from a model without an ID value\nconst emptyDoc = new Document();\ntry {\n  const id = findModelId(emptyDoc); // Will throw an error\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n\n// Get ID with returnEmpty option\nconst emptyId = findModelId(emptyDoc, true); // Returns undefined instead of throwing\nconsole.log(\"Empty ID:\", emptyId);\n",
        "context": "Description: Use the identity module to work with model IDs.",
        "source": "howto",
        "title": "Description Use The Identity Module To",
        "details": "Description: Use the identity module to work with model IDs."
      }
    ],
    "base_path": "db-decorators"
  },
  {
    "name": "transactional-decorators",
    "title": "transactional-decorators",
    "description": "### Description\n\nThe Transactional Decorators library is a standalone module that provides a robust implementation for handling concurrency and transaction management in TypeScript applications. It offers a comprehensive set of tools for ensuring data integrity and thread safety in your code.\n\n#### Core Components\n\n- **Transaction Class**: The central class that manages the lifecycle of transactions, including creation, execution, and cleanup. It provides mechanisms for binding transactions to objects and methods, ensuring proper transaction context propagation.\n\n- **Lock System**: A flexible locking mechanism for controlling access to shared resources:\n  - `Lock`: A base class providing fundamental locking capabilities with support for queuing and executing functions when the lock is available.\n  - `TransactionLock`: An interface defining the contract for transaction lock implementations that manage transaction execution order and concurrency.\n  - `SyncronousLock`: A default implementation of TransactionLock that processes transactions one at a time in the order they are submitted.\n\n- **Decorators**:\n  - `@transactional()`: A method decorator that enables transactional behavior by wrapping the original method in a transaction context that handles transaction creation, binding, and error handling.\n  - `transactionalSuperCall()`: A utility function for handling super calls in transactional methods, ensuring transaction continuity through the inheritance chain.\n\n#### Key Features\n\n- **Simple yet powerful locking**: The library provides a flexible locking system that can be customized to suit your application's needs.\n- **Method decoration with `@transactional()`**: Easily add transactional behavior to your methods with a simple decorator.\n- **Instance proxying**: The Transaction class can bind to objects, creating proxies that maintain transaction context across method calls.\n- **Transaction chaining**: Transactions can be linked together, allowing you to group multiple operations into a single atomic transaction.\n- **Customizable Transaction Lock**: You can implement your own TransactionLock to customize how transactions are processed.\n- **Error handling**: The library includes built-in error handling to ensure transactions are properly released even when errors occur.\n- **Seamless integration with `db-decorators`**: The library works well with the db-decorators package for database operations.\n\nThis library is ideal for applications that need to ensure data consistency and handle concurrent operations safely, such as database applications, financial systems, or any application where atomic operations are important.\n",
    "summary": "Description The Transactional Decorators library is a standalone module that provides a robust implementation for handling concurrency and transaction management in TypeScript applications.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { transactional } from '@decaf-ts/transactional-decorators';\n\nclass UserService {\n  @transactional()\n  async createUser(userData: any): Promise<any> {\n    // This method will be executed within a transaction\n    // If an error occurs, the transaction will be released with the error\n    const user = await this.userRepository.save(userData);\n    return user;\n  }\n\n  @transactional(['custom', 'metadata'])\n  async updateUser(userId: string, userData: any): Promise<any> {\n    // You can pass custom metadata to the transaction\n    const user = await this.userRepository.findById(userId);\n    Object.assign(user, userData);\n    return await this.userRepository.save(user);\n  }\n}\n\n// Using the transactional method\nconst userService = new UserService();\nconst newUser = await userService.createUser({ name: 'John Doe' });\n",
        "context": "Description: Add transactional behavior to a class method, ensuring that the method executes within a transaction context.",
        "source": "howto",
        "title": "Description Add Transactional Behavior To A",
        "details": "Description: Add transactional behavior to a class method, ensuring that the method executes within a transaction context."
      },
      {
        "lang": "typescript",
        "code": "import { Transaction } from '@decaf-ts/transactional-decorators';\n\n// Creating a transaction\nconst transaction = new Transaction(\n  'UserService', // Source\n  'createUser',  // Method name\n  async () => {\n    // Transaction logic here\n    const user = await userRepository.save({ name: 'John Doe' });\n    return user;\n  }\n);\n\n// Submitting the transaction for execution\nTransaction.submit(transaction);\n\n// Using the Transaction.push method for callback-style APIs\nTransaction.push(\n  userService, // The object instance\n  userService.createUserWithCallback, // The method to call\n  { name: 'John Doe' }, // Arguments\n  (err, user) => {\n    if (err) {\n      console.error('Error creating user:', err);\n      return;\n    }\n    console.log('User created:', user);\n  }\n);\n",
        "context": "Description: Create and manage transactions manually for complex scenarios or when you need fine-grained control.",
        "source": "howto",
        "title": "Description Create And Manage Transactions Manually",
        "details": "Description: Create and manage transactions manually for complex scenarios or when you need fine-grained control."
      },
      {
        "lang": "typescript",
        "code": "import { transactional, transactionalSuperCall } from '@decaf-ts/transactional-decorators';\n\nclass BaseRepository {\n  @transactional()\n  async save(entity: any): Promise<any> {\n    // Base save implementation\n    return entity;\n  }\n}\n\nclass UserRepository extends BaseRepository {\n  @transactional()\n  async save(user: any): Promise<any> {\n    // Pre-processing\n    user.updatedAt = new Date();\n\n    // Call the super method with transaction context\n    const result = await transactionalSuperCall(super.save.bind(this), user);\n\n    // Post-processing\n    console.log('User saved:', result);\n    return result;\n  }\n}\n",
        "context": "Description: Maintain transaction context when calling a superclass method that is also transactional.",
        "source": "howto",
        "title": "Description Maintain Transaction Context When Calling",
        "details": "Description: Maintain transaction context when calling a superclass method that is also transactional."
      },
      {
        "lang": "typescript",
        "code": "import { TransactionLock, Transaction } from '@decaf-ts/transactional-decorators';\n\n// Custom transaction lock that logs transactions\nclass LoggingTransactionLock implements TransactionLock {\n  currentTransaction?: Transaction;\n  private pendingTransactions: Transaction[] = [];\n\n  submit(transaction: Transaction): void {\n    console.log(`Submitting transaction: ${transaction.toString()}`);\n\n    if (this.currentTransaction) {\n      this.pendingTransactions.push(transaction);\n      console.log(`Transaction queued. Queue length: ${this.pendingTransactions.length}`);\n    } else {\n      this.currentTransaction = transaction;\n      console.log(`Executing transaction immediately`);\n      transaction.fire();\n    }\n  }\n\n  async release(err?: Error): Promise<void> {\n    if (err) {\n      console.error(`Transaction error: ${err.message}`);\n    } else {\n      console.log(`Transaction completed successfully`);\n    }\n\n    this.currentTransaction = undefined;\n\n    if (this.pendingTransactions.length > 0) {\n      const nextTransaction = this.pendingTransactions.shift()!;\n      console.log(`Processing next transaction: ${nextTransaction.toString()}`);\n      this.currentTransaction = nextTransaction;\n      nextTransaction.fire();\n    }\n\n    return Promise.resolve();\n  }\n}\n\n// Set the custom lock as the default\nTransaction.setLock(new LoggingTransactionLock());\n",
        "context": "Description: Create a custom transaction lock implementation for specialized concurrency control.",
        "source": "howto",
        "title": "Description Create A Custom Transaction Lock",
        "details": "Description: Create a custom transaction lock implementation for specialized concurrency control."
      },
      {
        "lang": "typescript",
        "code": "import { Lock } from '@decaf-ts/transactional-decorators';\n\n// Create a lock for a shared resource\nconst resourceLock = new Lock();\n\n// Execute a function with exclusive access to the resource\nasync function accessSharedResource() {\n  const result = await resourceLock.execute(async () => {\n    // This code will run with exclusive access to the resource\n    const data = await fetchDataFromDatabase();\n    const processedData = processData(data);\n    await saveDataToDatabase(processedData);\n    return processedData;\n  });\n\n  return result;\n}\n\n// Alternatively, you can manually acquire and release the lock\nasync function manualLockHandling() {\n  await resourceLock.acquire();\n  try {\n    // Critical section with exclusive access\n    const data = await fetchDataFromDatabase();\n    const processedData = processData(data);\n    await saveDataToDatabase(processedData);\n    return processedData;\n  } finally {\n    // Always release the lock, even if an error occurs\n    resourceLock.release();\n  }\n}\n",
        "context": "Description: Use the Lock class for simple concurrency control in non-transactional contexts.",
        "source": "howto",
        "title": "Description Use The Lock Class For",
        "details": "Description: Use the Lock class for simple concurrency control in non-transactional contexts."
      }
    ],
    "base_path": "transactional-decorators"
  },
  {
    "name": "core",
    "title": "core",
    "description": "# Core Package — Detailed Description\n\nThe Decaf Core package provides a cohesive set of primitives for building strongly-typed data-access layers in TypeScript. It centers around:\n\n- Models (from @decaf-ts/decorator-validation) enhanced with identity and persistence metadata\n- A Repository abstraction that encapsulates CRUD, querying, and observation\n- Adapters that bridge repositories to underlying storage (in-memory, HTTP, TypeORM, etc.)\n- A fluent Query DSL (Statement/Condition) with pagination\n- Lightweight dependency injection utilities to auto-resolve repositories\n\nBelow is an overview of the main modules and their public APIs exposed by core.\n\n1) Repository module\n- Repository<M>\n  - Constructor: new Repository(adapter: Adapter, clazz: Constructor<M>, ...)\n  - CRUD: create, read, update, delete\n  - Bulk ops: createAll, readAll, updateAll, deleteAll\n  - Hooks: createPrefix/createSuffix, updateAllPrefix, readAllPrefix, deleteAllPrefix (internal orchestration helpers)\n  - Query: select(...selectors?), query(condition?, orderBy?, order?, limit?, skip?)\n  - Observation: observe(observer, filter?), unObserve(observer), updateObservers(...), refresh(...)\n  - Repository registry helpers:\n    - static for(config, ...args): Proxy factory for building repositories with specific adapter config\n    - static forModel(model, alias?, ...args): returns a Repository instance or repository constructor registered for the model\n    - static get(model, alias?): low-level retrieval of a registered repository constructor\n    - static register(model, repoCtor, alias?)\n    - static getMetadata/setMetadata/removeMetadata(model)\n    - static getSequenceOptions(model)\n    - static indexes(model): reads index definitions for model\n    - static relations(model)\n    - static table(model), static column(model, attribute)\n- Decorators (repository/decorators)\n  - repository(modelCtor, flavour?):\n    - As property decorator: injects the repository instance for the annotated model\n    - As class decorator: registers the annotated class as the repository for the model; integrates with Injectables\n- Injectables registry (repository/injectables)\n  - InjectablesRegistry extends InjectableRegistryImp\n  - get<T>(name | token | ctor, flavour?): resolves a registered injectable; if not registered, attempts to infer the model and construct or fetch the appropriate repository based on adapter flavour or metadata (falling back to current adapter)\n- Types/utilities (repository/types, repository/utils)\n  - IndexMetadata, OrderDirection, generateInjectableNameForRepository, and other helpers/constants\n\n2) Persistence module\n- Adapter<N = any, Q = any, R = any, Ctx = Context>\n  - Base bridge between repository and the back-end. Offers:\n    - initialize(...), flags(...), context(...)\n    - prepare(model, pk): model -> record mapping using model metadata\n    - revert(record, clazz, pk, id, transient?): record -> model mapping\n    - CRUD: create, createAll, read, readAll, update, updateAll, delete, deleteAll\n    - raw(rawInput): pass-through for back-end specific commands\n    - Observation: observe/unObserve, updateObservers, refresh\n    - Flavour/alias management: current(), get(flavour), setCurrent(flavour), alias(), models(flavour), flavourOf(model)\n    - Factory helpers: Statement(), Dispatch(), ObserverHandler(), Sequence(options)\n    - for(config, ...args): proxy-bound adapter for a given configuration\n- Dispatch: batching/dispatch helpers used by Adapter\n- Sequence: provides identity/sequence generation based on SequenceOptions (see interfaces)\n- ObserverHandler: internal observer list and filtering logic used by repositories/adapters\n- constants, errors, types: PersistenceKeys, EventIds, ObserverFilter, etc.\n\n3) Query module\n- Statement<M extends Model>\n  - Fluent DSL to build and execute queries via the configured Adapter\n  - Methods:\n    - select(...keys?), distinct(key), count(key), max(key), min(key)\n    - from(modelCtor), where(Condition), orderBy([key, OrderDirection]), groupBy(key)\n    - limit(n), offset(n), execute(), raw(input), paginate(size)\n- Condition<M extends Model>\n  - Composable condition tree with a builder API and logical combinators\n  - Methods:\n    - and(cond), or(cond), not(cond)\n    - attribute/attr(name): switch attribute under construction\n    - hasErrors(exceptions?): validation helper\n    - group(cond1, GroupOperator, cond2)\n    - builder(): ConditionBuilder\n  - ConditionBuilder methods: eq, dif, gt, lt, gte, lte, in, regexp, build\n- Paginator<M>\n  - Abstract pagination helper returned by Statement.paginate(size)\n  - Properties: current, total, count, size\n  - Methods: page(n?), next(), previous(); requires an Adapter-specific concrete implementation\n\n4) Interfaces module\n- Observable<T>, Observer<T>: basic observer pattern primitives\n- Executor, RawExecutor: contracts for query execution\n- Queriable: minimal interface for types that can return a Statement\n- Paginatable: marks types that can paginate\n- SequenceOptions and defaults: sequence/generator configuration presets\n\n5) Model & Identity modules\n- BaseModel and supporting types: base class all models extend from\n- identity/decorators and identity/utils: helpers to derive table names, etc.\n- model/decorators: e.g., @model and other persistence-related metadata (provided by @decaf-ts/decorator-validation and enriched here)\n\n6) RAM runtime (core/src/ram)\n- RamAdapter, RamRepository, RamStatement, RamPaginator (in-memory implementations used by tests and examples)\n- Useful for local testing and reference behavior of the core abstractions.\n\nDesign intent\n- Provide a consistent, typed data access layer decoupled from any particular storage or framework\n- Allow adapters to plug into multiple backends while preserving a uniform repository and query API\n- Make querying expressive but type-safe through fluent builders and model metadata\n- Enable DI and decorators for ergonomic repository wiring and testing\n",
    "summary": "Core Package — Detailed Description The Decaf Core package provides a cohesive set of primitives for building strongly-typed data-access layers in TypeScript.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { Model, model } from \"@decaf-ts/decorator-validation\";\nimport type { ModelArg } from \"@decaf-ts/decorator-validation\";\nimport {\n  Adapter,\n  OrderDirection,\n  Paginator,\n  Repository,\n  repository,\n  uses,\n  pk,\n  column,\n  table,\n} from \"@decaf-ts/core\";\nimport { RamAdapter, RamRepository } from \"@decaf-ts/core/ram\";\n\n@table(\"tst_user\")\n@model()\nclass User extends Model {\n  @pk() id!: string;\n  @column(\"tst_name\") name!: string;\n  @column(\"tst_nif\") nif!: string;\n  constructor(arg?: ModelArg<User>) { super(arg); }\n}\n",
        "context": "Prerequisites used across examples: - Ensure your model builder is set for tests/dev scenarios: Model.setBuilderModel.fromModel - Use the RAM adapter for quick in-memory demos",
        "source": "howto",
        "title": "Prerequisites Used Across Examples Ensure Your",
        "details": "Prerequisites used across examples: - Ensure your model builder is set for tests/dev scenarios: Model.setBuilderModel.fromModel - Use the RAM adapter for quick in-memory demos"
      },
      {
        "lang": "typescript",
        "code": "import { NotFoundError } from \"@decaf-ts/db-decorators\";\n\nasync function crudExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // CREATE\n  const created = await repo.create(\n    new User({ id: Date.now().toString(), name: \"Alice\", nif: \"123456789\" })\n  );\n\n  // READ\n  const read = await repo.read(created.id);\n  console.log(read.equals(created)); // true (same data, different instance)\n\n  // UPDATE\n  const updated = await repo.update(Object.assign(read, {name: \"Alice 2\" }));\n\n  // DELETE\n  const deleted = await repo.delete(created.id);\n  console.log(deleted.equals(updated)); // true\n}\n",
        "context": "- Repository + RAM adapter: basic CRUD Description: Create a RamAdapter and a Repository for a model and perform CRUD operations; mirrors core/tests/unit/RamAdapter.test.ts and adapter.test.ts.",
        "source": "howto",
        "title": "Database Access",
        "details": "- Repository + RAM adapter: basic CRUD Description: Create a RamAdapter and a Repository for a model and perform CRUD operations; mirrors core/tests/unit/RamAdapter.test.ts and adapter.test.ts."
      },
      {
        "lang": "typescript",
        "code": "\n@model()\nclass Managed extends Model { constructor(arg?: ModelArg<Managed>) { super(arg); } }\n\n@repository(Managed)\n@uses(\"ram\")\nclass ManagedRepository extends Repository<Managed> {\n  // Concrete adapter-backed methods would be provided by adapter implementation\n  // For quick test or demo, use a RamAdapter\n}\n\nasync function adapterRegistryExample() {\n  const adapter = new RamAdapter();\n\n  Adapter.setCurrent(\"ram\"); // set current flavour\n  console.log(Adapter.current === Adapter.get(\"ram\")); // true\n\n  // Models managed by current or specific adapter flavour\n  const managed = Adapter.models(\"ram\");\n  console.log(Array.isArray(managed));\n}\n",
        "context": "- Adapter current and registered models; @repository class decorator Description: Show how to set/get current adapter and register a repository via the @repository decorator; mirrors adapter.test.ts.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "- Adapter current and registered models; @repository class decorator Description: Show how to set/get current adapter and register a repository via the @repository decorator; mirrors adapter.test.ts."
      },
      {
        "lang": "typescript",
        "code": "async function queryExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // Seed data\n  await repo.createAll(\n    Array.from({ length: 5 }).map((_, i) =>\n      new User({ id: (i + 1).toString(), name: `u${i + 1}`, nif: \"123456789\" })\n    )\n  );\n\n  const results = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.ASC])\n    .execute();\n\n  console.log(results.map((u) => u.id)); // [\"1\",\"2\",\"3\",\"4\",\"5\"]\n}\n",
        "context": "- Query building with select/order and execution Description: Build a statement with orderBy and run it, as done in core/tests/unit/Pagination.test.ts.",
        "source": "howto",
        "title": "Database Access",
        "details": "- Query building with select/order and execution Description: Build a statement with orderBy and run it, as done in core/tests/unit/Pagination.test.ts."
      },
      {
        "lang": "typescript",
        "code": "async function paginationExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // Seed data\n  const size = 25;\n  await repo.createAll(\n    Array.from({ length: size }).map((_, i) =>\n      new User({ id: (i + 1).toString(), name: `u${i + 1}`, nif: \"123456789\" })\n    )\n  );\n\n  const paginator: Paginator<User> = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.DSC])\n    .paginate(10);\n\n  const page1 = await paginator.page(); // first page by default\n  const page2 = await paginator.next();\n  const page3 = await paginator.next();\n\n  console.log(page1.length, page2.length, page3.length); // 10, 10, 5\n}\n",
        "context": "- Pagination with Paginator Description: Paginate query results using Statement.paginatesize, then page through results; mirrors Pagination.test.ts.",
        "source": "howto",
        "title": "Database Access",
        "details": "- Pagination with Paginator Description: Paginate query results using Statement.paginatesize, then page through results; mirrors Pagination.test.ts."
      },
      {
        "lang": "typescript",
        "code": "import { Condition } from \"@decaf-ts/core\";\n\nasync function conditionExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  await repo.createAll([\n    new User({ id: \"1\", name: \"Alice\", nif: \"111111111\" }),\n    new User({ id: \"2\", name: \"Bob\", nif: \"222222222\" }),\n  ]);\n\n  const cond = Condition.attr<User>(\"name\")\n    .eq(\"Alice\")\n    .build();\n\n  const results = await repo.select().where(cond).execute();\n  console.log(results.length); // 1\n}\n",
        "context": "- Conditions: building filters Description: Compose conditions with the builder and apply them in a where clause.",
        "source": "howto",
        "title": "Conditions Building Filters Description Compose Conditions",
        "details": "- Conditions: building filters Description: Compose conditions with the builder and apply them in a where clause."
      },
      {
        "lang": "typescript",
        "code": "async function mappingExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  const toCreate = new User({ id: \"abc\", name: \"Test\", nif: \"123456789\" });\n\n  // prepare: model -> record\n  const pk = \"id\"; // infer with findPrimaryKey(toCreate).id if available\n  const { record, id } = adapter.prepare(toCreate, pk);\n  console.log(id === toCreate.id); // true\n\n  // revert: record -> model instance\n  const model = adapter.revert(record, User, pk, id) as User;\n  console.log(model instanceof User); // true\n}\n",
        "context": "- Adapter mapping: prepare and revert Description: Convert a model to a storage record and back using Adapter.prepare and Adapter.revert; mirrors adapter.test.ts.",
        "source": "howto",
        "title": "Adapter Mapping Prepare And Revert Description",
        "details": "- Adapter mapping: prepare and revert Description: Convert a model to a storage record and back using Adapter.prepare and Adapter.revert; mirrors adapter.test.ts."
      },
      {
        "lang": "typescript",
        "code": "import { Injectables } from \"@decaf-ts/injectable-decorators\";\nimport { InjectablesRegistry } from \"@decaf-ts/core\";\n\nasync function injectablesExample() {\n  // Register current adapter so repositories can be created\n  new RamAdapter();\n  Adapter.setCurrent(\"ram\");\n\n  // Resolve by constructor\n  const userRepo = Injectables.get<Repository<User>>(User);\n  if (userRepo) {\n    const u = await userRepo.create(\n      new User({ id: \"1\", name: \"A\", nif: \"123456789\" })\n    );\n    console.log(!!u);\n  }\n}\n",
        "context": "- Auto-resolving repositories with InjectablesRegistry Description: Retrieve a repository by model name or constructor using the DI registry; see repository/injectables.ts flow.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "- Auto-resolving repositories with InjectablesRegistry Description: Retrieve a repository by model name or constructor using the DI registry; see repository/injectables.ts flow."
      }
    ],
    "base_path": "core"
  },
  {
    "name": "for-http",
    "title": "for-http",
    "description": "# decaf-ts/for-http — Detailed Description\n\nThis package provides a small, focused HTTP integration for decaf-ts. It introduces a generic HttpAdapter abstraction that maps REST semantics (create/read/update/delete and bulk variants) onto decaf-ts repositories and services, plus minimal configuration and flags. A ready-to-use Axios adapter is included.\n\nCore goals\n- Keep HTTP concerns decoupled from models and repositories.\n- Provide a consistent CRUD surface over REST endpoints.\n- Allow custom clients (via subclassing HttpAdapter) while shipping an Axios implementation.\n- Offer simple configuration (protocol/host) and request-scoped headers via flags/context.\n\nKey building blocks\n- HttpConfig: A minimal connection config with protocol and host.\n- HttpFlags: Extends RepositoryFlags to include optional HTTP headers.\n- HttpAdapter<Y, CON, Q, F, C>:\n  - Extends the core Adapter to focus on HTTP.\n  - Adds default flags() with headers support.\n  - Provides URL building (protected url()) and error parsing (parseError()).\n  - Declares abstract request(), create(), read(), update(), delete().\n  - Declares optional/unsupported-by-default raw(), Sequence(), Statement(), parseCondition() that concrete adapters may implement if needed.\n  - repository() returns RestService as the default repository/service implementation for this adapter type.\n- RestService<M, Q, A, F, C>:\n  - Lightweight, model-centric service that delegates to the HttpAdapter for CRUD and bulk operations.\n  - Converts between model instances and plain records using adapter.prepare() and adapter.revert().\n  - Manages a list of observers (observe/unObserve/updateObservers) that can be refreshed after changes.\n- RestRepository<M, Q, A, F, C>:\n  - A Repository that works with an HttpAdapter; use it if you need decaf-ts repository decoration/logic before sending to the backend.\n  - Not the default repository for the HTTP adapter (that role is fulfilled by RestService); intended for cases where repository lifecycle logic matters.\n- AxiosHttpAdapter:\n  - Concrete implementation of HttpAdapter built on Axios.\n  - Implements request and CRUD operations using Axios.request/get/post/put/delete.\n  - Uses HttpConfig for base URL construction and inherits header flag behavior.\n\nFlow overview\n1. Instantiate a concrete adapter (e.g., AxiosHttpAdapter) with an HttpConfig.\n2. Get a repository/service for a given model (the default is RestService via adapter.getRepository(), or instantiate RestService/RestRepository directly).\n3. Call CRUD methods (create/read/update/delete) or their bulk equivalents (createAll/readAll/updateAll/deleteAll) on the service or repository. The service:\n   - Derives the table/collection name from the model’s decaf-ts metadata.\n   - Uses adapter.prepare() to serialize the model and extract its ID.\n   - Invokes the adapter’s HTTP methods.\n   - Uses adapter.revert() to rehydrate responses back into model instances.\n4. Optionally provide HttpFlags (e.g., headers) in the Context to influence requests.\n\nURL building and error handling\n- HttpAdapter.url() builds URLs as `${protocol}://${host}/${tableName}` and appends encoded query parameters when provided, ensuring spaces are encoded as %20.\n- HttpAdapter.parseError() currently returns the error unchanged (as BaseError) but is intended to be overridden/extended by concrete adapters to normalize HTTP/client errors.\n\nBulk operations\n- RestService implements createAll, readAll, updateAll, deleteAll. These delegate to similarly named adapter methods (which are expected to exist on the base Adapter implementation from @decaf-ts/core), allowing efficient batched operations where supported by the backend.\n\nUnsupported APIs by default\n- Some persistence APIs from the core (raw, Sequence, Statement, parseCondition) are not meaningful out of the box for a generic HTTP adapter, so HttpAdapter throws UnsupportedError for them. Concrete adapters targeting specific backends can choose to implement these.\n\nWhen to use RestService vs RestRepository\n- Use RestService by default for straightforward CRUD over REST endpoints.\n- Use RestRepository if you need repository-level decoration logic (e.g., hooks, rules) to run on your models before hitting the HTTP layer.\n\nExtending with another HTTP client\n- Subclass HttpAdapter and implement request(), create(), read(), update(), delete().\n- Override parseError() to translate client-specific errors to your app’s BaseError.\n- Optionally implement raw(), Sequence(), Statement(), parseCondition() if your backend/client supports those features.\n",
    "summary": "decaf-ts/for-http — Detailed Description This package provides a small, focused HTTP integration for decaf-ts.",
    "examples": [
      {
        "lang": "ts",
        "code": "import { HttpConfig, HttpFlags } from \"@decaf-ts/for-http\";\n\nconst config: HttpConfig = {\n  protocol: \"https\",\n  host: \"api.example.com\",\n};\n\n// You can pass headers via flags (typically through a Context)\nconst flags: HttpFlags = {\n  headers: {\n    Authorization: \"Bearer <token>\",\n  },\n};\n",
        "context": "Description: Define the basic connection configuration and optional per-request headers.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Define the basic connection configuration and optional per-request headers."
      },
      {
        "lang": "ts",
        "code": "import { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\nconst config: HttpConfig = { protocol: \"https\", host: \"api.example.com\" };\nconst adapter = new AxiosHttpAdapter(config);\n",
        "context": "Description: Ready-to-use HTTP adapter based on Axios. Use it to interact with REST endpoints.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Ready-to-use HTTP adapter based on Axios. Use it to interact with REST endpoints."
      },
      {
        "lang": "ts",
        "code": "import { RestService } from \"@decaf-ts/for-http\";\nimport { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\n// Example model (assumes proper decaf-ts decorations elsewhere)\nclass User {\n  id!: string;\n  name!: string;\n}\n\nconst config: HttpConfig = { protocol: \"https\", host: \"api.example.com\" };\nconst adapter = new AxiosHttpAdapter(config);\n\n// Create a service bound to the User model\nconst users = new RestService<User, any, typeof adapter>(adapter, User);\n\n// Create\nconst created = await users.create({ id: \"u1\", name: \"Alice\" } as User);\n\n// Read\nconst found = await users.read(\"u1\");\n\n// Update\nconst updated = await users.update({ id: \"u1\", name: \"Alice Cooper\" } as User);\n\n// Delete\nconst removed = await users.delete(\"u1\");\n\n// Bulk create\nconst many = await users.createAll([\n  { id: \"u2\", name: \"Bob\" } as User,\n  { id: \"u3\", name: \"Carol\" } as User,\n]);\n\n// Bulk read\nconst foundMany = await users.readAll([\"u2\", \"u3\"]);\n\n// Bulk update\nconst updatedMany = await users.updateAll([\n  { id: \"u2\", name: \"Bobby\" } as User,\n  { id: \"u3\", name: \"Caroline\" } as User,\n]);\n\n// Bulk delete\nconst removedMany = await users.deleteAll([\"u2\", \"u3\"]);\n",
        "context": "Description: Lightweight, model-centric service that delegates CRUD and bulk operations to the adapter.",
        "source": "howto",
        "title": "Create and Inject Service",
        "details": "Description: Lightweight, model-centric service that delegates CRUD and bulk operations to the adapter."
      },
      {
        "lang": "ts",
        "code": "import { RestRepository } from \"@decaf-ts/for-http\";\nimport { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\nclass Product {\n  id!: number;\n  title!: string;\n}\n\nconst cfg: HttpConfig = { protocol: \"https\", host: \"store.example.com\" };\nconst http = new AxiosHttpAdapter(cfg);\n\n// Create a repository for Product\nconst products = new RestRepository<Product, any, typeof http>(http, Product);\n\n// Typical repository interactions\nconst p = await products.findById(101);\n// ... other repository APIs as provided by @decaf-ts/core Repository\n",
        "context": "Description: Use this when you need decaf-ts \"repository\" decoration logic to run before hitting the HTTP backend.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Use this when you need decaf-ts \"repository\" decoration logic to run before hitting the HTTP backend."
      },
      {
        "lang": "ts",
        "code": "import { Context } from \"@decaf-ts/db-decorators\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { AxiosHttpAdapter, AxiosFlags } from \"@decaf-ts/for-http/axios\";\nimport { RestService } from \"@decaf-ts/for-http\";\n\nclass User { id!: string; name!: string; }\n\nconst adapter = new AxiosHttpAdapter({ protocol: \"https\", host: \"api.example.com\" });\nconst users = new RestService<User, any, typeof adapter>(adapter, User);\n\n// Generate flags for a READ operation (adds an empty headers obj you can override)\nconst flags = adapter.flags<User>(OperationKeys.READ, User, { headers: { Authorization: \"Bearer <token>\" } });\n\n// Place flags into a context (shape depends on @decaf-ts/db-decorators; we cast here for example purposes)\nconst ctx = { flags } as unknown as Context<AxiosFlags>;\n\n// Many decaf-ts operations accept an optional context/flags as the last argument\nconst user = await users.read(\"u1\", ctx);\n",
        "context": "Description: Supply headers for a specific operation using HttpFlags. These are typically carried inside a Context from @decaf-ts/db-decorators.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Supply headers for a specific operation using HttpFlags. These are typically carried inside a Context from @decaf-ts/db-decorators."
      },
      {
        "lang": "ts",
        "code": "import { HttpAdapter, HttpConfig, HttpFlags } from \"@decaf-ts/for-http\";\nimport { Context } from \"@decaf-ts/db-decorators\";\n\n// Hypothetical client types\ntype MyClient = { request: <T>(config: any) => Promise<T>; get: <T>(url: string) => Promise<T>; post: <T>(url: string, body: any) => Promise<T>; put: <T>(url: string, body: any) => Promise<T>; delete: <T>(url: string) => Promise<T>; };\n\ntype MyRequestConfig = { url: string; method: \"GET\"|\"POST\"|\"PUT\"|\"DELETE\"; data?: any; headers?: Record<string,string>; };\n\ntype MyFlags = HttpFlags;\n\ntype MyContext = Context<MyFlags>;\n\nclass MyHttpAdapter extends HttpAdapter<HttpConfig, MyClient, MyRequestConfig, MyFlags, MyContext> {\n  constructor(config: HttpConfig, alias?: string) { super(config, \"my-client\", alias); }\n\n  protected override getClient(): MyClient {\n    // create and return your HTTP client instance\n    return {\n      request: async <T>(c: any) => ({} as T),\n      get: async <T>(url: string) => ({} as T),\n      post: async <T>(url: string, body: any) => ({} as T),\n      put: async <T>(url: string, body: any) => ({} as T),\n      delete: async <T>(url: string) => ({} as T),\n    };\n  }\n\n  override async request<V>(details: MyRequestConfig): Promise<V> {\n    // bridge to your client’s request API\n    return this.client.request<V>(details);\n  }\n\n  async create(table: string, id: string|number, model: Record<string, any>): Promise<Record<string, any>> {\n    const url = this.url(table);\n    return this.client.post(url, model);\n  }\n\n  async read(table: string, id: string|number|bigint): Promise<Record<string, any>> {\n    const url = this.url(table, { id: id as string|number });\n    return this.client.get(url);\n  }\n\n  async update(table: string, id: string|number, model: Record<string, any>): Promise<Record<string, any>> {\n    const url = this.url(table);\n    return this.client.put(url, model);\n  }\n\n  async delete(table: string, id: string|number|bigint): Promise<Record<string, any>> {\n    const url = this.url(table, { id: id as string|number });\n    return this.client.delete(url);\n  }\n\n  // Optionally override parseError(err) to normalize client-specific errors\n}\n",
        "context": "Description: Implement a custom adapter for a different HTTP client. You must implement request and CRUD methods at minimum.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Implement a custom adapter for a different HTTP client. You must implement request and CRUD methods at minimum."
      },
      {
        "lang": "ts",
        "code": "import { AxiosFlavour, AxiosFlags } from \"@decaf-ts/for-http/axios\";\n\n// AxiosFlavour is the adapter flavour identifier string: \"axios\"\nconsole.log(AxiosFlavour);\n\n// AxiosFlags is a type alias of HttpFlags; useful for contexts with Axios\nconst f: AxiosFlags = { headers: { \"X-Trace\": \"1\" } };\n",
        "context": "Description: Utilities specific to the Axios implementation.",
        "source": "howto",
        "title": "Description Utilities Specific To The Axios",
        "details": "Description: Utilities specific to the Axios implementation."
      }
    ],
    "base_path": "for-http"
  },
  {
    "name": "ui-decorators",
    "title": "ui-decorators",
    "description": "### Description\n\nThe UI Decorators library is an extension of `@decaf-ts/decorator-validation` and `@decaf-ts/db-decorators` that provides a comprehensive framework for automatic model rendering in user interfaces. It enables a declarative approach to UI development by allowing developers to define how their data models should be rendered directly on the model classes and properties.\n\n#### Core Functionality\n\n- **Model Rendering**: Extends the Model class with the ability to render itself as a UI component\n- **Flexible Rendering Engine**: Provides an abstract RenderingEngine class that can be implemented for different UI frameworks\n- **Validation Integration**: Automatically applies validation rules from `@decaf-ts/decorator-validation` to UI elements\n- **CRUD Operation Support**: Controls element visibility and behavior based on the current CRUD operation (Create, Read, Update, Delete)\n- **List Rendering**: Special support for rendering collections of models as lists with customizable item templates\n\n#### Class Decorators\n\n- **`@uimodel(tag?, props?)`**: Marks a class as a UI model and specifies how it should be rendered, including the HTML tag to use and additional properties\n- **`@renderedBy(engine)`**: Specifies which rendering engine implementation should be used for a particular model\n- **`@uilistitem(tag?, props?)`**: Defines how a model should be rendered when it appears as an item in a list\n\n#### Property Decorators\n\n- **`@uiprop(propName?, stringify?)`**: Maps a model property to a UI component property, optionally with a different name or stringified\n- **`@uielement(tag, props?, serialize?)`**: Maps a model property to a specific UI element with custom properties\n- **`@uilistprop(propName?, props?)`**: Maps a model property containing a list to a list container component\n- **`@hideOn(...operations)`**: Hides a property during specific CRUD operations\n- **`@hidden()`**: Completely hides a property in all UI operations\n\n#### Rendering Engine\n\nThe abstract `RenderingEngine` class provides the foundation for implementing rendering strategies for different UI frameworks:\n\n- **Type Translation**: Converts between model types and HTML input types\n- **Validation Handling**: Applies validation rules from the model to UI elements\n- **Field Definition Generation**: Converts model metadata into UI field definitions\n- **Engine Management**: Registers and retrieves rendering engine implementations\n- **Extensibility**: Can be extended to support any UI framework or rendering strategy\n\n#### Integration with Validation\n\nThe library seamlessly integrates with the validation system from `@decaf-ts/decorator-validation`, automatically applying validation rules to UI elements:\n\n- Required fields\n- Minimum and maximum values\n- Minimum and maximum length\n- Pattern matching\n- Type-specific validation (email, URL, date, password)\n- Custom validation rules\n\nThis integration ensures that UI components not only display data correctly but also enforce the same validation rules defined in the model.\n",
    "summary": "Description The UI Decorators library is an extension of @decaf-ts/decorator-validation and @decaf-ts/db-decorators that provides a comprehensive framework for automatic model rendering in user interf…",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel()\nclass UserProfile extends Model {\n  @attribute()\n  @uielement('input', { type: 'text', placeholder: 'Enter your name' })\n  name: string;\n\n  @attribute()\n  @uielement('input', { type: 'email', placeholder: 'Enter your email' })\n  email: string;\n}\n\n// Create an instance\nconst user = new UserProfile();\nuser.name = 'John Doe';\nuser.email = 'john@example.com';\n\n// Render the model (the actual rendering depends on the registered rendering engine)\nconst renderedUI = user.render();\n",
        "context": "The most basic usage involves decorating a model class with @uimodel to make it renderable:",
        "source": "howto",
        "title": "The Most Basic Usage Involves Decorating",
        "details": "The most basic usage involves decorating a model class with @uimodel to make it renderable:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('div', { class: 'user-card', style: 'border: 1px solid #ccc; padding: 16px;' })\nclass UserCard extends Model {\n  @attribute()\n  @uielement('h2', { class: 'user-name' })\n  name: string;\n\n  @attribute()\n  @uielement('p', { class: 'user-bio' })\n  bio: string;\n}\n",
        "context": "You can customize how a model is rendered by providing a tag and properties to the @uimodel decorator:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "You can customize how a model is rendered by providing a tag and properties to the @uimodel decorator:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, renderedBy, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel()\n@renderedBy('react')\nclass ReactComponent extends Model {\n  @attribute()\n  @uielement('input', { type: 'text' })\n  title: string;\n}\n",
        "context": "You can specify which rendering engine to use for a particular model:",
        "source": "howto",
        "title": "You Can Specify Which Rendering Engine",
        "details": "You can specify which rendering engine to use for a particular model:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, attribute, required, minLength, maxLength } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('form')\nclass LoginForm extends Model {\n  @attribute()\n  @required()\n  @minLength(3)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'Username', \n    class: 'form-control' \n  })\n  username: string;\n\n  @attribute()\n  @required()\n  @minLength(8)\n  @uielement('input', { \n    type: 'password', \n    placeholder: 'Password', \n    class: 'form-control' \n  })\n  password: string;\n\n  @attribute()\n  @uielement('button', { \n    type: 'submit', \n    class: 'btn btn-primary' \n  })\n  submitButton: string = 'Login';\n}\n",
        "context": "The @uielement decorator maps a model property to a specific UI element:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "The @uielement decorator maps a model property to a specific UI element:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uiprop } from '@decaf-ts/ui-decorators';\n\n@uimodel('user-profile-component')\nclass UserProfile extends Model {\n  @attribute()\n  @uiprop() // Will be passed as 'fullName' to the component\n  fullName: string;\n\n  @attribute()\n  @uiprop('userEmail') // Will be passed as 'userEmail' to the component\n  email: string;\n\n  @attribute()\n  @uiprop('userData', true) // Will be passed as stringified JSON\n  userData: Record<string, any>;\n}\n",
        "context": "The @uiprop decorator maps a model property to a UI component property:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "The @uiprop decorator maps a model property to a UI component property:"
      },
      {
        "lang": "typescript",
        "code": "import { Model } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement, hideOn, hidden } from '@decaf-ts/ui-decorators';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\n\n@uimodel()\nclass User extends Model {\n  @uielement('input', { type: 'text' })\n  username: string;\n\n  @uielement('input', { type: 'password' })\n  @hideOn(OperationKeys.READ) // Hide during READ operations\n  password: string;\n\n  @uielement('input', { type: 'text' })\n  @hidden() // Completely hidden in all operations\n  internalId: string;\n}\n",
        "context": "You can control when properties are visible using the @hideOn and @hidden decorators:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "You can control when properties are visible using the @hideOn and @hidden decorators:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, list } from '@decaf-ts/decorator-validation';\nimport { uimodel, uilistitem, uilistprop, uielement } from '@decaf-ts/ui-decorators';\n\n// Define a list item model\n@uimodel()\n@uilistitem('li', { class: 'todo-item' })\nclass TodoItem extends Model {\n  @uielement('span', { class: 'todo-text' })\n  text: string;\n\n  @uielement('input', { type: 'checkbox' })\n  completed: boolean;\n}\n\n// Define a list container model\n@uimodel('div', { class: 'todo-app' })\nclass TodoList extends Model {\n  @uielement('h1')\n  title: string = 'My Todo List';\n\n  @list(TodoItem)\n  @uilistprop('items', { class: 'todo-items-container' })\n  items: TodoItem[];\n}\n\n// Usage\nconst todoList = new TodoList();\ntodoList.items = [\n  new TodoItem({ text: 'Learn TypeScript', completed: true }),\n  new TodoItem({ text: 'Build a UI with decorators', completed: false })\n];\n\nconst renderedList = todoList.render();\n",
        "context": "You can render lists of models using the @uilistitem and @uilistprop decorators:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "You can render lists of models using the @uilistitem and @uilistprop decorators:"
      },
      {
        "lang": "typescript",
        "code": "import { Model } from '@decaf-ts/decorator-validation';\nimport { RenderingEngine, FieldDefinition } from '@decaf-ts/ui-decorators';\n\n// Define the output type for your rendering engine\ntype ReactElement = any; // Replace with actual React element type\n\n// Create a custom rendering engine for React\nclass ReactRenderingEngine extends RenderingEngine<ReactElement> {\n  constructor() {\n    super('react'); // Specify the engine flavor\n  }\n\n  // Initialize the engine (required abstract method)\n  async initialize(...args: any[]): Promise<void> {\n    // Import React or perform any other initialization\n    this.initialized = true;\n  }\n\n  // Implement the render method (required abstract method)\n  render<M extends Model>(\n    model: M,\n    globalProps: Record<string, unknown> = {},\n    ...args: any[]\n  ): ReactElement {\n    // Convert the model to a field definition\n    const fieldDef = this.toFieldDefinition(model, globalProps);\n\n    // Convert the field definition to a React element\n    return this.createReactElement(fieldDef);\n  }\n\n  // Helper method to create React elements\n  private createReactElement(fieldDef: FieldDefinition<ReactElement>): ReactElement {\n    // Implementation would use React.createElement or JSX\n    // This is just a placeholder\n    return {\n      type: fieldDef.tag,\n      props: {\n        ...fieldDef.props,\n        children: fieldDef.children?.map(child => this.createReactElement(child))\n      }\n    };\n  }\n}\n\n// Register the custom rendering engine\nnew ReactRenderingEngine();\n\n// Now models can specify to use this engine\n@uimodel()\n@renderedBy('react')\nclass ReactComponent extends Model {\n  // ...\n}\n",
        "context": "To implement a custom rendering engine for a specific UI framework, you need to extend the RenderingEngine abstract class:",
        "source": "howto",
        "title": "To Implement A Custom Rendering Engine",
        "details": "To implement a custom rendering engine for a specific UI framework, you need to extend the RenderingEngine abstract class:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, required, email, minLength, pattern } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('form', { class: 'registration-form' })\nclass RegistrationForm extends Model {\n  @required()\n  @minLength(3)\n  @uielement('input', { type: 'text', placeholder: 'Username' })\n  username: string;\n\n  @required()\n  @email()\n  @uielement('input', { type: 'email', placeholder: 'Email' })\n  email: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$/) // Requires lowercase, uppercase, and digit\n  @uielement('input', { type: 'password', placeholder: 'Password' })\n  password: string;\n\n  // Validation will be automatically applied to the rendered UI elements\n}\n",
        "context": "The UI decorators library automatically integrates with the validation system from @decaf-ts/decorator-validation:",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "The UI decorators library automatically integrates with the validation system from @decaf-ts/decorator-validation:"
      },
      {
        "lang": "typescript",
        "code": "import { Model, attribute, required, email, minLength, maxLength, pattern } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement, renderedBy } from '@decaf-ts/ui-decorators';\n\n@uimodel('form', { class: 'registration-form', id: 'user-registration' })\n@renderedBy('html5') // Use the HTML5 rendering engine\nclass UserRegistration extends Model {\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'First Name',\n    class: 'form-control'\n  })\n  firstName: string;\n\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'Last Name',\n    class: 'form-control'\n  })\n  lastName: string;\n\n  @required()\n  @email()\n  @uielement('input', { \n    type: 'email', \n    placeholder: 'Email Address',\n    class: 'form-control'\n  })\n  email: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/)\n  @uielement('input', { \n    type: 'password', \n    placeholder: 'Password (min 8 chars, include uppercase, lowercase, number, and special char)',\n    class: 'form-control'\n  })\n  password: string;\n\n  @required()\n  @uielement('select', { class: 'form-control' })\n  country: string;\n\n  @attribute()\n  @uielement('textarea', { \n    placeholder: 'Tell us about yourself',\n    class: 'form-control',\n    rows: 4\n  })\n  bio: string;\n\n  @uielement('input', { \n    type: 'checkbox',\n    class: 'form-check-input'\n  })\n  acceptTerms: boolean = false;\n\n  @uielement('button', { \n    type: 'submit',\n    class: 'btn btn-primary'\n  })\n  submitButton: string = 'Register';\n}\n\n// Create an instance\nconst registration = new UserRegistration();\n\n// Render the form\nconst form = registration.render();\n\n// Check for validation errors\nconst errors = registration.hasErrors();\nif (errors) {\n  console.error('Validation errors:', errors);\n}\n",
        "context": "Here's a complete example showing how to use the UI decorators library to create a user registration form:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Here's a complete example showing how to use the UI decorators library to create a user registration form:"
      }
    ],
    "base_path": "ui-decorators"
  },
  {
    "name": "cli",
    "title": "cli",
    "description": "### Description\n\nThe Decaf-ts CLI is a powerful and extensible command-line interface framework designed to provide a unified entry point for all Decaf-ts modules. It enables developers to create modular CLI commands that can be discovered and executed through a single command-line tool.\n\n#### Core Components\n\n1. **CliWrapper**: The central class that manages the discovery, loading, and execution of CLI modules. It:\n   - Crawls the filesystem to find CLI module files\n   - Dynamically loads modules using JavaScript's import system\n   - Registers commands with Commander.js\n   - Provides a simple API for running commands\n\n2. **CLIUtils**: A utility class that provides helper methods for:\n   - Loading modules from files\n   - Normalizing imports between ESM and CommonJS formats\n   - Retrieving package information (name, version)\n   - Initializing Commander.js commands\n\n3. **CLI Module System**: A standardized way for Decaf-ts packages to expose CLI functionality:\n   - Modules are discovered by filename (cli-module.js)\n   - Each module exports a function that returns a Commander.js Command object\n   - Modules can define their own subcommands and options\n\n#### Key Features\n\n- **Dynamic Discovery**: Automatically finds CLI modules in the project and its dependencies\n- **Modular Architecture**: Each module can define its own commands independently\n- **Extensible**: New commands can be added without modifying the core CLI code\n- **Unified Interface**: All commands are accessible through the single `decaf` command\n- **Self-documenting**: Leverages Commander.js to provide help text and usage information\n\n#### Technical Details\n\nThe CLI uses a recursive filesystem crawler to find modules up to a configurable depth. It handles both ESM and CommonJS module formats, making it compatible with various JavaScript environments. The command structure follows the pattern:\n\n```\ndecaf <module> <command> [options]\n```\n\nWhere `<module>` is the name of a Decaf-ts module and `<command>` is a specific command provided by that module.\n",
    "summary": "Description The Decaf-ts CLI is a powerful and extensible command-line interface framework designed to provide a unified entry point for all Decaf-ts modules.",
    "examples": [
      {
        "lang": "",
        "code": "decaf <module> <command> [options]\n",
        "context": "The CLI uses a recursive filesystem crawler to find modules up to a configurable depth. It handles both ESM and CommonJS module formats, making it compatible with various JavaScript environments. The command structure follows the pattern:",
        "source": "description",
        "title": "The Cli Uses A Recursive Filesystem",
        "details": "The CLI uses a recursive filesystem crawler to find modules up to a configurable depth. It handles both ESM and CommonJS module formats, making it compatible with various JavaScript environments. The command structure follows the pattern:"
      },
      {
        "lang": "bash",
        "code": "# Get general help\nnpx decaf help\n\n# List all available modules\nnpx decaf list\n\n# Get help for a specific module\nnpx decaf help <module-name>\n\n# Run a command from a specific module\nnpx decaf <module-name> <command> [options]\n",
        "context": "The Decaf-ts CLI provides a unified command-line interface for all Decaf-ts modules. Here are some examples of how to use it:",
        "source": "howto",
        "title": "The Decaf Ts Cli Provides A",
        "details": "The Decaf-ts CLI provides a unified command-line interface for all Decaf-ts modules. Here are some examples of how to use it:"
      },
      {
        "lang": "typescript",
        "code": "import { Command } from \"commander\";\n\nexport default function myModule(): Command {\n  return new Command()\n    .command(\"hello <name>\")\n    .description(\"Say hello to someone\")\n    .action((name: string) => {\n      console.log(`Hello, ${name}!`);\n    });\n}\n",
        "context": "1. Create a file named cli-module.ts in your package:",
        "source": "howto",
        "title": "1 Create A File Named Cli",
        "details": "1. Create a file named cli-module.ts in your package:"
      },
      {
        "lang": "json",
        "code": "\"scripts\": {\n  \"build:cli\": \"tsc --project tsconfig.cli.json\"\n}\n",
        "context": "3. Add a build step to your package.json:",
        "source": "howto",
        "title": "3 Add A Build Step To",
        "details": "3. Add a build step to your package.json:"
      },
      {
        "lang": "typescript",
        "code": "import { CliWrapper } from \"@decaf-ts/cli\";\n\n// Create a new CLI wrapper with custom options\nconst cli = new CliWrapper(\"./src\", 2);\n\n// Run the CLI with custom arguments\ncli.run(process.argv)\n  .then(() => {\n    console.log(\"CLI commands executed successfully\");\n  })\n  .catch((error) => {\n    console.error(\"Error executing CLI commands:\", error);\n  });\n",
        "context": "You can also use the CliWrapper class programmatically in your own code:",
        "source": "howto",
        "title": "You Can Also Use The Cliwrapper",
        "details": "You can also use the CliWrapper class programmatically in your own code:"
      },
      {
        "lang": "typescript",
        "code": "import { CLIUtils } from \"@decaf-ts/cli\";\nimport { Command } from \"commander\";\n\n// Initialize a Command object with package information\nconst command = new Command();\nCLIUtils.initialize(command, \"./path/to/package\");\n\n// Get package information\nconst version = CLIUtils.packageVersion(\"./path/to/package\");\nconst name = CLIUtils.packageName(\"./path/to/package\");\n\n// Load a CLI module from a file\nconst modulePath = \"./path/to/cli-module.js\";\nCLIUtils.loadFromFile(modulePath)\n  .then((module) => {\n    const command = module();\n    console.log(\"Loaded command:\", command.name());\n  })\n  .catch((error) => {\n    console.error(\"Error loading module:\", error);\n  });\n",
        "context": "The CLIUtils class provides utility methods for working with CLI modules:",
        "source": "howto",
        "title": "The Cliutils Class Provides Utility Methods",
        "details": "The CLIUtils class provides utility methods for working with CLI modules:"
      }
    ],
    "base_path": "cli"
  },
  {
    "name": "for-couchdb",
    "title": "for-couchdb",
    "description": "### Description\n\nThe Decaf CouchDB Module is a versatile persistence layer designed to provide seamless integration between the Decaf.ts framework and CouchDB databases. It offers a comprehensive set of tools and abstractions that simplify working with CouchDB's unique features while maintaining type safety and following best practices.\n\n#### Core Components\n\n1. **CouchDBAdapter**: An abstract base class that provides the foundation for CouchDB database operations. It handles CRUD operations, sequence management, and error handling. Developers can extend this class to create custom adapters tailored to their specific needs.\n\n2. **Query System**: A powerful query builder with support for CouchDB's Mango queries:\n   - **CouchDBStatement**: Provides a fluent interface for building type-safe Mango queries\n   - **CouchDBPaginator**: Implements pagination for query results using CouchDB's bookmark system\n   - **Operator Translation**: Converts Decaf.ts core operators to CouchDB Mango operators\n\n3. **Indexing**: Tools for creating and managing CouchDB indexes:\n   - **Index Generation**: Automatically generates appropriate index configurations based on model metadata\n   - **Index Management**: Utilities for creating and maintaining indexes\n\n4. **Sequence Management**: A robust system for generating sequential IDs:\n   - **CouchDBSequence**: Implements the Sequence interface for CouchDB\n   - **Sequence Model**: Provides a data model for storing sequence information\n\n5. **Error Handling**: Specialized error types and utilities for handling CouchDB-specific errors:\n   - **Error Translation**: Converts CouchDB error codes and messages to appropriate Decaf.ts error types\n   - **IndexError**: Specialized error for index-related issues\n\n6. **Utilities**: Helper functions for common CouchDB operations:\n   - **Authentication**: Functions for handling CouchDB authentication\n   - **Connection Management**: Utilities for managing database connections\n   - **Document Processing**: Tools for processing CouchDB documents\n\nThis module serves as a bridge between your application and CouchDB, abstracting away the complexities of the database while providing a type-safe, consistent API that integrates seamlessly with the rest of the Decaf.ts ecosystem.\n",
    "summary": "Description The Decaf CouchDB Module is a versatile persistence layer designed to provide seamless integration between the Decaf.ts framework and CouchDB databases.",
    "examples": [
      {
        "lang": "typescript",
        "code": "import { CouchDBAdapter } from '@decaf-ts/for-couchdb';\nimport { Constructor, Model } from '@decaf-ts/decorator-validation';\nimport { MangoQuery } from '@decaf-ts/for-couchdb';\nimport { generateIndexes } from '@decaf-ts/for-couchdb';\nimport * as nano from 'nano';\n\n// Define your scope, flags, and context types\ninterface MyScope {\n  config: {\n    couchdb: {\n      url: string;\n      username: string;\n      password: string;\n      database: string;\n    }\n  }\n}\n\nclass MyCouchDBAdapter extends CouchDBAdapter<MyScope, MyFlags, MyContext> {\n  private db: any;\n\n  constructor(scope: MyScope) {\n    super(scope, 'my-couchdb', 'my-alias');\n\n    // Initialize connection to CouchDB\n    const { url, username, password, database } = scope.config.couchdb;\n    const connection = nano(url);\n    this.db = wrapDocumentScope(connection, database, username, password);\n  }\n\n  // Implement abstract methods\n  async index<M extends Model>(...models: Constructor<M>[]): Promise<void> {\n    const indexes = generateIndexes(models);\n    for (const index of indexes) {\n      try {\n        await this.db.createIndex(index);\n      } catch (error) {\n        throw this.parseError(error);\n      }\n    }\n  }\n\n  async raw<R>(rawInput: MangoQuery, docsOnly: boolean): Promise<R> {\n    try {\n      const result = await this.db.find(rawInput);\n      return docsOnly ? result.docs : result;\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async create(tableName: string, id: string | number, model: Record<string, any>, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const result = await this.db.insert(model);\n      return this.assignMetadata(model, result.rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async read(tableName: string, id: string | number, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const docId = this.generateId(tableName, id);\n      const doc = await this.db.get(docId);\n      return this.assignMetadata(doc, doc._rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async update(tableName: string, id: string | number, model: Record<string, any>, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const result = await this.db.insert(model);\n      return this.assignMetadata(model, result.rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async delete(tableName: string, id: string | number, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const docId = this.generateId(tableName, id);\n      const doc = await this.db.get(docId);\n      const result = await this.db.destroy(docId, doc._rev);\n      return { id, _deleted: true };\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n}\n",
        "context": "To use the CouchDB module, you need to create a concrete implementation of the CouchDBAdapter class:",
        "source": "howto",
        "title": "Database Access",
        "details": "To use the CouchDB module, you need to create a concrete implementation of the CouchDBAdapter class:"
      },
      {
        "lang": "typescript",
        "code": "import { model, required, validate } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk, index, table } from '@decaf-ts/core';\n\n@table('users')\n@model()\nexport class User extends BaseModel {\n  @pk()\n  id!: string;\n\n  @required()\n  @index()\n  email!: string;\n\n  @required()\n  firstName!: string;\n\n  @required()\n  lastName!: string;\n\n  @index()\n  age?: number;\n\n  constructor(data?: Partial<User>) {\n    super(data);\n  }\n}\n",
        "context": "Define your data models using the decorators from Decaf.ts:",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Define your data models using the decorators from Decaf.ts:"
      },
      {
        "lang": "typescript",
        "code": "import { Repository } from '@decaf-ts/core';\nimport { CouchDBRepository } from '@decaf-ts/for-couchdb';\nimport { User } from './models/User';\nimport { MyCouchDBAdapter } from './adapters/MyCouchDBAdapter';\n\n// Get the adapter instance\nconst adapter = new MyCouchDBAdapter(myScope);\n\n// Create a repository for the User model\nconst userRepository: CouchDBRepository<User, MyScope, MyFlags, MyContext> = \n  Repository.forModel(User, adapter.flavour);\n",
        "context": "Create a repository for your model:",
        "source": "howto",
        "title": "Database Access",
        "details": "Create a repository for your model: — Instantiates and configures a component."
      },
      {
        "lang": "typescript",
        "code": "// Create a new user\nconst newUser = new User({\n  id: '123',\n  email: 'john.doe@example.com',\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30\n});\n\n// Create\nconst createdUser = await userRepository.create(newUser);\n\n// Read\nconst user = await userRepository.read('123');\n\n// Update\nuser.age = 31;\nconst updatedUser = await userRepository.update(user);\n\n// Delete\nawait userRepository.delete('123');\n",
        "context": "Perform basic CRUD operations:",
        "source": "howto",
        "title": "Perform Basic Crud Operations",
        "details": "Perform basic CRUD operations: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { Condition } from '@decaf-ts/core';\n\n// Create a statement\nconst statement = adapter.Statement<User>();\n\n// Build a query to find users older than 25, sorted by lastName\nconst users = await statement\n  .from(User)\n  .where(Condition.attribute<User>('age').gt(25))\n  .orderBy('lastName', 'asc')\n  .limit(10)\n  .execute<User[]>();\n\n// Query with multiple conditions\nconst johnDoes = await statement\n  .from(User)\n  .where(\n    Condition.and(\n      Condition.attribute<User>('lastName').eq('Doe'),\n      Condition.attribute<User>('age').gt(18)\n    )\n  )\n  .execute<User[]>();\n\n// Select specific fields\nconst userEmails = await statement\n  .from(User)\n  .select(['email', 'firstName'])\n  .where(Condition.attribute<User>('age').gt(25))\n  .execute<Array<Pick<User, 'email' | 'firstName'>>>();\n",
        "context": "Build and execute queries using the Statement builder:",
        "source": "howto",
        "title": "Build And Execute Queries Using The",
        "details": "Build and execute queries using the Statement builder:"
      },
      {
        "lang": "typescript",
        "code": "// Create a paginator\nconst paginator = await adapter\n  .Statement<User>()\n  .from(User)\n  .where(Condition.attribute<User>('age').gt(18))\n  .orderBy('lastName', 'asc')\n  .paginate<User[]>(10); // 10 items per page\n\n// Get the first page\nconst page1 = await paginator.page(1);\n\n// Get the next page\nconst page2 = await paginator.page(2);\n",
        "context": "Paginate through query results:",
        "source": "howto",
        "title": "Database Access",
        "details": "Paginate through query results: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { SequenceOptions } from '@decaf-ts/core';\n\n// Create a sequence\nconst sequenceOptions: SequenceOptions = {\n  name: 'user-sequence',\n  startWith: 1000,\n  incrementBy: 1,\n  type: 'Number'\n};\n\nconst sequence = await adapter.Sequence(sequenceOptions);\n\n// Get the next value\nconst nextId = await sequence.next();\n\n// Get a range of values\nconst idRange = await sequence.range(5); // Returns 5 sequential IDs\n",
        "context": "Generate sequential IDs:",
        "source": "howto",
        "title": "Generate Sequential Ids",
        "details": "Generate sequential IDs: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { generateIndexDoc } from '@decaf-ts/for-couchdb';\n\n// Generate an index configuration\nconst indexConfig = generateIndexDoc(\n  'email',     // attribute\n  'users',     // tableName\n  ['firstName'], // compositions\n  'asc'        // order\n);\n\n// Create the index\nawait adapter.db.createIndex(indexConfig);\n\n// Initialize indexes for all models\nawait adapter.initialize();\n",
        "context": "Create and manage indexes:",
        "source": "howto",
        "title": "Create And Manage Indexes",
        "details": "Create and manage indexes: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { IndexError, ConflictError, NotFoundError } from '@decaf-ts/for-couchdb';\n\ntry {\n  // Some operation that might fail\n  await userRepository.read('non-existent-id');\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    console.error('Document not found:', error.message);\n  } else if (error instanceof ConflictError) {\n    console.error('Document conflict:', error.message);\n  } else if (error instanceof IndexError) {\n    console.error('Index error:', error.message);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n",
        "context": "Handle CouchDB-specific errors:",
        "source": "howto",
        "title": "Database Access",
        "details": "Handle CouchDB-specific errors: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { MangoQuery } from '@decaf-ts/for-couchdb';\n\n// Define a raw Mango query\nconst rawQuery: MangoQuery = {\n  selector: {\n    '??table': 'users',\n    age: { $gt: 25 },\n    lastName: { $eq: 'Doe' }\n  },\n  fields: ['_id', 'firstName', 'lastName', 'email'],\n  sort: [{ lastName: 'asc' }],\n  limit: 20\n};\n\n// Execute the raw query\nconst results = await adapter.raw(rawQuery, true);\n",
        "context": "Execute raw Mango queries:",
        "source": "howto",
        "title": "Execute Raw Mango Queries",
        "details": "Execute raw Mango queries: — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { reAuth, wrapDocumentScope, generateIndexName } from '@decaf-ts/for-couchdb';\n\n// Re-authenticate a connection\nawait reAuth(connection, 'username', 'password');\n\n// Wrap a document scope with automatic re-authentication\nconst db = wrapDocumentScope(connection, 'my-database', 'username', 'password');\n\n// Generate an index name\nconst indexName = generateIndexName('email', 'users', ['firstName'], 'asc');\n",
        "context": "Use utility functions for common operations:",
        "source": "howto",
        "title": "Use Utility Functions For Common Operations",
        "details": "Use utility functions for common operations:"
      }
    ],
    "base_path": "for-couchdb"
  },
  {
    "name": "for-nano",
    "title": "for-nano",
    "description": "### Description\n\nThis package integrates CouchDB via the Nano client into the decaf-ts data stack. It exposes a focused set of primitives that make CouchDB usage consistent with other decaf-ts backends (TypeORM, HTTP, Pouch, etc.), while retaining Nano’s flexibility.\n\nCore elements and their intents:\n\n- NanoAdapter\n  - Bridges decaf-ts Repository operations with Nano’s DocumentScope API.\n  - Implements repository-friendly CRUD: create, read, update, delete, plus bulk variants (createAll, readAll, updateAll, deleteAll).\n  - Preserves and manages CouchDB revision metadata transparently via PersistenceKeys.METADATA and CouchDBKeys.REV.\n  - Provides raw Mango query capability (raw) and index management (index).\n  - Offers connection and administration helpers: connect, createDatabase, deleteDatabase, createUser, deleteUser.\n  - Exposes Dispatch() to construct a NanoDispatch for change feed observation.\n  - Normalizes operation flags via flags(), ensuring user context is propagated from NanoFlags to the underlying operations.\n\n- NanoDispatch\n  - A Dispatch implementation that subscribes to CouchDB’s continuous changes feed through Nano.\n  - Parses change feed frames, groups them by table and operation (CREATE/UPDATE/DELETE), and notifies observers through updateObservers.\n  - Handles reconnection attempts and keeps track of the last processed update step (observerLastUpdate) for resilience.\n\n- NanoRepository\n  - A typed alias that binds Repository to the Nano-specific types: MangoQuery, NanoAdapter, NanoFlags, and Context.\n  - Enables consumers to use a familiar Repository API with CouchDB when paired with NanoAdapter.\n\n- Types and constants\n  - NanoFlags extends RepositoryFlags with a required user object (name, roles?) for consistent auth context propagation.\n  - NanoConfig captures the minimal connection shape (user, password, host, dbName) for setting up adapters.\n  - NanoFlavour identifies this backend for selection in multi-backend setups.\n  - VERSION exposes the package version string.\n\nDesign considerations:\n\n- Predictable metadata management: CouchDB’s _rev is captured in internal metadata, avoiding accidental leakage into domain models.\n- Bulk operations are error-aware: mixed success/failure responses are aggregated and surfaced as InternalError, preserving the failing reasons from Nano.\n- Testability: All core behaviors (CRUD, bulk, raw, admin helpers, dispatch) are covered by unit tests and written to be easily mocked.\n- Interop-first: Reuses shared types from @decaf-ts/for-couchdb (e.g., MangoQuery, CouchDBKeys) so that query building and index generation are consistent across CouchDB-based adapters.\n\n",
    "summary": "Description This package integrates CouchDB via the Nano client into the decaf-ts data stack.",
    "examples": [
      {
        "lang": "ts",
        "code": "import {\n  BaseModel,\n  Repository,\n  pk,\n  uses,\n} from \"@decaf-ts/core\";\nimport { model, Model, ModelArg, required } from \"@decaf-ts/decorator-validation\";\nimport type { NanoRepository } from \"@decaf-ts/for-nano\";\n\n@uses(\"nano\")\n@model()\nclass UserModel extends BaseModel implements Model {\n  @pk({ type: \"String\" })\n  id!: string; // primary key\n\n  @required()\n  name!: string;\n\n  constructor(arg?: ModelArg<UserModel>) {\n    super(arg);\n  }\n}\n\nconst repo: NanoRepository<UserModel> = Repository.forModel<UserModel, NanoRepository<UserModel>>(UserModel);\n",
        "context": "Description: Declare a model with table/primary-key decorators and get a Nano-powered repository for it. The flavour is auto-wired by importing @decaf-ts/for-nano.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Declare a model with table/primary-key decorators and get a Nano-powered repository for it. The flavour is auto-wired by importing @decaf-ts/for-nano."
      },
      {
        "lang": "ts",
        "code": "import type { NanoFlags } from \"@decaf-ts/for-nano\";\n\nconst flags: NanoFlags = {\n  user: { name: \"tester\", roles: [\"writer\"] },\n};\n",
        "context": "Description: Pass NanoFlags in repository calls; the user info is propagated to operations by the adapter under the hood.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Pass NanoFlags in repository calls; the user info is propagated to operations by the adapter under the hood."
      },
      {
        "lang": "ts",
        "code": "import { PersistenceKeys } from \"@decaf-ts/core\";\n\nconst created = await repo.create(new UserModel({ id: \"user:1\", name: \"Ada\" }));\n// created[PersistenceKeys.METADATA] contains the new revision string, e.g., \"1-a\"\n\nconst loaded = await repo.read(\"user:1\");\nconsole.log(loaded.name);\n",
        "context": "Description: Insert a document and read it back. CouchDB revisions are stored in PersistenceKeys.METADATA transparently.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Insert a document and read it back. CouchDB revisions are stored in PersistenceKeys.METADATA transparently."
      },
      {
        "lang": "ts",
        "code": "const users = [\n  new UserModel({ id: \"user:2\", name: \"Lin\" }),\n  new UserModel({ id: \"user:3\", name: \"Grace\" }),\n];\nconst createdMany = await repo.createAll(users);\n\nconst fetchedMany = await repo.readAll([\"user:2\", \"user:3\"]);\n",
        "context": "Description: Insert multiple documents and then fetch them by IDs. Bulk operations aggregate errors.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Insert multiple documents and then fetch them by IDs. Bulk operations aggregate errors."
      },
      {
        "lang": "ts",
        "code": "let u = await repo.read(\"user:1\");\n// ... mutate\nu.name = \"Ada Lovelace\";\n// u already has PersistenceKeys.METADATA from read()\nu = await repo.update(u);\n\n// Bulk update requires each model to carry its matching metadata\nconst u2 = await repo.read(\"user:2\");\nconst u3 = await repo.read(\"user:3\");\nconst updatedMany = await repo.updateAll([u2, u3]);\n",
        "context": "Description: Update requires the previous revision in metadata. The new revision is written back into metadata.",
        "source": "howto",
        "title": "Description Update Requires The Previous Revision",
        "details": "Description: Update requires the previous revision in metadata. The new revision is written back into metadata."
      },
      {
        "lang": "ts",
        "code": "const deleted = await repo.delete(\"user:3\");\n\nconst deletedMany = await repo.deleteAll([\"user:1\", \"user:2\"]);\n",
        "context": "Description: Delete a single document, or delete in bulk by IDs.",
        "source": "howto",
        "title": "Description Delete A Single Document Or",
        "details": "Description: Delete a single document, or delete in bulk by IDs."
      },
      {
        "lang": "ts",
        "code": "import { Condition, OrderDirection } from \"@decaf-ts/core\";\n\n// Select all as full UserModel objects\nconst all = await repo.select().execute();\n\n// Select only specific attributes\nconst projected = await repo.select([\"name\"]).execute();\n\n// Conditional queries\nconst nameEq = Condition.attribute<UserModel>(\"name\").eq(\"Ada Lovelace\");\nconst named = await repo.select().where(nameEq).execute();\n\n// Ordering (requires proper indexes configured for CouchDB)\nconst ordered = await repo.select().orderBy([\"name\", OrderDirection.ASC]).execute();\n",
        "context": "Description: Use the Repository query API to filter and project results.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: Use the Repository query API to filter and project results."
      },
      {
        "lang": "ts",
        "code": "import type { Observer } from \"@decaf-ts/core\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\n\nconst observer: Observer = {\n  async refresh(table: string, operation: OperationKeys | string, ids: string[]) {\n    if (operation.toString() === OperationKeys.DELETE.toString()) {\n      console.log(`Deleted from ${table}:`, ids);\n    }\n  },\n};\n\nawait repo.observe(observer);\n// ... later\nawait repo.unObserve(observer);\n",
        "context": "Description: Subscribe to CREATE/UPDATE/DELETE events using the Observer interface. The repository wires Nano’s change feed internally.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Subscribe to CREATE/UPDATE/DELETE events using the Observer interface. The repository wires Nano’s change feed internally."
      },
      {
        "lang": "ts",
        "code": "import { NanoFlavour } from \"@decaf-ts/for-nano\";\nconsole.log(NanoFlavour); // \"nano\"\n",
        "context": "Description: Use NanoFlavour as an identifier in multi-backend setups.",
        "source": "howto",
        "title": "Configure and Initialize",
        "details": "Description: Use NanoFlavour as an identifier in multi-backend setups."
      },
      {
        "lang": "ts",
        "code": "import type { NanoRepository } from \"@decaf-ts/for-nano\";\nimport type { Model } from \"@decaf-ts/decorator-validation\";\n\nclass MyModel implements Model {\n  _id!: string;\n}\n\nlet myRepo!: NanoRepository<MyModel>;\n",
        "context": "Description: Bind your model type to a repository powered by the Nano backend.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Bind your model type to a repository powered by the Nano backend."
      },
      {
        "lang": "ts",
        "code": "import { NanoAdapter } from \"@decaf-ts/for-nano\";\n\n// Build a Nano (CouchDB) connection\nconst url = NanoAdapter.connect(\"admin\", \"secret\", \"localhost:5984\", \"http\");\n\n// Ensure a database exists / manage users\nawait NanoAdapter.createDatabase(url, \"mydb\");\n// ... createUser/deleteUser, deleteDatabase, etc.\n",
        "context": "Description: If you must manage CouchDB resources, @decaf-ts/for-nano exports static helpers on NanoAdapter no direct instantiation required. These are not part of the Repository API.",
        "source": "howto",
        "title": "Call an HTTP API",
        "details": "Description: If you must manage CouchDB resources, @decaf-ts/for-nano exports static helpers on NanoAdapter no direct instantiation required. These are not part of the Repository API."
      }
    ],
    "base_path": "for-nano"
  },
  {
    "name": "for-pouch",
    "title": "for-pouch",
    "description": "# decaf-ts / for-pouch — Detailed Description\n\nThis package integrates PouchDB with the decaf-ts data and decorator ecosystem. It provides:\n- A concrete PouchAdapter that implements persistence against a PouchDB backend (local or remote CouchDB-compatible server).\n- A typed PouchRepository alias for convenience when working with decaf-ts Repository and Mango queries.\n- Configuration and flag types tailored for PouchDB usage.\n- A module entry that wires flavour-specific decorations for createdBy/updatedBy when the module is loaded.\n\nThe intent of this library is to offer an ergonomic, type-safe repository pattern on top of PouchDB/CouchDB, including:\n- CRUD operations (single and bulk) with proper error mapping.\n- Query support via Mango queries, sorting with defined indexes, and pagination via core utilities.\n- Support for multiple databases and aliases.\n- Seamless model decoration with decaf-ts decorators, including created/updated metadata and relation handling.\n\n\nAPI Inventory by File\n\n1) src/constants.ts\n- PouchFlavour: string = \"pouch\" — Flavour identifier used by the decorator system and Repository.forModel resolution.\n- DefaultLocalStoragePath: string = \"local_dbs\" — Default path for local PouchDB storage when running without a remote host.\n\n2) src/types.ts\n- interface PouchFlags extends RepositoryFlags\n  - UUID: string — a per-operation/user identifier injected in Context and used by createdBy/updatedBy decoration.\n- type PouchConfig\n  - user?: string — remote username.\n  - password?: string — remote password.\n  - host?: string — remote host.\n  - protocol?: \"http\" | \"https\" — remote protocol.\n  - port?: number — remote port (optional if in host).\n  - dbName: string — database name.\n  - storagePath?: string — base path for local databases.\n  - plugins: any[] — list of PouchDB plugins to register before client creation.\n\n3) src/PouchRepository.ts\n- type PouchRepository<M extends Model> = Repository<M, MangoQuery, PouchAdapter>\n  - Convenience alias that binds the decaf-ts Repository with MangoQuery and the PouchAdapter backend.\n\n4) src/adapter.ts\n- function createdByOnPouchCreateUpdate<M, R, V>(this: R, context: Context<PouchFlags>, data: V, key: keyof M, model: M): Promise<void>\n  - Decorator handler: copies context UUID into the model[key]. Throws UnsupportedError when unavailable.\n- class PouchAdapter extends CouchDBAdapter<PouchConfig, PouchDB.Database, PouchFlags, Context<PouchFlags>>\n  - constructor(config: PouchConfig, alias?: string)\n    - Initializes the adapter with configuration and optional alias.\n  - getClient(): PouchDB.Database\n    - Lazy client getter; registers provided plugins; creates local or remote client.\n  - flags(operation, model, flags?): Context<PouchFlags>\n    - Prepares operation context and attaches Pouch-specific flags when required.\n  - index(models: Constructor<Model>[]): Promise<CreateIndexResponse[]>\n    - Generates remote/local indexes based on @index decorators in the given models.\n  - initialize(): Promise<CreateIndexResponse[]>\n    - Inherited via CouchDBAdapter; here used in tests to create indexes for sorting. (Called on the adapter instance.)\n  - create(tableName: string, id: Id, model: Model): Promise<Model>\n  - createAll(tableName: string, ids: Id[], models: Model[]): Promise<Model[]>\n  - read(tableName: string, id: Id): Promise<Model>\n  - readAll(tableName: string, ids: Id[]): Promise<Model[]>\n  - update(tableName: string, id: Id, model: Model): Promise<Model>\n  - updateAll(tableName: string, ids: Id[], models: Model[]): Promise<Model[]>\n  - delete(tableName: string, id: Id): Promise<Model>\n  - deleteAll(tableName: string, ids: Id[]): Promise<Model[]>\n    - Bulk variants aggregate item-level errors and throw a mapped BaseError when any failures occur.\n  - raw<T = any>(rawInput: any, process: boolean): Promise<T>\n    - Executes a raw Mango find request. When process=true, returns docs array; otherwise returns full find response.\n  - static parseError(err: unknown): BaseError\n    - Maps PouchDB/HTTP errors and messages into decaf-ts BaseError subtypes, including ConflictError/NotFoundError/ConnectionError.\n    - The instance method parseError delegates to the static implementation.\n  - static decoration(): void\n    - Registers createdByOnPouchCreateUpdate for the pouch flavour so createdBy/updatedBy fields are managed automatically.\n\n5) src/index.ts\n- Side-effect call: PouchAdapter.decoration() — ensures flavour-specific decorator handler is registered upon import.\n- Re-exports: constants, PouchRepository, types, adapter.\n- VERSION: string — package version placeholder replaced at build time.\n\n\nBehavioral Notes and Design Intent\n\n- Multiple DB support: A PouchAdapter can be constructed with an alias; Repository.forModel(Model, alias) resolves the repository for that specific adapter/DB. This enables working with multiple databases concurrently.\n- Decorator-driven modeling: Use @model, @pk, @index, @readonly, and other decaf-ts decorators to describe schemas and constraints. The adapter interprets indexes through @index and can generate them via initialize() or index().\n- Querying: The core Repository composes Mango queries via select().where(Condition...).orderBy(...). PouchAdapter translates and executes these queries with PouchDB Find.\n- Pagination: Use core Paginator returned by paginate(size) on a selection. Sorting requires proper indexes.\n- Error translation: PouchAdapter.parseError normalizes errors from PouchDB/CouchDB and HTTP status codes into a stable error hierarchy for consistent handling.\n- Raw access: raw() allows advanced Mango usage or debugging by running low-level queries and choosing between processed docs or the full response.\n",
    "summary": "decaf-ts / for-pouch — Detailed Description This package integrates PouchDB with the decaf-ts data and decorator ecosystem.",
    "examples": [
      {
        "lang": "ts",
        "code": "import { PouchAdapter, DefaultLocalStoragePath, VERSION } from \"@decaf-ts/for-pouch\";\n\n// Example: Local (in-memory) PouchDB using the memory adapter plugin\nasync function makeMemoryAdapter() {\n  const memory = (await import(\"pouchdb-adapter-memory\")).default as any;\n  // Alias allows multiple DBs; useful in multi-tenant scenarios\n  const adapter = new PouchAdapter({ dbName: \"local_mem_db\", plugins: [memory] }, \"mem-local\");\n  // Accessing the client verifies plugins and initializes the PouchDB instance\n  const client: any = (adapter as any).client;\n  return adapter;\n}\n\n// Example: Remote CouchDB-compatible server\nasync function makeRemoteAdapter() {\n  const adapter = new PouchAdapter(\n    {\n      protocol: \"http\",\n      host: \"localhost:5984\",\n      user: \"admin\",\n      password: \"secret\",\n      dbName: \"my_database\",\n      plugins: [],\n    },\n    \"remote-1\"\n  );\n  return adapter;\n}\n\nconsole.log(\"for-pouch version:\", VERSION);\n",
        "context": "You can work with a local/in-memory database useful for tests or a remote CouchDB-compatible server.",
        "source": "howto",
        "title": "Database Access",
        "details": "You can work with a local/in-memory database useful for tests or a remote CouchDB-compatible server."
      },
      {
        "lang": "ts",
        "code": "import {\n  BaseModel,\n  Repository,\n  OrderDirection,\n  pk,\n  index,\n  uses,\n} from \"@decaf-ts/core\";\nimport {\n  Model,\n  model,\n  required,\n  minlength,\n  min,\n  type,\n  ModelArg,\n} from \"@decaf-ts/decorator-validation\";\n\n@uses(\"pouch\")\n@model()\nclass User extends BaseModel {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @min(18)\n  @index([OrderDirection.DSC, OrderDirection.ASC])\n  age!: number;\n\n  @required()\n  @minlength(5)\n  name!: string;\n\n  @required()\n  @type([String.name])\n  sex!: \"M\" | \"F\";\n\n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nModel.setBuilder(Model.fromModel);\n",
        "context": "Use decaf-ts decorators to define your schema, indexes, and target flavour. The @uses\"pouch\" decorator ties the model to this adapter flavour.",
        "source": "howto",
        "title": "Validate Data with Schema",
        "details": "Use decaf-ts decorators to define your schema, indexes, and target flavour. The @uses\"pouch\" decorator ties the model to this adapter flavour."
      },
      {
        "lang": "ts",
        "code": "import { Repository } from \"@decaf-ts/core\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function crudExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Create\n  const created = await repo.create(\n    new User({ name: \"user_name_1\", age: 20, sex: \"M\" })\n  );\n\n  // Read\n  const read = await repo.read(created.id);\n\n  // Update\n  const updated = await repo.update(new User({ ...created, name: \"new_name\" }));\n\n  // Delete\n  const deleted = await repo.delete(created.id);\n\n  return { created, read, updated, deleted };\n}\n",
        "context": "3 Basic CRUD with Repository and PouchAdapter",
        "source": "howto",
        "title": "Database Access",
        "details": "3 Basic CRUD with Repository and PouchAdapter"
      },
      {
        "lang": "ts",
        "code": "async function bulkExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Create many\n  const models = Array.from({ length: 5 }, (_, i) =>\n    new User({ name: `user_${i + 1}`.padEnd(6, \"_\"), age: 18 + i, sex: i % 2 ? \"F\" : \"M\" })\n  );\n  const created = await repo.createAll(models);\n\n  // Read many by id\n  const ids = created.map((u) => u.id);\n  const many = await repo.readAll(ids);\n\n  // Update many\n  const updated = await repo.updateAll(\n    many.map((u) => new User({ ...u, name: u.name + \"_x\" }))\n  );\n\n  // Delete many\n  const deleted = await repo.deleteAll(updated.map((u) => u.id));\n  return { created, many, updated, deleted };\n}\n",
        "context": "4 Bulk Operations createAll, readAll, updateAll, deleteAll",
        "source": "howto",
        "title": "4 Bulk Operations Createall Readall Updateall",
        "details": "4 Bulk Operations createAll, readAll, updateAll, deleteAll"
      },
      {
        "lang": "ts",
        "code": "import { Condition, OrderDirection } from \"@decaf-ts/core\";\n\nasync function queryExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Insert sample data\n  await repo.createAll(\n    [1, 2, 3, 4, 5].map((i) => new User({ name: `user_name_${i}`, age: 18 + i % 3, sex: i % 2 ? \"F\" : \"M\" }))\n  );\n\n  // Fetch full objects\n  const all = await repo.select().execute();\n\n  // Fetch only selected attributes\n  const projected = await repo.select([\"age\", \"sex\"]).execute();\n\n  // Conditional filtering\n  const cond = Condition.attribute<User>(\"age\").eq(20);\n  const exactly20 = await repo.select().where(cond).execute();\n\n  // Sorting requires proper indexes (use adapter.initialize() to build from @index decorators)\n  await adapter.initialize();\n  const sorted = await repo.select().orderBy([\"age\", OrderDirection.DSC]).execute();\n\n  return { all, projected, exactly20, sorted };\n}\n",
        "context": "5 Querying with select, where, and orderBy",
        "source": "howto",
        "title": "Database Access",
        "details": "5 Querying with select, where, and orderBy"
      },
      {
        "lang": "ts",
        "code": "import { Paginator } from \"@decaf-ts/core\";\n\nasync function paginationExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  await adapter.initialize();\n  const paginator: Paginator<User, any> = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.DSC])\n    .paginate(10);\n\n  const page1 = await paginator.page();\n  const page2 = await paginator.next();\n  return { page1, page2 };\n}\n",
        "context": "6 Pagination",
        "source": "howto",
        "title": "6 Pagination",
        "details": "6 Pagination — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { Repository } from \"@decaf-ts/core\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function multiDbExample() {\n  const memory = (await import(\"pouchdb-adapter-memory\")).default as any;\n\n  // Two adapters with distinct aliases\n  const db1 = new PouchAdapter({ dbName: \"db1\", plugins: [memory] }, \"db1\");\n  const db2 = new PouchAdapter({ dbName: \"db2\", plugins: [memory] }, \"db2\");\n\n  // Repository.forModel can resolve by alias (after @uses(\"pouch\") on the model)\n  const repo1 = Repository.forModel(User, \"db1\");\n  const repo2 = Repository.forModel(User, \"db2\");\n\n  const u1 = await repo1.create(new User({ name: \"A_user\", age: 21, sex: \"M\" }));\n  const u2 = await repo2.create(new User({ name: \"B_user\", age: 22, sex: \"F\" }));\n\n  const again1 = await repo1.read(u1.id);\n  const again2 = await repo2.read(u2.id);\n  return { again1, again2 };\n}\n",
        "context": "7 Multiple Databases via Alias",
        "source": "howto",
        "title": "Database Access",
        "details": "7 Multiple Databases via Alias — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { CouchDBKeys } from \"@decaf-ts/for-couchdb\";\n\nasync function rawExample(adapter: PouchAdapter) {\n  const client: any = (adapter as any).client;\n  await client.put({ [CouchDBKeys.ID]: \"r1\", type: \"row\", x: 1 });\n  await client.put({ [CouchDBKeys.ID]: \"r2\", type: \"row\", x: 2 });\n\n  // process=true -> returns docs array only\n  const docsOnly = await adapter.raw<any[]>({ selector: { type: { $eq: \"row\" } } }, true);\n\n  // process=false -> returns the full FindResponse\n  const full = await adapter.raw<any>({ selector: { type: { $eq: \"row\" } } }, false);\n\n  return { docsOnly, full };\n}\n",
        "context": "8 Using raw for Advanced Mango Queries",
        "source": "howto",
        "title": "8 Using Raw For Advanced Mango",
        "details": "8 Using raw for Advanced Mango Queries — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { BaseError } from \"@decaf-ts/db-decorators\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function parseErrorExample(adapter: PouchAdapter) {\n  try {\n    await adapter.read(\"tbl\", \"no-such-id\");\n  } catch (e) {\n    // Convert low-level errors to decaf-ts BaseError shape\n    const parsed = PouchAdapter.parseError(e);\n    if (parsed instanceof BaseError) {\n      // handle known error types (ConflictError, NotFoundError, etc.)\n      console.warn(\"Handled decaf error:\", parsed.message);\n    } else {\n      throw e;\n    }\n  }\n}\n",
        "context": "9 Error Handling with parseError",
        "source": "howto",
        "title": "9 Error Handling With Parseerror",
        "details": "9 Error Handling with parseError — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { createdByOnPouchCreateUpdate, PouchFlags } from \"@decaf-ts/for-pouch\";\nimport { Context } from \"@decaf-ts/db-decorators\";\n\nclass ExampleModel { createdBy?: string }\n\nasync function createdByExample() {\n  const ctx = new Context<PouchFlags>().accumulate({ UUID: \"user-123\" });\n  const model = new ExampleModel();\n  await createdByOnPouchCreateUpdate.call(\n    {} as any,\n    ctx,\n    {} as any,\n    \"createdBy\" as any,\n    model as any\n  );\n  // model.createdBy === \"user-123\"\n  return model;\n}\n",
        "context": "The module registers a handler that copies a context UUID into the createdBy/updatedBy fields for the pouch flavour. In advanced cases you can call the handler directly, as shown in tests.",
        "source": "howto",
        "title": "Database Access",
        "details": "The module registers a handler that copies a context UUID into the createdBy/updatedBy fields for the pouch flavour. In advanced cases you can call the handler directly, as shown in tests."
      },
      {
        "lang": "ts",
        "code": "import type { PouchConfig, PouchFlags } from \"@decaf-ts/for-pouch\";\nimport { PouchFlavour, DefaultLocalStoragePath } from \"@decaf-ts/for-pouch\";\n\nconst flavour: string = PouchFlavour; // \"pouch\"\nconst defaultPath: string = DefaultLocalStoragePath; // \"local_dbs\"\n\nconst cfg: PouchConfig = {\n  dbName: \"sample\",\n  plugins: [],\n};\n\nconst flags: PouchFlags = {\n  UUID: \"user-xyz\",\n};\n",
        "context": "11 Types and Constants",
        "source": "howto",
        "title": "11 Types And Constants",
        "details": "11 Types and Constants"
      }
    ],
    "base_path": "for-pouch"
  },
  {
    "name": "for-typeorm",
    "title": "for-typeorm",
    "description": "# Decaf.ts for TypeORM — Detailed Description\n\nDecaf.ts for TypeORM provides a complete implementation of Decaf.ts' data access abstractions backed by a TypeORM DataSource. It bridges Decaf models, repositories, and query primitives with TypeORM's ORM facilities, while keeping a consistent API across different database adapters in the Decaf.ts ecosystem.\n\nCore capabilities include:\n- An Adapter (TypeORMAdapter) that encapsulates connection management, CRUD operations, schema creation helpers, index generation, raw execution, error translation, and wiring of decorators.\n- A Repository (TypeORMRepository) that exposes typed CRUD and batch operations for a given Model, validating data via @decaf-ts/db-decorators and @decaf-ts/decorator-validation.\n- Query composition via TypeORMStatement, which converts the Decaf.ts core Statement API into TypeORM Find options and QueryBuilder calls. Combined with TypeORMPaginator to paginate results.\n- Decorator overrides that mirror TypeORM’s decorators (Entity, Column, PrimaryColumn, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, JoinColumn, OneToOne, OneToMany, ManyToOne) ensuring compatible metadata is emitted for the adapter.\n- Sequence utilities (TypeORMSequence) for generating and reading database sequence values.\n- Index generation helpers (generateIndexes) to produce SQL index creation statements based on model metadata.\n- Typed constants, enums, and helper types for SQL operators, query containers, and PostgreSQL result shapes.\n\nArchitecture and responsibilities\n\n1. Adapter layer\n   - TypeORMAdapter is the central integration point. It:\n     - Holds a TypeORM DataSource and provides dataSource(), connect(), createDatabase(), createUser(), and related helpers.\n     - Implements CRUD over entities: create, read, update, delete, and their batch counterparts (createAll, readAll, updateAll, deleteAll).\n     - Provides Statement(), Sequence(), Repository() factories returning TypeORM-specific implementations.\n     - Indexing support via index(models) which uses generateIndexes to build SQL statements for indexes.\n     - Raw execution via raw({ query, values }).\n     - Error translation through parseError() mapping DB errors to Decaf.ts errors.\n     - Schema creation helpers: parseTypeToPostgres, parseValidationToPostgres, parseRelationsToPostgres, createTable.\n     - Decoration() static initializer: wires Decaf.ts model decorators and relation metadata to TypeORM’s metadata storage using the overrides in src/overrides.\n\n2. Repository layer\n   - TypeORMRepository<M> extends the Decaf.ts core Repository and provides:\n     - Validation enforcement (enforceDBDecorators) and Context propagation.\n     - Standard CRUD and batch operations that delegate to the adapter, applying OperationKeys flags and TypeORMFlags.\n     - Query builder access via queryBuilder() to get a TypeORMStatement for fluent querying.\n\n3. Query layer\n   - TypeORMStatement<M, R> extends core Statement and composes queries as TypeORM Find options/QueryBuilder calls.\n     - build() resolves the internal statement into a TypeORMQuery container.\n     - raw() executes a SelectQueryBuilder and returns getMany() results.\n     - paginate(size) returns a TypeORMPaginator bound to this statement.\n     - translateOperators() maps Decaf.ts Operator/GroupOperator to SQL via TypeORMOperator/TypeORMGroupOperator.\n   - TypeORMPaginator<M, R> implements page navigation using TypeORM’s repository.findAndCount with take/skip and maps rows back to models via the adapter’s revert().\n\n4. Decorator overrides\n   - Functions mirroring TypeORM decorators but routed through our overrides/utilities to control metadata aggregation:\n     - Entity, Column, PrimaryColumn, PrimaryGeneratedColumn.\n     - CreateDateColumn, UpdateDateColumn.\n     - JoinColumn.\n     - OneToOne, OneToMany, ManyToOne.\n   - These register metadata through getMetadataArgsStorage() and the helper aggregateOrNewColumn to avoid duplicates and merge options.\n\n5. Sequences\n   - TypeORMSequence implements the Decaf.ts Sequence abstraction using Adapter.raw to query and increment PostgreSQL sequences, parsing values according to the configured type.\n\n6. Index generation\n   - generateIndexes(models) inspects Repository.indexes metadata and returns a list of TypeORMQuery statements to create indexes. The Adapter can execute them via raw().\n\n7. Dispatching and events\n   - TypeORMDispatch extends core Dispatch to subscribe a TypeORM DataSource to a TypeORMEventSubscriber, translating TypeORM entity events (insert/update/delete) into OperationKeys notifications for Decaf.ts observers.\n   - TypeORMEventSubscriber listens to afterInsert/afterUpdate/afterRemove, resolves the model/table via Repository.table, and calls adapter.updateObservers.\n\n8. Constants, types, and utilities\n   - constants: reservedAttributes regex, TypeORMFlavour identifier, TypeORMKeys for common DB keys.\n   - query/constants: TypeORMQueryLimit and mappings for TypeORMOperator (comparison operators) and TypeORMGroupOperator (logical operators), plus TypeORMConst.\n   - types: SQLOperator enum; TypeORMQuery container; TypeORMFlags; TypeORMTableSpec.\n   - raw/postgres: FieldDef, QueryResultBase, QueryResult, QueryArrayResult for typing raw Postgres results.\n   - utils: convertJsRegexToPostgres() to transform JS RegExp into PostgreSQL POSIX pattern strings.\n\nTypical usage flow\n\n1. Initialize and decorate\n   - Import from `@decaf-ts/for-typeorm` index. It calls TypeORMAdapter.decoration() on import to ensure decorators are wired.\n2. Configure adapter and data source\n   - Construct a TypeORMAdapter with DataSourceOptions, then initialize/connect.\n3. Define models with decaf-ts decorators, keeping it consistent decorators:\n   - use @table() instead of @Entity();\n   - use @column() instead of @Column();\n   - always use decaf-ts decorators instead of TypeORM decorators. Decaf's will be wired to TypeORM's metadata storage.\n4. Use repositories\n   - Use Repository.forModel to get a decaf repository for your model.\n   - Get a TypeORMRepository native features use repository.nativeRepository().\n5. Build queries\n   - Using the decaf query api, all queries are guaranteed to use prepared statements via repository.select()\n   - Use repository.queryBuilder() to use native typeorm query builder for edge cases or advanced queries.\n6. Sequences and indexes\n   - Use TypeORMSequence for sequence values and generateIndexes to pre-create DB indexes.\n7. Observe changes\n   - Use TypeORMDispatch to subscribe to entity events and update observers in real time.\n\nError handling\n\n- IndexError signals issues with index generation/handling.\n- Adapter.parseError translates TypeORM/DB errors into Decaf.ts error types (ConflictError, NotFoundError, etc.) for consistent error semantics across adapters.\n\nDatabase and compatibility notes\n\n- The adapter targets TypeORM; many helper utilities assume PostgreSQL (e.g., regex operators, sequence queries). The code converts JS regex to PostgreSQL-compatible patterns and defines raw result typings for Postgres.\n\nExports overview (primary)\n\n- Classes: TypeORMAdapter, TypeORMRepository, TypeORMDispatch, TypeORMEventSubscriber, TypeORMStatement, TypeORMPaginator, TypeORMSequence, IndexError.\n- Decorators and helpers: Entity, Column, PrimaryColumn, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, JoinColumn, OneToOne, OneToMany, ManyToOne, aggregateOrNewColumn.\n- Query utilities: TypeORMQueryLimit, TypeORMOperator, TypeORMGroupOperator, TypeORMConst, translateOperators.\n- Types: SQLOperator, TypeORMQuery, TypeORMFlags, TypeORMTableSpec.\n- Constants: reservedAttributes, TypeORMKeys, TypeORMFlavour.\n- Utils: convertJsRegexToPostgres.\n- Raw typing: FieldDef, QueryResultBase, QueryResult, QueryArrayResult.\n",
    "summary": "Decaf.ts for TypeORM — Detailed Description Decaf.ts for TypeORM provides a complete implementation of Decaf.ts' data access abstractions backed by a TypeORM DataSource.",
    "examples": [
      {
        "lang": "ts",
        "code": "import { TypeORMAdapter, TypeORMFlavour } from \"@decaf-ts/for-typeorm\";\nimport { DataSource, DataSourceOptions } from \"typeorm\";\n\n// Admin connection (used to create db/user)\nconst adminOptions: DataSourceOptions = {\n  type: \"postgres\",\n  host: \"localhost\",\n  port: 5432,\n  username: \"postgres\",\n  password: \"password\",\n  database: \"postgres\",\n};\n\n// App database name and user\nconst dbName = \"app_db\";\nconst appUser = \"app_user\";\nconst appPass = \"password\";\n\n// 1) Connect as admin and prepare database and user\nconst admin = await TypeORMAdapter.connect(adminOptions);\ntry {\n  await TypeORMAdapter.createDatabase(admin, dbName);\n  await TypeORMAdapter.createUser(admin, dbName, appUser, appPass);\n  await TypeORMAdapter.createNotifyFunction(admin, appUser);\n} finally {\n  await admin.destroy();\n}\n\n// 2) Application DataSource and adapter\nconst appOptions: DataSourceOptions = {\n  type: \"postgres\",\n  host: \"localhost\",\n  port: 5432,\n  username: appUser,\n  password: appPass,\n  database: dbName,\n  synchronize: true,\n  logging: false,\n};\n\nconst adapter = new TypeORMAdapter(appOptions);\n// Optionally inject an existing DataSource instance\nadapter[\"_dataSource\"] = new DataSource(appOptions);\n",
        "context": "Setup the adapter and DataSource",
        "source": "howto",
        "title": "Configure and Initialize",
        "details": "Setup the adapter and DataSource — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { model, ModelArg } from \"@decaf-ts/decorator-validation\";\nimport {\n  table,\n  pk,\n  column,\n  required,\n  oneToOne,\n  oneToMany,\n  manyToOne,\n  manyToMany,\n  Repository,\n  uses,\n} from \"@decaf-ts/core\";\nimport { TypeORMFlavour, TypeORMRepository } from \"@decaf-ts/for-typeorm\";\nimport { Cascade } from \"@decaf-ts/db-decorators\";\n\n/**\n * User ↔ Profile: one-to-one\n * User → Post: one-to-many\n * Post → User: many-to-one\n * Post ↔ Tag: many-to-many\n */\n\n@uses(TypeORMFlavour)\n@table(\"app_user\")\n@model()\nclass AppUser extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column(\"name\")\n  @minlength(3)\n  @maxlength(255)\n  @index()\n  name!: string;\n\n  @required()\n  @column(\"email\")\n  @email()\n  @index()\n  email!: string;\n\n  @column(\"is_active\")\n  isActive: boolean = true;\n\n  @column(\"created_at\")\n  @createdAt()\n  createdAt: Date;\n\n  // oneToOne: each user has exactly one profile\n  @oneToOne(\n    () => UserProfile,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.SET_NULL,\n    },\n    true // populate\n  )\n  @required()\n  profile!: UserProfile;\n\n  // oneToMany: user has many posts (inverse in Post.author as manyToOne)\n  @oneToMany(\n    () => Post,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.CASCADE,\n    },\n    true // populate\n  )\n  posts?: Post[];\n\n  constructor(arg?: ModelArg<AppUser>) {\n    super(arg);\n  }\n}\n\n@uses(TypeORMFlavour)\n@table(\"user_profile\")\n@model()\nclass UserProfile extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @column(\"bio\")\n  bio?: string;\n\n  @column(\"age\")\n  @min(0)\n  @max(150)\n  @step(1)\n  @required()\n  age!: number;\n  \n  @column(\"avatar_url\")\n  @url()\n  avatarUrl?: string;\n\n  @column(\"phone\")\n  @index()\n  phone?: string;\n  \n  @column(\"created_at\")\n  @createdAt()\n  updatedAt: Date;\n  \n  @column(\"updated_at\")\n  @updatedAt()\n  updatedAt: Date;\n\n  // Optional back-reference to the user (many projects omit the reverse one-to-one)\n  @oneToOne(\n    () => AppUser,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.CASCADE,\n    },\n    true\n  )\n  @required()\n  user!: AppUser;\n\n  constructor(arg?: ModelArg<UserProfile>) {\n    super(arg)\n  }\n}\n\n@uses(TypeORMFlavour)\n@table(\"post\")\n@model()\nclass Post extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column(\"title\")\n  @index()\n  title!: string;\n\n  @required()\n  @column(\"body\")\n  body!: string;\n\n  @column(\"published_at\")\n  publishedAt?: Date;\n\n  @column(\"is_published\")\n  isPublished: boolean = false;\n\n  // manyToOne: each post belongs to a single user (inverse of AppUser.posts)\n  @manyToOne(\n    () => AppUser,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.SET_NULL,\n    },\n    false // only one side of the relation can be eager\n  )\n  author!: AppUser;\n\n  // manyToMany: posts can have many tags and tags can belong to many posts\n  @manyToMany(\n    () => Tag,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.NONE,\n    },\n    true // populate\n  )\n  tags?: Tag[];\n\n  constructor(arg?: ModelArg<Post>) {\n    super(arg)\n  }\n}\n\n@uses(TypeORMFlavour)\n@table()\n@model()\nclass Tag extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column()\n  @index()\n  name!: string;\n\n  @column()\n  color?: string;\n\n  // Optional reverse manyToMany side\n  @manyToMany(\n    () => Post,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.NONE,\n    },\n    true\n  )\n  posts?: Post[];\n\n  constructor(arg?: ModelArg<Tag>) {\n    super(arg)\n  }\n}\n\n// Example: create a user with profile, posts and tags in one go\nconst userRepo: TypeORMRepository<AppUser> = Repository.forModel(AppUser);\nconst tagRepo: TypeORMRepository<Tag> = Repository.forModel(Tag);\n\nconst t1 = await tagRepo.create(new Tag({ name: \"typescript\", color: \"#3178C6\" }));\nconst t2 = await tagRepo.create(new Tag({ name: \"orm\" }));\n\nconst createdUser = await userRepo.create(\n  new AppUser({\n    name: \"Alice\",\n    email: \"alice@example.com\",\n    profile: { \n      bio: \"Full-stack dev\", \n      phone: \"+1-555-1234\" \n    },\n    posts: [\n      {\n        title: \"Hello World\",\n        body: \"My first post\",\n        isPublished: true,\n        tags: [t1, t2],\n      },\n      {\n        title: \"TypeORM Tips\",\n        body: \"Relations and cascading\",\n        tags: [t1],\n      },\n    ],\n  })\n);\n\n// Read back with relations populated (populate=true in decorators)\nconst fetched = await userRepo.read(createdUser.id);\n",
        "context": "Use Decaf decorators @model, @table, @pk, @column, etc.. They are wired to TypeORM automatically by this package.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Use Decaf decorators @model, @table, @pk, @column, etc.. They are wired to TypeORM automatically by this package."
      },
      {
        "lang": "ts",
        "code": "import { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { Observer } from \"@decaf-ts/core\";\n\n// Observe changes\nconst mock = jest.fn(); // or any function\nconst observer: Observer = { refresh: (...args) => Promise.resolve(mock(...args)) };\nrepo.observe(observer);\n\n// Create\nconst created = await repo.create(new User({ name: \"Alice\", nif: \"123456789\" }));\n// Read\nconst fetched = await repo.read(created.id);\n// Update\ncreated.name = \"Alice Doe\";\nconst updated = await repo.update(created);\n// Delete\nawait repo.delete(updated.id);\n\n// Bulk operations\nconst many = [\n  new User({ name: \"u1\", nif: \"111111111\" }),\n  new User({ name: \"u2\", nif: \"222222222\" }),\n];\nconst createdAll = await repo.createAll(many);\nconst readAll = await repo.readAll(createdAll.map(u => u.id));\nconst updatedAll = await repo.updateAll(readAll.map(u => ({ ...u, name: u.name + \"!\" }) as User));\nawait repo.deleteAll(updatedAll.map(u => u.id));\n",
        "context": "Repository CRUD operations",
        "source": "howto",
        "title": "Database Access",
        "details": "Repository CRUD operations — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { TypeORMRepository } from \"@decaf-ts/for-typeorm\"\n// Access the underlying TypeORM Repository\nconst repo: TypeORMRepository = Repository.forModel(User);\nconst nativeRepo = repo.nativeRepository();\n\n// Or build a TypeORM query using queryBuilder()\nconst qb = repo.queryBuilder<User>(); // returns a QueryBuilder<User>\nconst rows = await qb.select(\"user\").where({ name: \"Alice\" }).getMany();\n",
        "context": "Native TypeORM repository and QueryBuilder access",
        "source": "howto",
        "title": "Database Access",
        "details": "Native TypeORM repository and QueryBuilder access"
      },
      {
        "lang": "ts",
        "code": "import { Operator, Condition, Repository } from \"@decaf-ts/core\";\nconst repo: TypeORMRepository = Repository.forModel(User);\n\n// Build a Decaf statement and paginate\nconst stmt = repo\n  .select()\n  .where(Condition.attr<User>(\"name\").eq(\"Alice\"))\n  .orderBy(\"id\")\n  .paginate(10); // TypeORMPaginator under the hood\n\nconst page1 = await stmt.page(1); // User[]\n",
        "context": "Decaf Statement with pagination",
        "source": "howto",
        "title": "Decaf Statement With Pagination",
        "details": "Decaf Statement with pagination — Asynchronous usage with async/await."
      },
      {
        "lang": "ts",
        "code": "import { TypeORMDispatch, TypeORMAdapter } from \"@decaf-ts/for-typeorm\";\nimport { Repository, Observer } from \"@decaf-ts/core\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { DataSourceOptions } from \"typeorm\";\n\n// Assume you already created the DB and user\nconst options: DataSourceOptions = { /* postgres options */ } as any;\nconst adapter = new TypeORMAdapter(options);\n\n// Observe repository changes\nconst repo = Repository.forModel(User);\nconst spy = jest.fn();\nconst observer: Observer = { refresh: (t, op, ids) => Promise.resolve(spy(t, op, ids)) };\nrepo.observe(observer);\n\n// Start dispatch\nconst dispatch = new TypeORMDispatch();\nawait dispatch.observe(adapter, options);\n\n// After create/update/delete through the repo, your observer will be notified\nawait repo.create(new User({ name: \"Bob\", nif: \"999999990\" }));\nexpect(spy).toHaveBeenCalledWith(repo.table, OperationKeys.CREATE, expect.any(Array));\n",
        "context": "Description: Subscribe to TypeORM entity events and notify Decaf observers on CREATE/UPDATE/DELETE. Based on tests/integration/dispatch-subscriber.test.ts.",
        "source": "howto",
        "title": "Description Subscribe To Typeorm Entity Events",
        "details": "Description: Subscribe to TypeORM entity events and notify Decaf observers on CREATE/UPDATE/DELETE. Based on tests/integration/dispatch-subscriber.test.ts."
      },
      {
        "lang": "ts",
        "code": "import { TypeORMEventSubscriber } from \"@decaf-ts/for-typeorm\";\nimport { DataSource, DataSourceOptions } from \"typeorm\";\n\nconst options: DataSourceOptions = { /* postgres options */ } as any;\nconst ds = new DataSource({ ...options, subscribers: [new TypeORMEventSubscriber((table, op, ids) => {\n  console.log(\"Changed:\", table, op, ids);\n})] });\nawait ds.initialize();\n",
        "context": "Description: Register the subscriber in a DataSource to forward TypeORM events. Used implicitly by TypeORMDispatch; shown here for completeness.",
        "source": "howto",
        "title": "Description Register The Subscriber In A",
        "details": "Description: Register the subscriber in a DataSource to forward TypeORM events. Used implicitly by TypeORMDispatch; shown here for completeness."
      },
      {
        "lang": "ts",
        "code": "import { translateOperators } from \"@decaf-ts/for-typeorm\";\nimport { Operator, GroupOperator } from \"@decaf-ts/core\";\n\nconst eq = translateOperators(Operator.EQUAL);      // \"=\"\nconst ne = translateOperators(Operator.DIFFERENT);  // \"<>\"\nconst and = translateOperators(GroupOperator.AND);  // \"AND\"\n",
        "context": "Description: Translate Decaf operators to TypeORM SQL operators; useful when building custom WHERE clauses. Based on src/query/translate.ts and query/constants.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Translate Decaf operators to TypeORM SQL operators; useful when building custom WHERE clauses. Based on src/query/translate.ts and query/constants."
      },
      {
        "lang": "ts",
        "code": "import { convertJsRegexToPostgres } from \"@decaf-ts/for-typeorm\";\n\nconvertJsRegexToPostgres(/foo.*/i); // \"foo.*\"\nconvertJsRegexToPostgres(\"/bar.+/g\"); // \"bar.+\"\n",
        "context": "Description: Convert a JS RegExp or string form to a PostgreSQL POSIX pattern string for use with  / .",
        "source": "howto",
        "title": "Description Convert A Js Regexp Or",
        "details": "Description: Convert a JS RegExp or string form to a PostgreSQL POSIX pattern string for use with  / ."
      },
      {
        "lang": "ts",
        "code": "import { splitEagerRelations } from \"@decaf-ts/for-typeorm\";\n\nconst { relations, nonEager } = splitEagerRelations(User);\n// relations might include [\"posts\", \"profile\", \"posts.tags\"] depending on your decorators\n",
        "context": "Description: Compute eager vs. non-eager relations for a Model class based on relation decorators. Mirrors behavior used by the adapter and statement builder.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Compute eager vs. non-eager relations for a Model class based on relation decorators. Mirrors behavior used by the adapter and statement builder."
      },
      {
        "lang": "ts",
        "code": "import { TypeORMSequence } from \"@decaf-ts/for-typeorm\";\n\nconst seq = new TypeORMSequence({ name: \"user_id_seq\", type: \"Number\", startWith: 1, incrementBy: 1 }, adapter);\nconst nextValue = await seq.next();\nconst batch = await seq.range(5); // e.g., [2,3,4,5,6]\n",
        "context": "Description: Work with PostgreSQL sequences through the adapter. Based on tests/integration/sequences.test.ts.",
        "source": "howto",
        "title": "Description Work With Postgresql Sequences Through",
        "details": "Description: Work with PostgreSQL sequences through the adapter. Based on tests/integration/sequences.test.ts."
      },
      {
        "lang": "ts",
        "code": "import { generateIndexes, TypeORMAdapter } from \"@decaf-ts/for-typeorm\";\n\nconst stmts = generateIndexes([User, Post]); // returns TypeORMQuery[] with raw SQL and values\nfor (const st of stmts) {\n  await adapter.raw(st);\n}\n",
        "context": "Description: Generate SQL statements to create indexes defined via decorators. Use adapter.raw to execute them. Based on adapter.index and indexes/generator.",
        "source": "howto",
        "title": "Use Decorators",
        "details": "Description: Generate SQL statements to create indexes defined via decorators. Use adapter.raw to execute them. Based on adapter.index and indexes/generator."
      }
    ],
    "base_path": "for-typeorm"
  },
  {
    "name": "for-fabric",
    "title": "for-fabric",
    "description": "### Description\n\nThis module focuses on the chaincode (contracts) side of @decaf-ts/for-fabric. It adapts DECAF’s Repository/Model/Adapter abstractions to Hyperledger Fabric’s world state and execution context so you can implement smart contracts with familiar patterns and minimal boilerplate.\n\nKey ideas:\n- Keep your domain models as annotated classes (using @decaf-ts/decorator-validation).\n- Use a Repository to persist/read/query models through a Fabric-aware Adapter.\n- Compose reusable CRUD contracts and utilities instead of hand-writing stub calls.\n- Emit first-class Fabric events from repository operations.\n- Leverage context-aware logging and typed flags during execution.\n\nContracts building blocks identified in src/contracts:\n\n1) Core context and types\n- FabricContractContext: Extends the generic Context to expose Fabric-specific properties (stub, clientIdentity, logger) and timestamp resolution from the ledger.\n- FabricContractFlags: Interface extending RepositoryFlags with stub, clientIdentity and logger for contract calls.\n\n2) Logging\n- ContractLogger: MiniLogger-compatible logger bound to the Fabric contract Context. It honors log levels and forwards to the underlying Fabric logger.\n\n3) Adapter and repository\n- FabricContractAdapter: Chaincode-side Adapter that implements CRUD, bulk operations, raw Mango queries, result iteration, model preparation/reversion, composite-key prefixes, and sequence creation. Bridges DECAF abstractions to Fabric (ChaincodeStub, ClientIdentity) and CouchDB-style queries.\n- FabricContractRepository<M>: Repository for models inside chaincode. Supports create, update, createAll, updateAll, read/readAll, raw queries (Mango), select projections, prefix-based bulk ops, and event emission through an ObserverHandler.\n- FabricContractRepositoryObservableHandler: ObserverHandler that emits Fabric events via stub.setEvent using names generated by generateFabricEventName.\n\n4) Sequences\n- FabricContractDBSequence: Fabric-backed implementation of Sequence with current, next and range. Stores values in the world state via FabricContractRepository and supports Number or BigInt sequences with configurable startWith and incrementBy.\n\n5) CRUD contracts\n- FabricCrudContract<M>: Base smart contract exposing CRUD endpoints (create, read, update, delete, createAll, readAll, updateAll, deleteAll, raw, init, healthcheck) for a model type. Uses DeterministicSerializer and the FabricContractAdapter/Repository behind the scenes and provides logFor(ctx).\n- SerializedCrudContract<M>: Same endpoints as FabricCrudContract but takes/returns JSON strings (de)serialized to the model class. This simplifies client interactions and is used in tests.\n\n6) ERC20 sample\n- ERC20Token, ERC20Wallet, Allowance: Sample domain models for an ERC20-like token, wallets and allowances.\n- FabricStatement<M,R>: A CouchDBStatement bridge that runs Mango queries through FabricContractAdapter, handling primary key projection when needed.\n- FabricERC20Contract: A full ERC20 smart contract showcasing repository-based persistence and arithmetic helpers. Implements Initialize, CheckInitialized, TokenName, Symbol, Decimals, TotalSupply, BalanceOf, Transfer, TransferFrom, Approve, Allowance, Mint, Burn, BurnFrom, ClientAccountBalance, ClientAccountID and an internal _transfer helper.\n\nDesign notes:\n- Deterministic serialization is used to ensure stable bytes for world-state writes.\n- onCreate/onCreateUpdate hooks from db-decorators are leveraged by the adapter to set primary keys and creator/owner metadata.\n- Mango queries (CouchDB) are used for rich queries via getQueryResultWithPagination.\n- Event emission is opt-in per operation type through FabricContractRepositoryObservableHandler’s supportedEvents list.\n\nWith these components you can build robust chaincode while keeping code concise, testable, and aligned with DECAF’s architecture.\n",
    "summary": "Description This module focuses on the chaincode contracts side of @decaf-ts/for-fabric.",
    "examples": [
      {
        "lang": "bash",
        "code": "npm install @decaf-ts/for-fabric\n",
        "context": "Installation",
        "source": "howto",
        "title": "Installation",
        "details": "Installation"
      },
      {
        "lang": "typescript",
        "code": "import { FabricAdapter, PeerConfig } from '@decaf-ts/for-fabric';\n\n// Configure connection to a Fabric peer\nconst config: PeerConfig = {\n  mspId: 'Org1MSP',\n  peerEndpoint: 'localhost:7051',\n  channelName: 'mychannel',\n  chaincodeName: 'mycc',\n  contractName: 'mycontract',\n  tlsCertPath: '/path/to/tls/cert',\n  certDirectoryPath: '/path/to/cert/dir',\n  keyDirectoryPath: '/path/to/key/dir',\n  cryptoPath: '/path/to/crypto',\n  peerHostAlias: 'peer0.org1.example.com',\n  caEndpoint: 'localhost:7054',\n  caTlsCertificate: '/path/to/ca/tls/cert',\n  caCert: '/path/to/ca/cert',\n  caKey: '/path/to/ca/key',\n  ca: 'ca.org1.example.com'\n};\n\n// Create an adapter instance\nconst adapter = new FabricAdapter(config, 'org1-adapter');\n\n// Use the adapter to interact with the Fabric network\nasync function createAsset() {\n  const asset = { id: 'asset1', value: 'Asset 1 Value' };\n  return await adapter.create('assets', 'asset1', asset, {}, mySerializer);\n}\n\nasync function readAsset(id: string) {\n  return await adapter.read('assets', id, mySerializer);\n}\n\nasync function updateAsset(id: string, newValue: string) {\n  const asset = await readAsset(id);\n  asset.value = newValue;\n  return await adapter.update('assets', id, asset, {}, mySerializer);\n}\n\nasync function deleteAsset(id: string) {\n  return await adapter.delete('assets', id, mySerializer);\n}\n\nasync function queryAssets(owner: string) {\n  const query = {\n    selector: {\n      owner: owner\n    }\n  };\n  return await adapter.raw(query, true);\n}\n",
        "context": "Connecting to a Fabric Network",
        "source": "howto",
        "title": "Connecting To A Fabric Network",
        "details": "Connecting to a Fabric Network — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { FabricAdapter, FabricDispatch } from '@decaf-ts/for-fabric';\n\nasync function setupEventListener(config: PeerConfig) {\n  // Create a client\n  const client = await FabricAdapter.getClient(config);\n\n  // Create a dispatch instance\n  const dispatch = new FabricDispatch(client);\n\n  // Configure the dispatch with peer configuration\n  dispatch.configure(config);\n\n  // Register an observer for a specific table and event\n  dispatch.observe('assets', 'create', (id) => {\n    console.log(`Asset created: ${id}`);\n    // Fetch the new asset or update UI\n  });\n\n  // Start listening for events\n  await dispatch.start();\n\n  // When done, close the connection\n  // await dispatch.close();\n}\n",
        "context": "Listening for Chaincode Events",
        "source": "howto",
        "title": "Listening For Chaincode Events",
        "details": "Listening for Chaincode Events — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { \n  getIdentity, \n  getSigner, \n  readFile, \n  getCAUser \n} from '@decaf-ts/for-fabric';\n\nasync function setupIdentity() {\n  // Read a certificate file\n  const tlsCert = await readFile('/path/to/tls/cert');\n\n  // Get an identity from a certificate directory\n  const identity = await getIdentity('Org1MSP', '/path/to/cert/dir');\n\n  // Get a signer from a key directory\n  const signer = await getSigner('/path/to/key/dir');\n\n  // Create a CA user\n  const user = await getCAUser(\n    'user1', \n    privateKeyPem, \n    certificatePem, \n    'Org1MSP'\n  );\n\n  return { identity, signer, user };\n}\n",
        "context": "Working with Identities and Certificates",
        "source": "howto",
        "title": "Working With Identities And Certificates",
        "details": "Working with Identities and Certificates"
      },
      {
        "lang": "typescript",
        "code": "import { Model, id, property, table } from '@decaf-ts/decorator-validation';\n\n@table('assets')\nexport class Asset extends Model {\n  @id()\n  id: string;\n\n  @property()\n  value: string;\n\n  @property()\n  owner: string;\n\n  @property()\n  createdAt: number;\n}\n",
        "context": "Creating a Model",
        "source": "howto",
        "title": "Creating A Model",
        "details": "Creating a Model"
      },
      {
        "lang": "typescript",
        "code": "import { FabricCrudContract } from '@decaf-ts/for-fabric';\nimport { Context, Contract, Info, Transaction } from 'fabric-contract-api';\nimport { Asset } from './asset';\n\n@Info({ title: 'AssetContract', description: 'Smart contract for trading assets' })\nexport class AssetContract extends FabricCrudContract<Asset> {\n  constructor() {\n    super('AssetContract', Asset);\n  }\n\n  // The base class already provides standard CRUD operations:\n  // create, read, update, delete, createAll, readAll, updateAll, deleteAll\n\n  // Add custom methods as needed\n  @Transaction()\n  async getAssetHistory(ctx: Context, id: string): Promise<any[]> {\n    const stub = ctx.stub;\n    const iterator = await stub.getHistoryForKey(id);\n\n    const results = [];\n    let result = await iterator.next();\n\n    while (!result.done) {\n      const value = result.value;\n      results.push({\n        txId: value.txId,\n        timestamp: value.timestamp,\n        value: JSON.parse(value.value.toString('utf8'))\n      });\n\n      result = await iterator.next();\n    }\n\n    await iterator.close();\n    return results;\n  }\n\n  @Transaction()\n  async transferAsset(ctx: Context, id: string, newOwner: string): Promise<Asset> {\n    const asset = await this.read(ctx, id);\n    asset.owner = newOwner;\n    return await this.update(ctx, asset);\n  }\n}\n",
        "context": "Creating a CRUD Contract",
        "source": "howto",
        "title": "Creating A Crud Contract",
        "details": "Creating a CRUD Contract — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { FabricContractAdapter } from '@decaf-ts/for-fabric';\nimport { Context, Contract, Transaction } from 'fabric-contract-api';\n\nexport class CustomContract extends Contract {\n  private adapter: FabricContractAdapter;\n\n  constructor() {\n    super('CustomContract');\n    this.adapter = new FabricContractAdapter();\n  }\n\n  @Transaction()\n  async createRecord(ctx: Context, id: string, data: string): Promise<any> {\n    const record = { id, data, timestamp: Date.now() };\n    return await this.adapter.create(\n      'records',\n      id,\n      record,\n      {},\n      { stub: ctx.stub, logger: ctx.logging }\n    );\n  }\n\n  @Transaction(false)\n  async queryRecords(ctx: Context, owner: string): Promise<any[]> {\n    const query = {\n      selector: {\n        owner: owner\n      }\n    };\n\n    return await this.adapter.raw(\n      query,\n      true,\n      { stub: ctx.stub, logger: ctx.logging }\n    );\n  }\n}\n",
        "context": "Using the Contract Adapter Directly",
        "source": "howto",
        "title": "Using The Contract Adapter Directly",
        "details": "Using the Contract Adapter Directly — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { \n  FabricContractRepositoryObservableHandler,\n  generateFabricEventName,\n  parseEventName\n} from '@decaf-ts/for-fabric';\nimport { Context } from 'fabric-contract-api';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\n\n// In chaincode: Emit an event\nasync function emitEvent(ctx: Context, tableName: string, id: string) {\n  const handler = new FabricContractRepositoryObservableHandler();\n  const logger = ctx.logging.getLogger('EventHandler');\n\n  await handler.updateObservers(\n    logger,\n    tableName,\n    OperationKeys.CREATE,\n    id,\n    { stub: ctx.stub }\n  );\n}\n\n// In client: Parse an event name\nfunction handleEvent(eventName: string, payload: Buffer) {\n  const { table, event, owner } = parseEventName(eventName);\n  const data = JSON.parse(payload.toString());\n\n  console.log(`Received ${event} event for ${table} with ID ${data.id}`);\n  if (owner) {\n    console.log(`Event owner: ${owner}`);\n  }\n}\n",
        "context": "Emitting and Handling Events",
        "source": "howto",
        "title": "Emitting And Handling Events",
        "details": "Emitting and Handling Events — Asynchronous usage with async/await."
      },
      {
        "lang": "typescript",
        "code": "import { Context, Transaction, Contract } from 'fabric-contract-api';\nimport { model, ModelArg, required } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { FabricCrudContract } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass Person extends BaseModel {\n  @pk({ type: 'Number' })\n  id!: number;\n  @required() name!: string;\n  constructor(arg?: ModelArg<Person>) { super(arg); }\n}\n\nexport class PersonContract extends FabricCrudContract<Person> {\n  constructor() {\n    super('PersonContract', Person);\n  }\n\n  @Transaction(false)\n  async ping(ctx: Context): Promise<string> {\n    // Uses FabricCrudContract.logFor\n    this.logFor(ctx).info('ping');\n    return 'pong';\n  }\n}\n",
        "context": "Description: Base contract exposing CRUD endpoints for a model class. It uses Repository and DeterministicSerializer under the hood.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Base contract exposing CRUD endpoints for a model class. It uses Repository and DeterministicSerializer under the hood."
      },
      {
        "lang": "typescript",
        "code": "import { Context } from 'fabric-contract-api';\nimport { model, ModelArg, required } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { SerializedCrudContract } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass TestModel extends BaseModel {\n  @pk({ type: 'Number' }) id!: number;\n  @required() name!: string;\n  @required() nif!: string;\n  constructor(arg?: ModelArg<TestModel>) { super(arg); }\n}\n\nexport class TestModelContract extends SerializedCrudContract<TestModel> {\n  constructor() {\n    super('TestModelContract', TestModel);\n  }\n}\n\n// Example invocation (mirrors unit test usage)\nasync function createExample(contract: TestModelContract, ctx: Context) {\n  const payload = new TestModel({ name: 'Alice', nif: '123456789' }).serialize();\n  const resultJson = await contract.create(ctx, payload);\n  const created = new TestModel(JSON.parse(resultJson));\n  return created;\n}\n",
        "context": "Description: Same endpoints as FabricCrudContract but takes and returns JSON strings. Useful for simple clients. Based on tests/unit/contracts.test.ts.",
        "source": "howto",
        "title": "Description Same Endpoints As Fabriccrudcontract But",
        "details": "Description: Same endpoints as FabricCrudContract but takes and returns JSON strings. Useful for simple clients. Based on tests/unit/contracts.test.ts."
      },
      {
        "lang": "typescript",
        "code": "import { Context } from 'fabric-contract-api';\nimport { Repo } from '@decaf-ts/core';\nimport { model, required, ModelArg } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { FabricContractRepository } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass Asset extends BaseModel {\n  @pk() id!: string;\n  @required() owner!: string;\n  constructor(arg?: ModelArg<Asset>) { super(arg); }\n}\n\nexport class AssetContract extends Contract {\n  private repo: Repo<Asset, any, any, any, any>;\n  constructor() {\n    super('AssetContract');\n    this.repo = new FabricContractRepository<Asset>(new (require('@decaf-ts/for-fabric').contracts.FabricContractAdapter)(), Asset);\n  }\n\n  @Transaction()\n  async Create(ctx: Context, id: string, owner: string): Promise<void> {\n    const m = new Asset({ id, owner });\n    await this.repo.create(m, ctx as any);\n  }\n\n  @Transaction(false)\n  async Read(ctx: Context, id: string): Promise<Asset> {\n    return this.repo.read(id, ctx as any);\n  }\n\n  @Transaction(false)\n  async QueryByOwner(ctx: Context, owner: string): Promise<Asset[]> {\n    return this.repo.raw({ selector: { owner } } as any, true, ctx as any);\n  }\n}\n",
        "context": "Description: Chaincode-side repository used inside contract methods to persist and query models.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Chaincode-side repository used inside contract methods to persist and query models."
      },
      {
        "lang": "typescript",
        "code": "import { Context } from 'fabric-contract-api';\nimport { FabricContractDBSequence } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractAdapter } from '@decaf-ts/for-fabric/contracts';\n\nconst adapter = new FabricContractAdapter();\n\nexport class OrderContract extends Contract {\n  private orderSeq = new FabricContractDBSequence({\n    name: 'orderSeq',\n    type: 'Number',\n    startWith: 1,\n    incrementBy: 1,\n  }, adapter);\n\n  @Transaction()\n  async CreateOrder(ctx: Context): Promise<number> {\n    const next = await this.orderSeq.next(ctx as any);\n    // use next as order id\n    return next as number;\n  }\n\n  @Transaction(false)\n  async NextRange(ctx: Context, count: number): Promise<number[]> {\n    return (await this.orderSeq.range(count, ctx as any)) as number[];\n  }\n}\n",
        "context": "Description: World-state backed sequences for generating incremental values.",
        "source": "howto",
        "title": "Description World State Backed Sequences For",
        "details": "Description: World-state backed sequences for generating incremental values."
      },
      {
        "lang": "typescript",
        "code": "import { FabricStatement } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractAdapter } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\nimport { MangoQuery } from '@decaf-ts/for-couchdb';\nimport { Model } from '@decaf-ts/decorator-validation';\n\nclass MyModel extends Model {}\n\nconst adapter = new FabricContractAdapter();\n\nasync function query(ctx: FabricContractContext) {\n  const stmt = new FabricStatement<MyModel, MyModel[]>(adapter, ctx);\n  const models = await stmt.raw<MyModel[]>({ selector: { type: 'MyModel' } } as MangoQuery);\n  return models;\n}\n",
        "context": "Description: Bridge to run Mango queries through the Fabric adapter and get typed models back; used internally by repositories and also directly in advanced cases. See tests/unit/erc20conttract.test.ts mocking CouchDBStatement processing.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Bridge to run Mango queries through the Fabric adapter and get typed models back; used internally by repositories and also directly in advanced cases. See tests/unit/erc20conttract.test.ts mocking CouchDBStatement processing."
      },
      {
        "lang": "typescript",
        "code": "import { Context, Transaction } from 'fabric-contract-api';\nimport { Contract } from 'fabric-contract-api';\nimport { ContractLogger } from '@decaf-ts/for-fabric/contracts';\n\nexport class LoggableContract extends Contract {\n  @Transaction()\n  async DoWork(ctx: Context): Promise<void> {\n    const log = new ContractLogger('LoggableContract', { level: 'info' }, ctx as any);\n    log.info('Starting work');\n    // ... work ...\n    log.debug('Finished');\n  }\n}\n",
        "context": "Description: Context-aware logger bound to Fabric’s Context, honoring log levels.",
        "source": "howto",
        "title": "Structured Logging",
        "details": "Description: Context-aware logger bound to Fabric’s Context, honoring log levels."
      },
      {
        "lang": "typescript",
        "code": "import { FabricContractRepositoryObservableHandler } from '@decaf-ts/for-fabric/contracts';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\nimport { MiniLogger } from '@decaf-ts/logging';\n\nasync function emitExample(ctx: FabricContractContext) {\n  const handler = new FabricContractRepositoryObservableHandler();\n  const log = new MiniLogger('obs');\n  await handler.updateObservers(log as any, 'assets', OperationKeys.CREATE, 'asset1', ctx);\n}\n",
        "context": "Description: Emits Fabric events for repository operations. You can also use it directly to emit a custom event.",
        "source": "howto",
        "title": "Database Access",
        "details": "Description: Emits Fabric events for repository operations. You can also use it directly to emit a custom event."
      },
      {
        "lang": "typescript",
        "code": "import { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\n\nfunction readContext(ctx: FabricContractContext) {\n  const ts = ctx.timestamp; // Date from stub.getDateTimestamp()\n  const id = ctx.identity.getID();\n  ctx.logger.info(`Tx by ${id} at ${ts.toISOString()}`);\n}\n",
        "context": "Description: Access Fabric-specific context inside contracts.",
        "source": "howto",
        "title": "Description Access Fabric Specific Context Inside",
        "details": "Description: Access Fabric-specific context inside contracts."
      },
      {
        "lang": "typescript",
        "code": "import { FabricERC20Contract } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\n\nconst contract = new FabricERC20Contract('TestToken');\n\nasync function initAndRead(ctx: FabricContractContext) {\n  const created = await contract.Initialize(ctx, 'TestToken', 'TT', 18);\n  if (created) {\n    const name = await contract.TokenName(ctx);\n    const decimals = await contract.Decimals(ctx);\n    return { name, decimals };\n  }\n  throw new Error('Init failed');\n}\n",
        "context": "Description: Full ERC20 implementation used in tests see tests/unit/erc20conttract.test.ts.",
        "source": "howto",
        "title": "Description Full Erc20 Implementation Used In",
        "details": "Description: Full ERC20 implementation used in tests see tests/unit/erc20conttract.test.ts."
      }
    ],
    "base_path": "for-fabric"
  },
  {
    "name": "for-nest",
    "title": "for-nest",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "summary": "Description No one needs the hassle of setting up new repos every time. Now you can create new repositories from this template and enjoy having everything set up for you.",
    "examples": [],
    "base_path": "for-nest"
  },
  {
    "name": "styles",
    "title": "styles",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "summary": "Description No one needs the hassle of setting up new repos every time. Now you can create new repositories from this template and enjoy having everything set up for you.",
    "examples": [],
    "base_path": "styles"
  },
  {
    "name": "for-angular",
    "title": "for-angular",
    "description": "### Description\n\nA very versatile persistence layer. from smart contracts, Digital wallets or just regular database access\n\n",
    "summary": "Description A very versatile persistence layer. from smart contracts, Digital wallets or just regular database access",
    "examples": [],
    "base_path": "for-angular"
  },
  {
    "name": "mcp-server",
    "title": "mcp-server",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "summary": "Description No one needs the hassle of setting up new repos every time. Now you can create new repositories from this template and enjoy having everything set up for you.",
    "examples": [],
    "base_path": "mcp-server"
  },
  {
    "name": "for-react-native",
    "title": "for-react-native",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "summary": "Description No one needs the hassle of setting up new repos every time. Now you can create new repositories from this template and enjoy having everything set up for you.",
    "examples": [],
    "base_path": "for-react-native"
  },
  {
    "name": "demo",
    "title": "demo",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "summary": "Description No one needs the hassle of setting up new repos every time. Now you can create new repositories from this template and enjoy having everything set up for you.",
    "examples": [],
    "base_path": "demo"
  }
]