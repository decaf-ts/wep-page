[
  {
    "name": "decoration",
    "title": "decoration",
    "description": "# Description\n\n@decaf-ts/decoration provides two complementary capabilities:\n\n- A small, builder-style API (Decoration) to define and apply decorators that can vary by \"flavour\" (for example, different frameworks or environments) while keeping a stable key-based API.\n- A centralized runtime Metadata store (Metadata) for reading and writing structured information about classes and their members, using reflect-metadata for design-time type hints.\n\nThis module aims to standardize how decorators are composed, discovered, and executed across contexts, and how metadata is stored and queried during runtime.\n\nMain building blocks\n\n- Decoration (builder and registry)\n  - You create a decoration pipeline for a key (for(\"component\"), for example).\n  - For the default flavour (\"decaf\"), you define the base decorators with define(...).\n  - For other flavours (e.g., \"vue\", \"nest\"), you can either override the base decorators (define for that flavour) or extend them with extras (extend(...)).\n  - At runtime, a global flavour resolver (setFlavourResolver) decides which flavour to apply to a given target. If that flavour has overrides, they are used; otherwise, the default base decorators are applied. Any flavour-specific extras and default extras are appended.\n  - The result of apply() is a decorator function whose name encodes the flavour and key to aid debugging.\n\n- Decorator utilities\n  - metadata(key, value): writes arbitrary metadata on a class or member.\n  - prop(): captures the Reflect design:type for a property and records it in Metadata under properties.<prop>.\n  - apply(...decorators): composes multiple decorators of different kinds and applies them in sequence.\n  - propMetadata(key, value): convenience factory that performs both metadata(key, value) and prop().\n  - description(text): stores a human-friendly description for a class or property under description.class or description.<prop>.\n\n- Metadata store\n  - Static convenience API backed by a singleton instance. It maps each class constructor to a structured metadata object.\n  - Keys are nested (e.g., \"properties.name\", \"description.class\") and navigated using a splitter (default \".\").\n  - When mirroring is enabled (default), the internal metadata object is also defined on the constructor under a stable, non-enumerable key (DecorationKeys.REFLECT) for quick inspection.\n  - Helper methods:\n    - properties(ctor): list known property names that have recorded type info.\n    - description(ctor, prop?): read description for class or a property.\n    - type(ctor, prop): read the recorded design type for a property.\n    - get/set(ctor, key): low-level access to arbitrary paths.\n\nConstants and types\n\n- DefaultFlavour: the default flavour identifier (\"decaf\").\n- ObjectKeySplitter: delimiter for nested metadata keys (\".\").\n- DecorationKeys: well-known metadata keys (REFLECT, PROPERTIES, CLASS, DESCRIPTION, design:type, etc.).\n- DefaultMetadata: the default metadata shape used as a base.\n- BasicMetadata / Constructor: utility types that describe metadata structure and a class constructor signature.\n\nDesign highlights\n\n- Composable and flavour-aware: The Decoration builder allows different environments or frameworks to contribute distinct decorator behavior under the same semantic key. This is useful when building adapters (e.g., Angular vs React components) without changing user code imports.\n- Predictable application order: Default decorators are applied first (or a flavour-specific override is used), followed by extras. Extras can come from the default flavour and/or the resolved flavour.\n- Introspectable metadata: The Metadata store makes it straightforward to record and query runtime facts about models, properties, and behavior. This is especially helpful for ORMs, serializers, validators, and UI bindings.\n",
    "examples": [
      "  {\n    \"compilerOptions\": {\n      \"experimentalDecorators\": true,\n      \"emitDecoratorMetadata\": true\n    }\n  }\n  ",
      "  import \"reflect-metadata\";\n  ",
      "import { Decoration } from \"@decaf-ts/decoration\";\n\nconst markAsComponent: ClassDecorator = (target) => {\n  (target as any).__isComponent = true;\n};\n\nconst tagFactory = (tag: string): ClassDecorator => (target) => {\n  (target as any).__tag = tag;\n};\n\nconst component = () =>\n  Decoration.for(\"component\")\n    .define({ decorator: tagFactory, args: [\"base\"] }, markAsComponent)\n    .apply();\n\n@component()\nclass DefaultComponent {}\n\n(DefaultComponent as any).__isComponent; // true\n(DefaultComponent as any).__tag; // \"base\"\n",
      "// Register the same base behaviour as above.\nconst baseComponent = () =>\n  Decoration.for(\"component\")\n    .define(((target: any) => target) as ClassDecorator)\n    .apply();\n\n@baseComponent()\nclass BaseComponent {}\n\nDecoration.setFlavourResolver(() => \"web\");\n\nconst decorate = () =>\n  Decoration.flavouredAs(\"web\")\n    .for(\"component\")\n    .extend({\n      decorator: (platform: string): ClassDecorator => (target) => {\n        (target as any).__platform = platform;\n      },\n      args: [\"web\"],\n    })\n    .apply();\n\n@decorate()\nclass WebComponent {}\n\n(WebComponent as any).__platform; // \"web\"\n",
      "const base = () =>\n  Decoration.for(\"component\")\n    .define(((target: any) => {\n      (target as any).__base = true;\n    }) as ClassDecorator)\n    .apply();\n\n@base()\nclass BaseBehaviour {}\n\nDecoration.setFlavourResolver(() => \"mobile\");\n\nconst mobileComponent = () =>\n  Decoration.flavouredAs(\"mobile\")\n    .for(\"component\")\n    .define(((target: any) => {\n      (target as any).__mobile = true;\n    }) as ClassDecorator)\n    .apply();\n\n@mobileComponent()\nclass MobileComponent {}\n\n(MobileComponent as any).__base; // undefined – overridden\n(MobileComponent as any).__mobile; // true\n",
      "const base = Decoration.for(\"guarded\");\n\n// Missing key before define/extend\nexpect(() => (new Decoration() as any).define(() => () => undefined)).toThrow();\n\n// Multiple overridable decorators are rejected\nconst overridable = {\n  decorator: (() => ((target: any) => target)) as any,\n  args: [],\n};\nexpect(() => base.define(overridable as any, overridable as any)).toThrow();\n\n// Extending the default flavour is blocked\nexpect(() => Decoration.for(\"guarded\").extend(((t: any) => t) as any)).toThrow();\n",
      "import { metadata, Metadata } from \"@decaf-ts/decoration\";\n\n@metadata(\"role\", \"entity\")\nclass User {}\n\nMetadata.get(User, \"role\"); // \"entity\"\n",
      "import { prop, Metadata } from \"@decaf-ts/decoration\";\n\nclass Article {\n  @prop()\n  title!: string;\n}\n\nMetadata.type(Article, \"title\") === String; // true\n",
      "import { apply } from \"@decaf-ts/decoration\";\n\nconst logClass: ClassDecorator = (target) => {\n  console.log(\"class\", (target as any).name);\n};\n\nconst withLogging = () => apply(logClass);\nconst logProperty = () => apply((_, key) => console.log(\"prop\", String(key)));\n\n@withLogging()\nclass Box {\n  @logProperty()\n  size!: number;\n}\n",
      "import { propMetadata, Metadata } from \"@decaf-ts/decoration\";\n\nclass Product {\n  @propMetadata(\"column\", \"price\")\n  price!: number;\n}\n\nMetadata.get(Product, \"column\"); // \"price\"\nMetadata.type(Product, \"price\") === Number; // true\n",
      "import { description, Metadata } from \"@decaf-ts/decoration\";\n\n@description(\"User entity\")\nclass User {\n  @description(\"Primary email address\")\n  email!: string;\n}\n\nMetadata.description(User); // \"User entity\"\nMetadata.description<User>(User, \"email\" as keyof User); // \"Primary email address\"\n",
      "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Person {\n  name!: string;\n}\n\nMetadata.set(Person, `${DecorationKeys.DESCRIPTION}.class`, \"Person model\");\nMetadata.set(Person, `${DecorationKeys.PROPERTIES}.name`, String);\n\nMetadata.description(Person); // \"Person model\"\nMetadata.properties(Person); // [\"name\"]\n\nconst mirror = Object.getOwnPropertyDescriptor(Person, DecorationKeys.REFLECT);\nmirror?.enumerable; // false\n",
      "(Metadata as any).mirror = false;\n\nMetadata.set(Person, `${DecorationKeys.DESCRIPTION}.class`, \"No mirror\");\nObject.getOwnPropertyDescriptor(Person, DecorationKeys.REFLECT); // undefined\n\n(Metadata as any).mirror = true; // reset when you are done\n",
      "class Service {\n  get(): string {\n    return \"value\";\n  }\n}\n\nMetadata.set(\n  Service,\n  `${DecorationKeys.METHODS}.get.${DecorationKeys.DESIGN_PARAMS}`,\n  []\n);\nMetadata.set(\n  Service,\n  `${DecorationKeys.METHODS}.get.${DecorationKeys.DESIGN_RETURN}`,\n  String\n);\n\nMetadata.methods(Service); // [\"get\"]\nMetadata.params(Service, \"get\"); // []\nMetadata.return(Service, \"get\") === String; // true\n",
      "Metadata.type(Person, \"name\"); // Reflects design type recorded by @prop()\nMetadata.get(Person); // Full metadata payload for advanced inspection\nMetadata.get(Person, DecorationKeys.CONSTRUCTOR); // Underlying constructor reference\n",
      "import { Metadata } from \"@decaf-ts/decoration\";\n\nMetadata.registerLibrary(\"@decaf-ts/decoration\", \"0.0.6\");\n\nexpect(() =>\n  Metadata.registerLibrary(\"@decaf-ts/decoration\", \"0.0.6\")\n).toThrow(/already/);\n",
      "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Org {}\n\nMetadata.set(Org, `${DecorationKeys.DESCRIPTION}.class`, \"Organization\");\nMetadata.set(Org, `${DecorationKeys.PROPERTIES}.name`, String);\n\nconsole.log(Metadata.get(Org, `${DecorationKeys.DESCRIPTION}.class`)); // \"Organization\"\nconsole.log(Metadata.type(Org, \"name\") === String); // true\n",
      "import { Metadata } from \"@decaf-ts/decoration\";\n\nclass File {\n  name!: string;\n  size!: number;\n}\n\nMetadata.set(File, \"properties.name\", String);\nMetadata.set(File, \"properties.size\", Number);\n\nconsole.log(Metadata.properties(File)); // [\"name\", \"size\"]\n",
      "import { Metadata, DecorationKeys } from \"@decaf-ts/decoration\";\n\nclass Temp {}\n;(Metadata as any).mirror = false; // disable\n\nMetadata.set(Temp, `${DecorationKeys.DESCRIPTION}.class`, \"Temporary\");\n\nconsole.log(Object.getOwnPropertyDescriptor(Temp, DecorationKeys.REFLECT)); // undefined\n// Re-enable when done\n;(Metadata as any).mirror = true;\n",
      "import { DefaultFlavour, ObjectKeySplitter, DecorationKeys } from \"@decaf-ts/decoration\";\n\nconsole.log(DefaultFlavour);     // \"decaf\"\nconsole.log(ObjectKeySplitter);  // \".\"\nconsole.log(DecorationKeys.PROPERTIES); // \"properties\"\n"
    ],
    "base_path": "decoration"
  },
  {
    "name": "logging",
    "title": "logging",
    "description": "# Logging Library — Detailed Description\n\nThe logging package is a lightweight, extensible logging solution for TypeScript projects. It centers on two main constructs:\n- MiniLogger — a minimal, context-aware logger used by default.\n- Logging — a static facade that manages global configuration, creates loggers for classes/functions/strings, and applies optional theming.\n\nIt also offers:\n- A concise set of decorators (log, debug, info, verbose, silly) to instrument methods with consistent logging and optional benchmarking.\n- Pluggable factories so that alternate implementations (e.g., WinstonLogger) can be used without changing call sites.\n- Strong typing for configuration and theming primitives.\n\nCore files and their roles\n- src/types.ts: Type definitions and contracts\n  - Logger: the runtime contract with methods silly, verbose, info, debug, error, for, setConfig.\n  - LoggingConfig: runtime configuration for filtering, formatting, and styling.\n  - LoggerFactory: factory signature returning a Logger for a given context and optional config.\n  - Theme/ThemeOption/ThemeOptionByLogLevel: shape of color and style configuration, optionally varying by LogLevel.\n  - Additional helpers: StringLike, AnyFunction, Class, LoggingContext.\n\n- src/constants.ts: Defaults and enums\n  - LogLevel: error | info | verbose | debug | silly (string values), plus NumericLogLevels for filtering.\n  - LoggingMode: RAW | JSON (current implementation focuses on RAW; JSON is available for adapters like Winston).\n  - DefaultTheme: sensible default colors/styles per component and per log level.\n  - DefaultLoggingConfig: default global configuration (info level, no styling, timestamp on, etc.).\n\n- src/logging.ts: Implementations and static facade\n  - MiniLogger: A small, dependency-light logger that:\n    - Generates formatted log strings (timestamp, log level, context, correlation id, message, stack) according to config.\n    - Supports child loggers via .for(method|config) with a Proxy to overlay per-child config and extend the context (class.method).\n    - Emits to console.log/console.debug/console.error based on level. Verbosity controls .silly output (gated by config.verbose).\n  - Logging: The static entry point that:\n    - Holds global configuration (Logging.getConfig(), Logging.setConfig()).\n    - Creates loggers for arbitrary contexts (Logging.for(object|class|function|string, config?)).\n    - Provides convenience static logging methods (info, debug, error, verbose, silly) delegating to a global logger instance.\n    - Supports theming (Logging.theme) by applying Theme options through styled-string-builder when style=true.\n    - Allows replacing the logger factory (Logging.setFactory) to integrate with other backends (e.g., Winston).\n\n- src/decorators.ts: Method decorators\n  - log(level=info, benchmark=false, verbosity=0): wraps a method to emit a call log and optionally a completion time; supports Promise-returning methods.\n  - debug/info/silly/verbose: concise wrappers around log() for common patterns.\n\n- src/LoggedClass.ts: Base convenience class\n  - LoggedClass exposes a protected this.log getter returning a context-aware Logger built via Logging.for(this), simplifying logging inside class methods.\n\n- src/winston/winston.ts: Optional Winston adapter\n  - WinstonLogger: extends MiniLogger but delegates emission to a configured Winston instance.\n  - WinstonFactory: a LoggerFactory you can install with Logging.setFactory(WinstonFactory) to globally route logs through Winston.\n\nDesign principles\n- Minimal by default: Console output with small surface area and no heavy dependencies (except styled-string-builder when style is enabled).\n- Config-driven: Behavior (level thresholds, verbosity, timestamps, separators, theming) is controlled via LoggingConfig.\n- Context-first: Log context is explicit (\"MyClass\" or \"MyClass.method\"), aiding filtering and debugging.\n- Extensible: Swap logger implementations via a factory; MiniLogger serves as a reference implementation.\n- Safe theming: Logging.theme guards against invalid theme keys and values and logs errors instead of throwing.\n\nKey behaviors\n- Level filtering: NumericLogLevels are used to compare configured level with the message level and decide emission.\n- Verbosity: .silly obeys LoggingConfig.verbose; only messages with <= configured verbosity are emitted.\n- Theming and styling: When style=true, Logging.theme applies Theme rules per component (class, message, logLevel, id, stack, timestamp). Theme can vary per LogLevel via ThemeOptionByLogLevel.\n- Correlation IDs: If correlationId is configured in a logger or child logger, it is included in output for easier traceability.\n\nPublic API surface\n- Classes: MiniLogger, Logging, LoggedClass; WinstonLogger (optional).\n- Decorators: log, debug, info, verbose, silly.\n- Enums/Consts: LogLevel, LoggingMode, NumericLogLevels, DefaultTheme, DefaultLoggingConfig.\n- Types: Logger, LoggingConfig, LoggerFactory, Theme, ThemeOption, ThemeOptionByLogLevel, LoggingContext.\n\nIntended usage\n- Use Logging.setConfig() at application startup to set level/style/timestamps.\n- Create class- or method-scoped loggers via Logging.for(MyClass) or logger.for('method').\n- Adopt LoggedClass to remove boilerplate in classes.\n- Add decorators to methods for automatic call/benchmark logs.\n- For advanced deployments, swap to WinstonFactory.\n",
    "examples": [
      "import { Logging, LogLevel } from \"@decaf-ts/logging\";\n\n// Set global configuration\nLogging.setConfig({\n  level: LogLevel.debug, // allow debug and above\n  style: false,          // plain output (tests use both styled and themeless)\n  timestamp: false,      // omit timestamp for simplicity in this example\n});\n\n// Log using the global logger\nLogging.info(\"Application started\");\nLogging.debug(\"Debug details\");\nLogging.error(\"Something went wrong\");\n\n// Verbosity-controlled logs (silly delegates to verbose internally)\nLogging.setConfig({ verbose: 2 });\nLogging.silly(\"Extra details at verbosity 1\");      // emitted when verbose >= 1\nLogging.verbose(\"Even more details\", 2);            // only with verbose >= 2\n",
      "import { Logging, LogLevel } from \"@decaf-ts/logging\";\n\nLogging.setConfig({ level: LogLevel.debug });\n\n// A class-scoped logger\nconst classLogger = Logging.for(\"UserService\");\nclassLogger.info(\"Fetching users\");\n\n// A child logger for a specific method with temporary config overrides\nconst methodLogger = classLogger.for(\"list\", { style: false });\nmethodLogger.debug(\"Querying repository...\");\n",
      "import { MiniLogger, LogLevel, type LoggingConfig } from \"@decaf-ts/logging\";\n\nconst logger = new MiniLogger(\"TestContext\");\nlogger.info(\"Info from MiniLogger\");\n\n// With custom configuration\nconst custom: Partial<LoggingConfig> = { level: LogLevel.debug, verbose: 2 };\nconst customLogger = new MiniLogger(\"TestContext\", custom);\ncustomLogger.debug(\"Debug with custom level\");\n\n// Child logger with correlation id\nconst traced = customLogger.for(\"run\", { correlationId: \"req-123\" });\ntraced.info(\"Tracing this operation\");\n",
      "import { log, debug, info as infoDecor, verbose as verboseDecor, silly as sillyDecor, LogLevel, Logging } from \"@decaf-ts/logging\";\n\n// Configure logging for demo\nLogging.setConfig({ level: LogLevel.debug, style: false, timestamp: false });\n\nclass AccountService {\n  @log(LogLevel.info) // logs method call with args\n  create(name: string) {\n    return { id: \"1\", name };\n  }\n\n  @debug(true) // logs call and completion time at debug level\n  rebuildIndex() {\n    // heavy work...\n    return true;\n  }\n\n  @info() // convenience wrapper for info level\n  enable() {\n    return true;\n  }\n\n  @verbose(1, true) // verbose with verbosity threshold and benchmark\n  syncAll() {\n    return Promise.resolve(\"ok\");\n  }\n\n  @silly() // very chatty, only emitted when verbose allows\n  ping() {\n    return \"pong\";\n  }\n}\n\nconst svc = new AccountService();\nsvc.create(\"Alice\");\nsvc.rebuildIndex();\nsvc.enable();\nawait svc.syncAll();\nsvc.ping();\n",
      "import { LoggedClass } from \"@your-scope/logging\";\n\nclass UserRepository extends LoggedClass {\n  findById(id: string) {\n    this.log.info(`Finding ${id}`);\n    return { id };\n  }\n}\n\nconst repo = new UserRepository();\nrepo.findById(\"42\");\n",
      "import { Logging } from \"@your-scope/logging\";\nimport { WinstonFactory } from \"@your-scope/logging/winston/winston\";\n\n// Install Winston as the logger factory\nLogging.setFactory(WinstonFactory);\n\n// Now any logger created will use Winston under the hood\nconst log = Logging.for(\"ApiGateway\");\nlog.info(\"Gateway started\");\n",
      "import { Logging, LogLevel, DefaultTheme, type Theme } from \"@your-scope/logging\";\n\n// Enable styling globally\nLogging.setConfig({ style: true, timestamp: true, context: false });\n\n// Optionally override theme: make debug level yellow (fg:33) and error red+bold\nconst theme: Theme = {\n  ...DefaultTheme,\n  logLevel: {\n    ...DefaultTheme.logLevel,\n    debug: { fg: 33 },\n    error: { fg: 31, style: [\"bold\"] },\n  },\n};\n\n// Apply at runtime by passing to Logging.theme where needed (MiniLogger does this internally)\nconst styled = Logging.theme(\"debug\", \"logLevel\", LogLevel.debug, theme);\n\n// Regular logging picks up style=true and formats output accordingly\nLogging.debug(\"This is a styled debug message\");\n",
      "import { Logging } from \"@your-scope/logging\";\n\n// Ad-hoc logger labeled with a reason and optional id (handy for correlation)\nconst jobLog = Logging.because(\"reindex\", \"job-77\");\njobLog.info(\"Starting reindex\");\n",
      "import type { Logger, LoggingConfig } from \"@your-scope/logging\";\n\nexport interface ServiceDeps {\n  log: Logger;\n  config?: Partial<LoggingConfig>;\n}\n\nexport class PaymentService {\n  constructor(private deps: ServiceDeps) {}\n  charge(amount: number) {\n    this.deps.log.info(`Charging ${amount}`);\n  }\n}\n"
    ],
    "base_path": "logging"
  },
  {
    "name": "utils",
    "title": "utils",
    "description": "### Description\n\nThe Decaf Utils module is a comprehensive TypeScript utility library designed to standardize APIs across repositories and provide a robust foundation for building command-line interface (CLI) applications. The library is organized into several key components:\n\n#### CLI Module\nThe CLI module provides a structured framework for creating command-line applications:\n- Abstract `Command` class for implementing custom CLI commands with standardized input handling, logging, and execution flow\n- Command option handling with support for common flags like verbose, version, help, etc.\n- Standardized command execution flow with proper error handling\n\n#### Input Module\nThe Input module offers tools for handling user input and command-line arguments:\n- `UserInput` class for creating interactive prompts with various input types (text, number, confirmation, etc.)\n- Support for input validation, formatting, and default values\n- Command-line argument parsing with type checking and validation\n- Methods for repeatedly asking for input until valid responses are received\n\n#### Utils Module\nThe Utils module contains a wide range of utility functions:\n- **File System Operations**: Reading, writing, copying, and deleting files and directories\n- **Package Management**: Retrieving package information, managing dependencies, and version handling\n- **HTTP Utilities**: Simple client for downloading files from URLs\n- **Text Processing**: String interpolation, case conversion (camelCase, snake_case, etc.), and regular expression utilities\n- **Environment Handling**: Working with environment variables and configuration\n\n#### Writers Module\nThe Writers module provides different strategies for handling command output:\n- `OutputWriter` interface defining a standard contract for output handling\n- `StandardOutputWriter` for handling standard command-line output with proper logging\n- `RegexpOutputWriter` for processing output with regular expressions and pattern matching\n\n#### Output Module\nThe Output module offers utilities for formatting and displaying output:\n- Common output formatting functions\n- Banner display capabilities\n\nThis library serves as a light version of the Decaf CLI tool, providing all the essential utilities needed for building robust command-line applications with consistent input handling, output formatting, and error management.\n",
    "examples": [
      "import { Command, CommandOptions } from '@decaf-ts/utils';\n\n// Define input options interface\ninterface MyCommandOptions {\n  filename: string;\n  dryRun: boolean;\n}\n\n// Create a custom command class\nclass MyCommand extends Command<MyCommandOptions, string> {\n  constructor() {\n    // Define command options with their configurations\n    const options: CommandOptions<MyCommandOptions> = {\n      filename: {\n        type: 'string',\n        short: 'f',\n        default: 'output.txt'\n      },\n      dryRun: {\n        type: 'boolean',\n        short: 'd',\n        default: false\n      }\n    };\n\n    super('my-command', options);\n  }\n\n  // Override the help method to provide custom help information\n  protected help(): void {\n    this.log.info(`\n      Usage: my-command [options]\n\n      Options:\n        -f, --filename  Specify output filename (default: output.txt)\n        -d, --dryRun    Run without making changes (default: false)\n        -h, --help      Show help information\n        -v, --version   Show version information\n    `);\n  }\n\n  // Implement the run method to define command behavior\n  protected async run(answers: { filename: string; dryRun: boolean }): Promise<string> {\n    this.log.info(`Running command with filename: ${answers.filename}, dryRun: ${answers.dryRun}`);\n\n    // Command implementation here\n\n    return 'Command executed successfully';\n  }\n}\n\n// Execute the command\nasync function main() {\n  const command = new MyCommand();\n  const result = await command.execute();\n  console.log(result);\n}\n\nmain().catch(console.error);\n",
      "import { UserInput } from '@decaf-ts/utils';\n\nasync function collectUserInfo() {\n  // Create a text input for name\n  const nameInput = new UserInput('name')\n    .setMessage('What is your name?')\n    .setInitial('User');\n\n  // Create a number input for age with validation\n  const ageInput = new UserInput('age')\n    .setType('number')\n    .setMessage('How old are you?')\n    .setMin(0)\n    .setMax(120)\n    .setValidate(value => {\n      if (value < 18) return 'You must be at least 18 years old';\n      return true;\n    });\n\n  // Create a confirmation input\n  const confirmInput = new UserInput('confirm')\n    .setType('confirm')\n    .setMessage('Is this information correct?')\n    .setInitial(true);\n\n  // Ask for all inputs and get the answers\n  const answers = await UserInput.ask([nameInput, ageInput, confirmInput]);\n\n  console.log(`Hello ${answers.name}, you are ${answers.age} years old.`);\n  console.log(`Information confirmed: ${answers.confirm ? 'Yes' : 'No'}`);\n\n  return answers;\n}\n\ncollectUserInfo().catch(console.error);\n",
      "import { UserInput } from '@decaf-ts/utils';\n\nasync function quickInputExample() {\n  // Ask for text input\n  const name = await UserInput.askText('name', 'What is your name?', undefined, 'User');\n\n  // Ask for number input\n  const age = await UserInput.askNumber('age', 'How old are you?', 0, 120);\n\n  // Ask for confirmation\n  const confirm = await UserInput.askConfirmation('confirm', 'Is this information correct?', true);\n\n  // Ask for text with validation and retry until valid\n  const email = await UserInput.insistForText(\n    'email',\n    'What is your email address?',\n    (value) => /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/.test(value),\n    undefined,\n    undefined,\n    false,\n    3 // Maximum 3 attempts\n  );\n\n  console.log(`Name: ${name}, Age: ${age}, Email: ${email}, Confirmed: ${confirm}`);\n}\n\nquickInputExample().catch(console.error);\n",
      "import { UserInput, ParseArgsOptionsConfig } from '@decaf-ts/utils';\n\n// Define command-line options\nconst options: ParseArgsOptionsConfig = {\n  verbose: {\n    type: 'boolean',\n    short: 'V',\n    default: false\n  },\n  output: {\n    type: 'string',\n    short: 'o',\n    default: 'output.txt'\n  },\n  count: {\n    type: 'string',\n    short: 'c',\n    default: '10'\n  }\n};\n\n// Parse command-line arguments\nconst args = UserInput.parseArgs(options);\n\nconsole.log('Parsed arguments:', args.values);\nconsole.log('Positional arguments:', args.positionals);\n",
      "import { \n  readFile, \n  writeFile, \n  patchFile, \n  getAllFiles, \n  copyFile, \n  renameFile, \n  deletePath \n} from '@decaf-ts/utils';\n\n// Read a file\nconst content = readFile('./config.json');\nconsole.log('File content:', content);\n\n// Write to a file\nwriteFile('./output.txt', 'Hello, world!');\n\n// Patch a file with replacements\npatchFile('./template.txt', {\n  '{{name}}': 'John Doe',\n  '{{date}}': new Date().toISOString()\n});\n\n// Get all files in a directory\nconst files = getAllFiles('./src', (file) => file.endsWith('.ts'));\nconsole.log('TypeScript files:', files);\n\n// Copy a file\ncopyFile('./source.txt', './destination.txt');\n\n// Rename a file\nrenameFile('./old-name.txt', './new-name.txt');\n\n// Delete a file or directory\ndeletePath('./temp');\n",
      "import { \n  getPackage, \n  getPackageVersion, \n  setPackageAttribute, \n  getDependencies, \n  installDependencies \n} from '@decaf-ts/utils';\n\n// Get package information\nconst pkg = getPackage();\nconsole.log('Package:', pkg);\n\n// Get package version\nconst version = getPackageVersion();\nconsole.log('Version:', version);\n\n// Set a package attribute\nsetPackageAttribute('version', '1.0.1');\n\n// Get dependencies\nasync function manageDependencies() {\n  const deps = await getDependencies();\n  console.log('Production dependencies:', deps.prod);\n  console.log('Development dependencies:', deps.dev);\n  console.log('Peer dependencies:', deps.peer);\n\n  // Install dependencies\n  await installDependencies({\n    prod: ['lodash', 'axios'],\n    dev: ['typescript', 'jest']\n  });\n}\n\nmanageDependencies().catch(console.error);\n",
      "import { HttpClient } from '@decaf-ts/utils';\n\nasync function downloadExample() {\n  try {\n    // Download a file from a URL\n    const content = await HttpClient.downloadFile('https://example.com/api/data.json');\n    console.log('Downloaded content:', content);\n\n    // Parse JSON content\n    const data = JSON.parse(content);\n    console.log('Parsed data:', data);\n\n    return data;\n  } catch (error) {\n    console.error('Download failed:', error);\n    throw error;\n  }\n}\n\ndownloadExample().catch(console.error);\n",
      "import { \n  padEnd, \n  patchPlaceholders, \n  patchString, \n  toCamelCase, \n  toSnakeCase, \n  toKebabCase, \n  toPascalCase, \n  toENVFormat \n} from '@decaf-ts/utils';\n\n// Pad a string\nconst padded = padEnd('Hello', 10, '-');\nconsole.log(padded); // 'Hello-----'\n\n// Replace placeholders\nconst template = 'Hello, ${name}! Today is ${day}.';\nconst filled = patchPlaceholders(template, {\n  name: 'Alice',\n  day: 'Monday'\n});\nconsole.log(filled); // 'Hello, Alice! Today is Monday.'\n\n// Replace strings\nconst patched = patchString('Hello, world!', {\n  'world': 'universe'\n});\nconsole.log(patched); // 'Hello, universe!'\n\n// Case conversion\nconst text = 'hello world';\nconsole.log(toCamelCase(text));   // 'helloWorld'\nconsole.log(toSnakeCase(text));   // 'hello_world'\nconsole.log(toKebabCase(text));   // 'hello-world'\nconsole.log(toPascalCase(text));  // 'HelloWorld'\nconsole.log(toENVFormat(text));   // 'HELLO_WORLD'\n",
      "import { StandardOutputWriter } from '@decaf-ts/utils';\n\n// Create a promise executor\nconst executor = {\n  resolve: (value: string) => console.log(`Command succeeded with: ${value}`),\n  reject: (error: Error) => console.error(`Command failed with: ${error.message}`)\n};\n\n// Create a standard output writer\nconst writer = new StandardOutputWriter('ls -la', executor);\n\n// Handle command output\nwriter.data('File list output...');\nwriter.data('file1.txt');\nwriter.data('file2.txt');\n\n// Handle command completion\nwriter.exit(0, ['Command executed successfully']);\n",
      "import { RegexpOutputWriter } from '@decaf-ts/utils';\n\n// Create a promise executor\nconst executor = {\n  resolve: (value: string) => console.log(`Found version: ${value}`),\n  reject: (error: Error) => console.error(`Error: ${error.message}`)\n};\n\n// Create a regexp output writer that matches version numbers\nconst writer = new RegexpOutputWriter('node --version', executor, /v(\\d+\\.\\d+\\.\\d+)/);\n\n// Process output that contains a version number\nwriter.data('v14.17.0');  // This will automatically resolve with \"v14.17.0\"\n\n// Process error output\nwriter.error('Command not found: node');  // This will be logged as an error\n"
    ],
    "base_path": "utils"
  },
  {
    "name": "reflection",
    "title": "reflection",
    "description": "## Description\n\nThe Reflection library is a powerful utility package for TypeScript applications that enhances runtime type inspection and metadata manipulation capabilities. Built on top of the `reflect-metadata` API, it provides a comprehensive set of tools for working with TypeScript's type system at runtime.\n\n### Core Components\n\n#### Reflection Class\nThe central component of the library is the `Reflection` class, which provides methods for:\n\n- **Type Checking**: Validate values against expected types at runtime with `checkType` and `checkTypes` methods\n- **Property Inspection**: Retrieve all properties of an object, including those in the prototype chain with `getAllProperties`\n- **Decorator Management**: Access and manipulate class and property decorators with methods like `getClassDecorators`, `getAllPropertyDecorators`, and `getPropertyDecorators`\n- **Type Extraction**: Extract type information from decorators with `getTypeFromDecorator`\n\n#### Decorator Utilities\nThe library includes decorator factory functions that simplify working with metadata:\n\n- **metadata**: A versatile decorator factory that attaches metadata to classes, methods, or properties\n- **apply**: A utility for applying multiple decorators to a single target in sequence\n\n#### Deep Equality Comparison\nThe `isEqual` function provides sophisticated deep equality checking between any two values with support for:\n\n- Primitive types with special handling for edge cases like NaN and +0/-0\n- Complex objects including Arrays, Maps, Sets, Dates, RegExp, and Error objects\n- TypedArrays with byte-by-byte comparison\n- Property exclusion through the optional `propsToIgnore` parameter\n\n#### Type Definitions\nThe library defines several TypeScript types to provide structure for working with decorators and metadata:\n\n- **DecoratorMetadata**: Represents metadata associated with decorators\n- **ClassDecoratorsList**: Collection of class decorators\n- **PropertyDecoratorList**: Maps property names to their decorators\n- **FullPropertyDecoratorList**: Complete decorator information for properties\n\n### Integration with TypeScript Ecosystem\n\nThe Reflection library is designed to work seamlessly with TypeScript's type system and the `reflect-metadata` API. It enhances TypeScript's compile-time type checking with runtime validation capabilities, making it an essential tool for building robust, type-safe applications.\n\n### Use Cases\n\n- **Runtime Type Validation**: Verify that values conform to expected types during program execution\n- **Framework Development**: Build frameworks that leverage TypeScript's type system at runtime\n- **Object Comparison**: Perform deep equality checks between complex objects\n- **Metadata-Driven Architecture**: Create systems that use metadata to drive behavior\n\nPlease follow the Contributing guide or the developer's guide to contribute to this library. All help is appreciated.\n\nTechnical documentation can be found [here](https://decaf-ts.github.io/reflection/)\n",
    "examples": [
      "// tsconfig.json\n{\n  \"compilerOptions\": {\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n    // other options...\n  }\n}\n",
      "import { Reflection, metadata, apply, isEqual, ReflectionKeys } from '@decaf-ts/reflection';\n",
      "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Check if a value is a string\nconst value = \"Hello, world!\";\nconst isString = reflection.checkType(value, String); // Returns true\n\n// Check if a value is a number\nconst num = 42;\nconst isNumber = reflection.checkType(num, Number); // Returns true\n\n// Check if a value is an instance of a class\nclass Person {\n  constructor(public name: string) {}\n}\nconst person = new Person(\"John\");\nconst isPerson = reflection.checkType(person, Person); // Returns true\n",
      "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Check if a value is either a string or a number\nconst value1 = \"Hello\";\nconst value2 = 42;\n\nconst isStringOrNumber1 = reflection.checkTypes(value1, [String, Number]); // Returns true\nconst isStringOrNumber2 = reflection.checkTypes(value2, [String, Number]); // Returns true\nconst isStringOrNumber3 = reflection.checkTypes(true, [String, Number]); // Returns false\n",
      "import { Reflection } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\nclass BaseClass {\n  baseProperty = 'base';\n\n  baseMethod() {\n    return 'base method';\n  }\n}\n\nclass DerivedClass extends BaseClass {\n  derivedProperty = 'derived';\n\n  derivedMethod() {\n    return 'derived method';\n  }\n}\n\nconst instance = new DerivedClass();\n\n// Get all properties including those from the prototype chain\nconst allProps = reflection.getAllProperties(instance, true);\nconsole.log(allProps); \n// Output includes: 'baseProperty', 'baseMethod', 'derivedProperty', 'derivedMethod'\n\n// Get only own properties\nconst ownProps = reflection.getAllProperties(instance, false);\nconsole.log(ownProps); \n// Output includes only: 'baseProperty', 'derivedProperty'\n",
      "import { Reflection, metadata } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Define some decorators\nconst EntityDecorator = metadata('entity', { name: 'User' });\nconst ValidateDecorator = metadata('validate', { required: true });\n\n// Apply decorators to a class\n@EntityDecorator\n@ValidateDecorator\nclass User {\n  id: number;\n  name: string;\n}\n\n// Get all decorators with 'entity' prefix\nconst entityDecorators = reflection.getClassDecorators('entity', User);\nconsole.log(entityDecorators);\n// Output: [{ key: 'entity', props: { name: 'User' } }]\n",
      "import { Reflection, metadata } from '@decaf-ts/reflection';\n\nconst reflection = new Reflection();\n\n// Define some property decorators\nconst ColumnDecorator = metadata('column', { type: 'varchar' });\nconst ValidateDecorator = metadata('validate', { required: true });\n\nclass User {\n  @ColumnDecorator\n  @ValidateDecorator\n  name: string;\n}\n\n// Get all decorators with 'column' prefix for the 'name' property\nconst columnDecorators = reflection.getPropertyDecorators('column', User, 'name');\nconsole.log(columnDecorators);\n// Output: [{ key: 'column', props: { type: 'varchar' } }]\n",
      "import { metadata } from '@decaf-ts/reflection';\n\n// Create a decorator for marking a class as an entity\nconst Entity = (name: string) => metadata('entity', { name });\n\n// Create a decorator for marking a property as a column\nconst Column = (options: { type: string, nullable?: boolean }) => \n  metadata('column', options);\n\n// Apply decorators\n@Entity('users')\nclass User {\n  @Column({ type: 'int', nullable: false })\n  id: number;\n\n  @Column({ type: 'varchar', nullable: true })\n  name: string;\n}\n\n// The metadata can later be retrieved using Reflection methods\n",
      "import { apply, metadata } from '@decaf-ts/reflection';\n\n// Create individual decorators\nconst Required = metadata('validate', { required: true });\nconst MaxLength = (length: number) => metadata('validate', { maxLength: length });\nconst Email = metadata('validate', { isEmail: true });\n\n// Create a composite decorator using apply\nconst ValidEmail = apply(\n  Required,\n  MaxLength(100),\n  Email\n);\n\nclass User {\n  // Apply multiple validations with a single decorator\n  @ValidEmail\n  email: string;\n}\n\n// This is equivalent to:\n// @Required\n// @MaxLength(100)\n// @Email\n// email: string;\n",
      "import { isEqual } from '@decaf-ts/reflection';\n\n// Compare primitive values\nconsole.log(isEqual(1, 1)); // true\nconsole.log(isEqual('hello', 'hello')); // true\nconsole.log(isEqual(1, '1')); // false (different types)\n\n// Compare objects\nconst obj1 = { name: 'John', age: 30 };\nconst obj2 = { name: 'John', age: 30 };\nconst obj3 = { name: 'Jane', age: 30 };\n\nconsole.log(isEqual(obj1, obj2)); // true\nconsole.log(isEqual(obj1, obj3)); // false\n\n// Compare with ignored properties\nconst user1 = { id: 1, name: 'John', createdAt: new Date('2023-01-01') };\nconst user2 = { id: 2, name: 'John', createdAt: new Date('2023-02-01') };\n\n// Compare ignoring 'id' and 'createdAt'\nconsole.log(isEqual(user1, user2, 'id', 'createdAt')); // true\n\n// Compare complex structures\nconst complex1 = {\n  data: [1, 2, 3],\n  metadata: new Map([['key1', 'value1']]),\n  date: new Date('2023-01-01')\n};\n\nconst complex2 = {\n  data: [1, 2, 3],\n  metadata: new Map([['key1', 'value1']]),\n  date: new Date('2023-01-01')\n};\n\nconsole.log(isEqual(complex1, complex2)); // true\n",
      "import { ReflectionKeys, metadata } from '@decaf-ts/reflection';\nimport 'reflect-metadata';\n\n// Define a class with a property\nclass User {\n  name: string;\n}\n\n// Access the type metadata\nconst typeMetadata = Reflect.getMetadata(ReflectionKeys.TYPE, User.prototype, 'name');\nconsole.log(typeMetadata === String); // true (if emitDecoratorMetadata is enabled)\n\n// Define a custom decorator that uses ReflectionKeys\nfunction TypedProperty() {\n  return (target: any, propertyKey: string) => {\n    const type = Reflect.getMetadata(ReflectionKeys.TYPE, target, propertyKey);\n    console.log(`Property ${propertyKey} has type: ${type.name}`);\n  };\n}\n\nclass Product {\n  @TypedProperty()\n  price: number;\n}\n// Output: \"Property price has type: Number\"\n",
      "import { Reflection, metadata, apply } from '@decaf-ts/reflection';\n\n// Create validation decorators\nconst Required = metadata('validate', { required: true });\nconst MinLength = (min: number) => metadata('validate', { minLength: min });\nconst MaxLength = (max: number) => metadata('validate', { maxLength: max });\nconst Email = metadata('validate', { isEmail: true });\n\n// Create a validator class\nclass Validator {\n  private reflection = new Reflection();\n\n  validate(instance: any): { isValid: boolean, errors: string[] } {\n    const errors: string[] = [];\n    const constructor = instance.constructor;\n\n    // Get all properties with validation decorators\n    const decoratedProps = this.reflection.getAllPropertyDecorators(constructor, ['validate']);\n\n    for (const propName in decoratedProps) {\n      const value = instance[propName];\n      const validators = decoratedProps[propName];\n\n      for (const validator of validators) {\n        const props = validator.props as Record<string, any>;\n\n        // Check required\n        if (props.required && (value === undefined || value === null || value === '')) {\n          errors.push(`${propName} is required`);\n        }\n\n        // Skip other validations if value is not present\n        if (value === undefined || value === null) continue;\n\n        // Check minLength\n        if (props.minLength && typeof value === 'string' && value.length < props.minLength) {\n          errors.push(`${propName} must be at least ${props.minLength} characters`);\n        }\n\n        // Check maxLength\n        if (props.maxLength && typeof value === 'string' && value.length > props.maxLength) {\n          errors.push(`${propName} must be at most ${props.maxLength} characters`);\n        }\n\n        // Check email\n        if (props.isEmail && typeof value === 'string') {\n          const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n          if (!emailRegex.test(value)) {\n            errors.push(`${propName} must be a valid email address`);\n          }\n        }\n      }\n    }\n\n    return {\n      isValid: errors.length === 0,\n      errors\n    };\n  }\n}\n\n// Use the validation system\nclass User {\n  @Required\n  id: number;\n\n  @apply(Required, MinLength(3), MaxLength(50))\n  name: string;\n\n  @apply(Required, Email)\n  email: string;\n}\n\nconst validator = new Validator();\n\n// Valid user\nconst validUser = new User();\nvalidUser.id = 1;\nvalidUser.name = \"John Doe\";\nvalidUser.email = \"john@example.com\";\nconsole.log(validator.validate(validUser)); \n// { isValid: true, errors: [] }\n\n// Invalid user\nconst invalidUser = new User();\ninvalidUser.name = \"Jo\";\ninvalidUser.email = \"not-an-email\";\nconsole.log(validator.validate(invalidUser));\n// { \n//   isValid: false, \n//   errors: [\n//     'id is required',\n//     'name must be at least 3 characters',\n//     'email must be a valid email address'\n//   ] \n// }\n"
    ],
    "base_path": "reflection"
  },
  {
    "name": "decorator-validation",
    "title": "decorator-validation",
    "description": "# Decorator Validation – Detailed Description\n\nDecorator Validation is a TypeScript library that centers on two complementary pillars:\n\n1) Declarative validation via decorators\n- A rich set of property decorators such as @required, @min, @max, @minLength, @maxLength, @pattern, @email, @url, @type, @equals, @greaterThan, @greaterThanOrEqual, @lessThan, @lessThanOrEqual, @step, @list, @diff, @date, @password, as well as an async() flag helper.\n- Each decorator writes strongly-typed metadata using reflect-metadata and a common Validation metadata keying convention, so validators can later interpret the rules consistently.\n- Decorators are defined in src/validation/decorators.ts and are backed by concrete Validator classes in src/validation/Validators/* that implement the actual validation logic.\n\n2) A model system tailored for validation, building, hashing, and serialization\n- Models are ordinary classes marked with @model() (src/model/decorators.ts). The decorator replaces the constructor, binds the model prototype utilities, runs a global builder (if registered), and tags reflection metadata for identification.\n- Additional class-level decorators configure algorithms:\n  - @hashedBy(algorithm, ...args) to define model hashing implementation.\n  - @serializedBy(serializer, ...args) to define serialization strategy.\n  - @description(text) to attach human-readable documentation to a class, property, or method.\n- The Model class (src/model/Model.ts) provides:\n  - A ModelRegistryManager for registering and retrieving model constructors by name, enabling rebuild/deserialize flows.\n  - Validation integration (model/validation.ts) that runs the registered validators against metadata collected by decorators.\n  - Utility methods and metadata helpers to identify models, fetch metadata, compare instances, and orchestrate hashing/serialization strategies.\n\nCore runtime architecture\n- Validation namespace (src/validation/Validation.ts):\n  - Manages a pluggable IValidatorRegistry so custom Validator implementations can be registered, migrated, and queried.\n  - Exposes helper utilities: Validation.key(key) for reflect-metadata keying, Validation.keys() to list available validator keys, register(...) and get(...) to manage validators, decorator registration to link a metadata key to its decorator for dynamic use.\n- Validator classes (src/validation/Validators/*):\n  - BaseValidator.ts defines common behaviors; concrete validators (RequiredValidator, MinValidator, PatternValidator, etc.) implement validate and message/typing logic.\n  - ValidatorRegistry.ts stores Validator instances keyed by ValidationKeys constants.\n  - constants.ts defines DEFAULT_ERROR_MESSAGES, DEFAULT_PATTERNS, and ValidationKeys (e.g., REQUIRED, MIN, MAX...).\n  - decorators.ts contains decorator sugar for directly registering standard validators and building metadata using Decoration/Reflection utilities.\n- Utilities (src/utils/*):\n  - strings, dates, types, serialization, hashing, registry, decorators, Decoration helper, and a PathProxy to traverse nested properties and apply metadata.\n\nIntent of the library\n- Provide a cohesive, decorator-first developer experience for enforcing validation constraints on model classes.\n- Ensure that validation, model lifecycle (build/serialize/hash), and metadata are consistent and extensible through registries.\n- Allow advanced composition (custom validators, alternative registries), and integration into automation flows (MCP tools).\n\nDesign principles\n- Declarative over imperative: Constraints live next to the properties they validate.\n- Extensibility: Registries and helper factories allow swapping implementations without changing consumer code.\n- Type safety: Metadata and decorators are typed; validators advertise supported types; utility functions use narrow types where practical.\n- Separation of concerns: Decorators express intent; Validator classes implement behavior; Model provides lifecycle utilities.\n",
    "examples": [
      "import { model, Model, ModelArg } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass User extends Model {\n  @prop()\n  id!: string;\n  @prop()\n  name!: string;\n  \n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nconst u = new User();\n",
      "import { required, Model, model, ModelArg } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Child extends Model {\n  @required()\n  name!: string;\n  \n  constructor(arg?: ModelArg<Child>) {\n    super(arg);\n  }\n}\n\n@model()\nclass Parent extends Model {\n  @required()\n  name!: string;\n  @required()\n  child!: Child;\n  constructor(arg?: ModelArg<Parent>) {\n    super(arg);\n  }\n}\n// Default builder is Model.fromModel\n\nlet parent = new Parent({\n  child: {\n    name: \"child\"\n  }\n})\n\nparent.child instanceof Child; // true\n\nModel.setBuilder(Model.fromObject);\n\nparent = new Parent({\n  child: {\n    name: \"child\"\n  }\n})\n\nparent.child instanceof Child; // false\n",
      "import { model, hashedBy, ModelArg, prop } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@hashedBy(\"sha256\", \"utf8\")\nclass FileInfo extends Model {\n  @prop()\n  path!: string;\n  @prop()\n  size!: number;\n  \n  constructor(arg?: ModelArg<FileInfo>) {\n    super(arg)\n  }\n}\n",
      "import { prop, ModelArg, model, serializedBy } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@serializedBy(\"json\")\nclass Settings extends Model {\n  @prop()\n  theme!: string;\n  @prop()\n  locale!: string;\n  \n  constructor(arg?: ModelArg<Settings>){\n    super(arg)\n  }\n}\n",
      "import { model, description, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@description(\"Represents an application user\")\nclass User extends Model {\n  @description(\"Unique identifier\")\n  id!: string;\n  // ...\n}\n",
      "import { Model, required, model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass User extends Model {\n  @required()\n  username!: string;\n  //...\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { min } from \"@decaf-ts/decorator-validation\";\nimport { max } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Product extends Model {\n  @min(0)\n  @max(1000)\n  price!: number;\n}\n",
      "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { minLength, maxLength } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Credentials extends Model {\n  @minLength(8)\n  @maxLength(64)\n  password!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { pattern, model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Vehicle extends Model {\n  @pattern(/^[A-Z]{2}-\\d{2}-[A-Z]{2}$/)\n  plate!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { email } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Contact extends Model {\n  @email()\n  email!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { url } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Link extends Model {\n  @url()\n  href!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { type } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Measurement extends Model {\n  @type(Number)\n  value!: number;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { equals } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Confirmation extends Model {\n  password!: string;\n  @equals(\":password\")\n  confirm!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { greaterThan, greaterThanOrEqual, lessThan, lessThanOrEqual } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Range extends Model {\n  @greaterThan(0)\n  @lessThanOrEqual(100)\n  ratio!: number;\n}\n",
      "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { step } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Slider extends Model {\n  @step(0.5)\n  value!: number;\n}\n",
      "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { list } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass ThemeSettingm extends Model {\n  @list([\"light\", \"dark\", \"system\"]) \n  theme!: \"light\" | \"dark\" | \"system\";\n}\n",
      "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { diff } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Credentials extends Model {\n  username!: string;\n  @diff(\":username\")\n  password!: string;\n}\n",
      "import { model, Model } from \"@decaf-ts/decorator-validation\";\nimport { date } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Booking extends Model {\n  @date({ min: new Date(\"2025-01-01\"), max: new Date(\"2025-12-31\") })\n  start!: Date;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { password, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Account extends Model{\n  @password({ minLength: 10 })\n  password!: string;\n}\n",
      "import { model } from \"@decaf-ts/decorator-validation\";\nimport { async } from \"@decaf-ts/decorator-validation\";\n\n@model()\n@async()\nclass Signup {\n  // fields that may use async validators\n}\n",
      "import { model, required, email, validate, Model } from \"@decaf-ts/decorator-validation\";\n\n@model()\nclass Contact extends Model {\n  @required()\n  @email()\n  email!: string;\n  \n  constructor(arg?: ModelArg<Contact>) {\n    super(arg);\n  }\n}\n\nconst c = new Contact({\n  email: \"not-an-email\"\n});\n\nlet errs = c.hasErrors(); // resolves to a list of errors or undefined\n\n@async()\n@model()\nclass User extends Model {\n  @required()\n  @email()\n  email!: string;\n  \n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nconst u = new User({\n  email: \"not-an-email\"\n})\n\nerrs = await u.hasErrors(); // resolves to a list of errors or undefined\n\n",
      "import { Validation, ValidatorRegistry } from \"@decaf-ts/decorator-validation\";\n\nconst custom = new ValidatorRegistry();\nValidation.setRegistry(custom, v => v); // trivial migration\n",
      "import { Validation, Validator, validator } from \"@decaf-ts/decorator-validation\";\n\n@validator(\"ALWAYS_OK\")\nclass AlwaysOk extends Validator {\n  hasErrors(...args: any[]) { return []; }\n}\n\nValidation.register(new AlwaysOk());\n",
      "import { Validation, ValidationKeys } from \"@decaf-ts/decorator-validation\";\n\nconst requiredValidator = Validation.get(ValidationKeys.REQUIRED);\n",
      "import { Validation } from \"@decaf-ts/decorator-validation\";\n\nconst metaKey = Validation.key(\"REQUIRED\");\nconst allKeys = Validation.keys();\n"
    ],
    "base_path": "decorator-validation"
  },
  {
    "name": "injectable-decorators",
    "title": "injectable-decorators",
    "description": "### Description\n\nThe `injectable-decorators` library is a standalone module that provides a lightweight and flexible dependency injection system for TypeScript applications. It is designed to simplify the management of dependencies between components in your application through the use of TypeScript decorators.\n\n#### Core Components\n\n1. **Injectables Registry**\n   - The central component that manages all injectable objects\n   - Maintains a cache of singleton instances\n   - Provides methods for registering, retrieving, and building injectable objects\n   - Can be customized with a different implementation if needed\n\n2. **Decorators**\n   - `@injectable()`: Class decorator that marks a class as available for dependency injection\n     - Transforms the class into a singleton that can be retrieved from the registry\n     - Supports optional category naming for minification safety\n     - Allows for custom callbacks after instance creation\n   - `@inject()`: Property decorator that injects a dependency into a class property\n     - Automatically resolves the dependency type from TypeScript's type system\n     - Supports custom transformers to modify the injected instance\n     - Implements lazy loading - dependencies are only instantiated when accessed\n\n3. **Reflection Utilities**\n   - Uses TypeScript's reflection metadata to determine property types\n   - Provides utilities for working with type information in decorators\n\n#### Key Features\n\n- **Singleton Management**: Injectables are typically managed as singletons, ensuring consistent state across your application.\n- **Lazy Loading**: Dependencies are only instantiated when they are actually accessed, simplifying the injection order and improving performance.\n- **Type Safety**: Leverages TypeScript's type system to ensure type safety in injected dependencies.\n- **Minification Support**: Provides options to specify explicit names for injectables to handle minification scenarios.\n- **Custom Transformations**: Supports transforming injectable instances before they're injected into target objects.\n- **Selective Reset**: Ability to selectively reset specific injectables in the registry based on name patterns.\n\n#### Design Philosophy\n\nThe library follows a minimalist approach, focusing on providing essential dependency injection capabilities without unnecessary complexity. It's designed to be:\n\n- **Lightweight**: Small footprint with minimal dependencies\n- **Flexible**: Adaptable to different application architectures\n- **Intuitive**: Simple API that follows natural TypeScript patterns\n- **Non-intrusive**: Minimal impact on your existing code structure\n\nUnlike more complex DI frameworks, this library doesn't require extensive configuration or setup. The developer is responsible for initially decorating classes and properties, but the library handles the instantiation and injection process automatically.\n",
    "examples": [
      "import 'reflect-metadata';\nimport { injectable, Injectables } from 'injectable-decorators';\n\n@injectable()\nclass InitialObject {\n  doSomething() { return 5; }\n}\n\nconst obj = new InitialObject();\nconst same = Injectables.get(InitialObject);\n// obj and same refer to the same instance (singleton by default)\n",
      "import 'reflect-metadata';\nimport { injectable, inject, Injectables } from 'injectable-decorators';\n\n@injectable()\nclass SomeService { value = 5; }\n\nclass Controller {\n  @inject()\n  service!: SomeService; // non-null assertion because it's set outside the constructor\n}\n\nconst c = new Controller();\nconsole.log(c.service.value); // 5\nconsole.log(c.service === Injectables.get(SomeService)); // true\n",
      "import 'reflect-metadata';\nimport { injectable, inject, singleton } from 'injectable-decorators';\n\n@singleton()\nclass AAA { a = 'aaa'; }\n\n@injectable('AAA')\nclass BBB extends AAA { b = 'bbb'; }\n\nconst b = new BBB();\n\nclass Host {\n  @inject()\n  repo!: AAA; // resolves to the instance registered under category 'AAA'\n}\n\nconst h = new Host();\nconsole.log(h.repo === b); // true\n",
      "import 'reflect-metadata';\nimport { inject, singleton } from 'injectable-decorators';\n\nclass DDD { a = 'aaa'; }\n\n@singleton('EEE')\nclass CCC extends DDD { b = 'bbb'; }\n\nconst instance = new CCC();\n\nclass Holder {\n  @inject('EEE')\n  repo!: CCC;\n}\n\nconst h = new Holder();\nconsole.log(h.repo === instance); // true\n",
      "import 'reflect-metadata';\nimport { injectable, inject } from 'injectable-decorators';\n\nclass Token {}\n\n@injectable(Token, { callback: (original) => original })\nclass Impl {\n  id = 1;\n}\n\nclass UsesImpl {\n  @inject(Token)\n  object!: Impl; // injects the instance registered under Token (Impl instance)\n}\n\nconst u = new UsesImpl();\nconsole.log(u.object instanceof Impl); // true\n",
      "import 'reflect-metadata';\nimport { onDemand, inject } from 'injectable-decorators';\n\n@onDemand()\nclass FreshObject {\n  constructor(public a?: string, public b?: string) {}\n}\n\nclass ParentA {\n  @inject()\n  fresh!: FreshObject; // new instance per parent\n}\n\nclass ParentB {\n  @inject({ args: ['x', 'y'] })\n  fresh!: FreshObject; // passes constructor args to on-demand instance\n}\n\nconst p1 = new ParentA();\nconst p2 = new ParentA();\nconsole.log(p1.fresh !== p2.fresh); // true\n\nconst p3 = new ParentB();\nconsole.log([p3.fresh.a, p3.fresh.b]); // ['x','y']\n",
      "import 'reflect-metadata';\nimport { injectable, inject } from 'injectable-decorators';\n\n@injectable('SomeOtherObject')\nclass SomeOtherObject { value() { return 10; } }\n\nclass Controller {\n  @inject({ transformer: (obj: SomeOtherObject, c: Controller) => '1' })\n  repo!: SomeOtherObject | string;\n}\n\nconst c = new Controller();\nconsole.log(c.repo); // '1'\n",
      "import { Injectables, InjectableRegistryImp } from 'injectable-decorators';\n\n// ensure something is registered\nInjectables.get('SomeOtherObject');\n\n// swap to a fresh registry\nInjectables.setRegistry(new InjectableRegistryImp());\nconsole.log(Injectables.get('SomeOtherObject')); // undefined\n\n// reset to a new empty default registry\nInjectables.reset();\n",
      "import { singleton, onDemand } from 'injectable-decorators';\n\n@singleton()\nclass OneOnly {}\n\n@onDemand()\nclass Many {}\n",
      "import { getInjectKey } from 'injectable-decorators';\n\nconsole.log(getInjectKey('injectable')); // \"inject.db.injectable\"\nconsole.log(getInjectKey('inject'));     // \"inject.db.inject\"\n"
    ],
    "base_path": "injectable-decorators"
  },
  {
    "name": "as-zod",
    "title": "as-zod",
    "description": "### Description\n\nEasy two-way conversion from Models to Zod\n\nversions `^0.0.1` are for zod 3.x. `^1.0.0` for zod 4.x",
    "examples": [],
    "base_path": "as-zod"
  },
  {
    "name": "db-decorators",
    "title": "db-decorators",
    "description": "\n### DB-Decorators\n\nThe db-decorators library is a powerful TypeScript framework for database operations that leverages decorators to simplify database interactions. It provides a comprehensive solution for implementing the repository pattern with built-in support for model definition, validation, identity management, and operation hooks.\n\n#### Key Features\n\n1. **Repository Pattern Implementation**\n  - Abstract `BaseRepository` class providing the foundation for CRUD operations\n  - Concrete `Repository` class with validation support\n  - Support for bulk operations through the `BulkCrudOperator` interface\n\n2. **Model Management**\n  - Model definition with TypeScript decorators\n  - Identity management with the `@id()` decorator\n  - Property composition with `@composed()` and `@composedFromKeys()` decorators\n  - Versioning support with the `@version()` decorator\n  - Transient properties with the `@transient()` decorator\n\n3. **Operation Hooks**\n  - Pre-operation hooks with `@on()`, `@onCreate()`, `@onUpdate()`, etc.\n  - Post-operation hooks with `@after()`, `@afterCreate()`, `@afterUpdate()`, etc.\n  - Custom operation handlers through the `Operations` registry\n\n4. **Context Management**\n  - Hierarchical context chains with parent-child relationships\n  - Context accumulation for state management\n  - Operation-specific context creation\n\n5. **Validation**\n  - Integration with decorator-validation library\n  - Automatic validation during CRUD operations\n  - Custom validation rules through decorators\n\nThe library is designed to be extensible and adaptable to different database backends, providing a consistent API regardless of the underlying storage mechanism.\n",
    "examples": [
      "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, hash, version, transient } from \"@decaf-ts/db-decorators\";\nimport { required, minLength, email as emailValidator } from \"@decaf-ts/decorator-validation\";\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  @minLength(3)\n  name: string;\n\n  @required()\n  @emailValidator()\n  email: string;\n\n  @required()\n  @minLength(8)\n  @hash()\n  password: string;\n\n  @version()\n  version: number;\n\n  @transient()\n  temporaryData: any;\n}\n",
      "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, composed, composedFromKeys } from \"@decaf-ts/db-decorators\";\nimport { required } from \"@decaf-ts/decorator-validation\";\n\nclass Product extends Model {\n  @id()\n  id: string;\n\n  @required()\n  category: string;\n\n  @required()\n  name: string;\n\n  @required()\n  variant: string;\n\n  @composed(['category', 'name', 'variant'], '-')\n  sku: string;\n\n  @composedFromKeys(['category', 'name'], '_', true, 'PROD_', '_KEY')\n  productKey: string;\n}\n",
      "import { Repository } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(User);\n  }\n\n  async create(model: User, ...args: any[]): Promise<User> {\n    // Implementation for creating a user in the database\n    console.log(`Creating user: ${model.name}`);\n    // Assign an ID if not already present\n    if (!model.id) {\n      model.id = Date.now().toString();\n    }\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation for reading a user from the database\n    console.log(`Reading user with ID: ${key}`);\n    return new User({ id: key, name: \"Example User\", email: \"user@example.com\" });\n  }\n\n  async update(model: User, ...args: any[]): Promise<User> {\n    // Implementation for updating a user in the database\n    console.log(`Updating user: ${model.name}`);\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation for deleting a user from the database\n    console.log(`Deleting user with ID: ${key}`);\n    const user = await this.read(key);\n    return user;\n  }\n}\n",
      "import { Repository } from \"@decaf-ts/db-decorators\";\nimport { Product } from \"./models/Product\";\n\nclass ProductRepository extends Repository<Product> {\n  constructor() {\n    super(Product);\n  }\n\n  // Implement required CRUD methods\n  async create(model: Product, ...args: any[]): Promise<Product> {\n    // Implementation\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<Product> {\n    // Implementation\n    return new Product({ id: key });\n  }\n\n  async update(model: Product, ...args: any[]): Promise<Product> {\n    // Implementation\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<Product> {\n    // Implementation\n    return await this.read(key);\n  }\n\n  // Override bulk methods for optimized implementation\n  async createAll(models: Product[], ...args: any[]): Promise<Product[]> {\n    console.log(`Bulk creating ${models.length} products`);\n    // Custom implementation for bulk creation\n    return models.map(model => {\n      if (!model.id) {\n        model.id = Date.now().toString();\n      }\n      return model;\n    });\n  }\n\n  async readAll(keys: string[] | number[], ...args: any[]): Promise<Product[]> {\n    console.log(`Bulk reading ${keys.length} products`);\n    // Custom implementation for bulk reading\n    return keys.map(key => new Product({ id: key }));\n  }\n}\n",
      "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, onCreate, onUpdate, onCreateUpdate } from \"@decaf-ts/db-decorators\";\nimport { required } from \"@decaf-ts/decorator-validation\";\n\n// Handler function for setting creation timestamp\nfunction setCreationTimestamp(repo, context, data, key, model) {\n  model[key] = new Date().toISOString();\n}\n\n// Handler function for setting update timestamp\nfunction setUpdateTimestamp(repo, context, data, key, model) {\n  model[key] = new Date().toISOString();\n}\n\n// Handler function for normalizing email\nfunction normalizeEmail(repo, context, data, key, model) {\n  if (model[key]) {\n    model[key] = model[key].toLowerCase().trim();\n  }\n}\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  name: string;\n\n  @required()\n  @onCreateUpdate(normalizeEmail)\n  email: string;\n\n  @onCreate(setCreationTimestamp)\n  createdAt: string;\n\n  @onUpdate(setUpdateTimestamp)\n  updatedAt: string;\n}\n",
      "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id, afterCreate, afterUpdate, afterDelete } from \"@decaf-ts/db-decorators\";\n\n// Handler function for logging after creation\nfunction logCreation(repo, context, data, key, model) {\n  console.log(`User created: ${model.id} - ${model.name}`);\n}\n\n// Handler function for logging after update\nfunction logUpdate(repo, context, data, key, model) {\n  console.log(`User updated: ${model.id} - ${model.name}`);\n}\n\n// Handler function for logging after deletion\nfunction logDeletion(repo, context, data, key, model) {\n  console.log(`User deleted: ${model.id} - ${model.name}`);\n}\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  name: string;\n\n  @required()\n  email: string;\n\n  @afterCreate(logCreation)\n  @afterUpdate(logUpdate)\n  @afterDelete(logDeletion)\n  _log: any; // This property is just a placeholder for the decorators\n}\n",
      "import { Context, Repository } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\nclass UserRepository extends Repository<User> {\n  constructor() {\n    super(User);\n  }\n\n  // Implement required CRUD methods\n  async create(model: User, ...args: any[]): Promise<User> {\n    // Implementation\n    return model;\n  }\n\n  async read(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation\n    return new User({ id: key });\n  }\n\n  async update(model: User, ...args: any[]): Promise<User> {\n    // Implementation\n    return model;\n  }\n\n  async delete(key: string | number, ...args: any[]): Promise<User> {\n    // Implementation\n    return await this.read(key);\n  }\n\n  // Example of using context\n  async createWithAudit(model: User, userId: string): Promise<User> {\n    // Create a context with audit information\n    const context = new Context().accumulate({\n      auditUser: userId,\n      auditTimestamp: new Date(),\n      skipValidation: false\n    });\n\n    // Pass the context to the create method\n    return this.create(model, context);\n  }\n}\n\n// Usage\nconst userRepo = new UserRepository();\nconst newUser = new User({ name: \"John Doe\", email: \"john@example.com\" });\nconst createdUser = await userRepo.createWithAudit(newUser, \"admin123\");\n",
      "import { Context, OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { User } from \"./models/User\";\n\n// Create a parent context\nconst parentContext = new Context().accumulate({\n  transactionId: \"tx123\",\n  batchOperation: true\n});\n\n// Create a child context for a specific operation\nconst childContext = parentContext.child<User, Context<any>>(\n  OperationKeys.CREATE,\n  User\n).accumulate({\n  operationId: \"op456\",\n  validationLevel: \"strict\"\n});\n\n// Access values from the context hierarchy\nconsole.log(childContext.get(\"transactionId\")); // \"tx123\" (inherited from parent)\nconsole.log(childContext.get(\"operationId\")); // \"op456\" (from child)\n",
      "import { User } from \"./models/User\";\nimport { UserRepository } from \"./repositories/UserRepository\";\n\nasync function userCrudExample() {\n  const userRepo = new UserRepository();\n\n  // Create a new user\n  const newUser = new User({\n    name: \"Alice Smith\",\n    email: \"alice@example.com\",\n    password: \"securePassword123\"\n  });\n  const createdUser = await userRepo.create(newUser);\n  console.log(\"Created user:\", createdUser);\n\n  // Read a user\n  const userId = createdUser.id;\n  const retrievedUser = await userRepo.read(userId);\n  console.log(\"Retrieved user:\", retrievedUser);\n\n  // Update a user\n  retrievedUser.name = \"Alice Johnson\";\n  const updatedUser = await userRepo.update(retrievedUser);\n  console.log(\"Updated user:\", updatedUser);\n\n  // Delete a user\n  const deletedUser = await userRepo.delete(userId);\n  console.log(\"Deleted user:\", deletedUser);\n}\n",
      "import { Product } from \"./models/Product\";\nimport { ProductRepository } from \"./repositories/ProductRepository\";\n\nasync function productBulkExample() {\n  const productRepo = new ProductRepository();\n\n  // Create multiple products\n  const products = [\n    new Product({ category: \"Electronics\", name: \"Laptop\", variant: \"15-inch\" }),\n    new Product({ category: \"Electronics\", name: \"Laptop\", variant: \"13-inch\" }),\n    new Product({ category: \"Electronics\", name: \"Smartphone\", variant: \"Pro\" })\n  ];\n  const createdProducts = await productRepo.createAll(products);\n  console.log(\"Created products:\", createdProducts);\n\n  // Read multiple products\n  const productIds = createdProducts.map(p => p.id);\n  const retrievedProducts = await productRepo.readAll(productIds);\n  console.log(\"Retrieved products:\", retrievedProducts);\n\n  // Update multiple products\n  const updatedProducts = retrievedProducts.map(p => {\n    p.name = p.name + \" (Updated)\";\n    return p;\n  });\n  const savedProducts = await productRepo.updateAll(updatedProducts);\n  console.log(\"Updated products:\", savedProducts);\n\n  // Delete multiple products\n  const deletedProducts = await productRepo.deleteAll(productIds);\n  console.log(\"Deleted products:\", deletedProducts);\n}\n",
      "import { Model, ModelErrorDefinition } from \"@decaf-ts/decorator-validation\";\nimport { id } from \"@decaf-ts/db-decorators\";\nimport { required, minLength, maxLength, email, pattern } from \"@decaf-ts/decorator-validation\";\n\nclass User extends Model {\n  @id()\n  id: string;\n\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  name: string;\n\n  @required()\n  @email()\n  emailAddress: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/, \n    \"Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character\")\n  password: string;\n\n  // Manual validation example\n  hasErrors(): ModelErrorDefinition | undefined {\n    const errors = super.hasErrors();\n    \n    // Add custom validation logic\n    if (this.name && this.name.includes('admin') && !this.emailAddress.includes('admin')) {\n      if (!errors) {\n        return {\n          name: [\"Admin users must have an admin email address\"]\n        };\n      }\n      errors.name = errors.name || [];\n      errors.name.push(\"Admin users must have an admin email address\");\n    }\n    \n    return errors;\n  }\n}\n\n// Usage in a repository\nclass UserRepository extends Repository<User> {\n  // ... other methods\n  \n  async create(model: User, ...args: any[]): Promise<User> {\n    // The Repository class will automatically validate the model\n    // and throw a ValidationError if validation fails\n    \n    // Custom validation can also be performed\n    const errors = model.hasErrors();\n    if (errors) {\n      throw new ValidationError(errors.toString());\n    }\n    \n    // Proceed with creation if validation passes\n    return model;\n  }\n}\n",
      "import { Model } from \"@decaf-ts/decorator-validation\";\nimport { id } from \"@decaf-ts/db-decorators\";\nimport { findPrimaryKey, findModelId } from \"@decaf-ts/db-decorators\";\n\nclass Document extends Model {\n  @id()\n  documentId: string;\n  \n  title: string;\n  content: string;\n}\n\n// Create a document instance\nconst doc = new Document({\n  documentId: \"doc-123\",\n  title: \"Sample Document\",\n  content: \"This is a sample document.\"\n});\n\n// Find the primary key property\nconst pkInfo = findPrimaryKey(doc);\nconsole.log(\"Primary key property:\", pkInfo.id); // \"documentId\"\nconsole.log(\"Primary key metadata:\", pkInfo.props);\n\n// Get the primary key value\nconst docId = findModelId(doc);\nconsole.log(\"Document ID:\", docId); // \"doc-123\"\n\n// Try to get ID from a model without an ID value\nconst emptyDoc = new Document();\ntry {\n  const id = findModelId(emptyDoc); // Will throw an error\n} catch (error) {\n  console.error(\"Error:\", error.message);\n}\n\n// Get ID with returnEmpty option\nconst emptyId = findModelId(emptyDoc, true); // Returns undefined instead of throwing\nconsole.log(\"Empty ID:\", emptyId);\n"
    ],
    "base_path": "db-decorators"
  },
  {
    "name": "transactional-decorators",
    "title": "transactional-decorators",
    "description": "### Description\n\nThe Transactional Decorators library is a standalone module that provides a robust implementation for handling concurrency and transaction management in TypeScript applications. It offers a comprehensive set of tools for ensuring data integrity and thread safety in your code.\n\n#### Core Components\n\n- **Transaction Class**: The central class that manages the lifecycle of transactions, including creation, execution, and cleanup. It provides mechanisms for binding transactions to objects and methods, ensuring proper transaction context propagation.\n\n- **Lock System**: A flexible locking mechanism for controlling access to shared resources:\n  - `Lock`: A base class providing fundamental locking capabilities with support for queuing and executing functions when the lock is available.\n  - `TransactionLock`: An interface defining the contract for transaction lock implementations that manage transaction execution order and concurrency.\n  - `SyncronousLock`: A default implementation of TransactionLock that processes transactions one at a time in the order they are submitted.\n\n- **Decorators**:\n  - `@transactional()`: A method decorator that enables transactional behavior by wrapping the original method in a transaction context that handles transaction creation, binding, and error handling.\n  - `transactionalSuperCall()`: A utility function for handling super calls in transactional methods, ensuring transaction continuity through the inheritance chain.\n\n#### Key Features\n\n- **Simple yet powerful locking**: The library provides a flexible locking system that can be customized to suit your application's needs.\n- **Method decoration with `@transactional()`**: Easily add transactional behavior to your methods with a simple decorator.\n- **Instance proxying**: The Transaction class can bind to objects, creating proxies that maintain transaction context across method calls.\n- **Transaction chaining**: Transactions can be linked together, allowing you to group multiple operations into a single atomic transaction.\n- **Customizable Transaction Lock**: You can implement your own TransactionLock to customize how transactions are processed.\n- **Error handling**: The library includes built-in error handling to ensure transactions are properly released even when errors occur.\n- **Seamless integration with `db-decorators`**: The library works well with the db-decorators package for database operations.\n\nThis library is ideal for applications that need to ensure data consistency and handle concurrent operations safely, such as database applications, financial systems, or any application where atomic operations are important.\n",
    "examples": [
      "import { transactional } from '@decaf-ts/transactional-decorators';\n\nclass UserService {\n  @transactional()\n  async createUser(userData: any): Promise<any> {\n    // This method will be executed within a transaction\n    // If an error occurs, the transaction will be released with the error\n    const user = await this.userRepository.save(userData);\n    return user;\n  }\n\n  @transactional(['custom', 'metadata'])\n  async updateUser(userId: string, userData: any): Promise<any> {\n    // You can pass custom metadata to the transaction\n    const user = await this.userRepository.findById(userId);\n    Object.assign(user, userData);\n    return await this.userRepository.save(user);\n  }\n}\n\n// Using the transactional method\nconst userService = new UserService();\nconst newUser = await userService.createUser({ name: 'John Doe' });\n",
      "import { Transaction } from '@decaf-ts/transactional-decorators';\n\n// Creating a transaction\nconst transaction = new Transaction(\n  'UserService', // Source\n  'createUser',  // Method name\n  async () => {\n    // Transaction logic here\n    const user = await userRepository.save({ name: 'John Doe' });\n    return user;\n  }\n);\n\n// Submitting the transaction for execution\nTransaction.submit(transaction);\n\n// Using the Transaction.push method for callback-style APIs\nTransaction.push(\n  userService, // The object instance\n  userService.createUserWithCallback, // The method to call\n  { name: 'John Doe' }, // Arguments\n  (err, user) => {\n    if (err) {\n      console.error('Error creating user:', err);\n      return;\n    }\n    console.log('User created:', user);\n  }\n);\n",
      "import { transactional, transactionalSuperCall } from '@decaf-ts/transactional-decorators';\n\nclass BaseRepository {\n  @transactional()\n  async save(entity: any): Promise<any> {\n    // Base save implementation\n    return entity;\n  }\n}\n\nclass UserRepository extends BaseRepository {\n  @transactional()\n  async save(user: any): Promise<any> {\n    // Pre-processing\n    user.updatedAt = new Date();\n\n    // Call the super method with transaction context\n    const result = await transactionalSuperCall(super.save.bind(this), user);\n\n    // Post-processing\n    console.log('User saved:', result);\n    return result;\n  }\n}\n",
      "import { TransactionLock, Transaction } from '@decaf-ts/transactional-decorators';\n\n// Custom transaction lock that logs transactions\nclass LoggingTransactionLock implements TransactionLock {\n  currentTransaction?: Transaction;\n  private pendingTransactions: Transaction[] = [];\n\n  submit(transaction: Transaction): void {\n    console.log(`Submitting transaction: ${transaction.toString()}`);\n\n    if (this.currentTransaction) {\n      this.pendingTransactions.push(transaction);\n      console.log(`Transaction queued. Queue length: ${this.pendingTransactions.length}`);\n    } else {\n      this.currentTransaction = transaction;\n      console.log(`Executing transaction immediately`);\n      transaction.fire();\n    }\n  }\n\n  async release(err?: Error): Promise<void> {\n    if (err) {\n      console.error(`Transaction error: ${err.message}`);\n    } else {\n      console.log(`Transaction completed successfully`);\n    }\n\n    this.currentTransaction = undefined;\n\n    if (this.pendingTransactions.length > 0) {\n      const nextTransaction = this.pendingTransactions.shift()!;\n      console.log(`Processing next transaction: ${nextTransaction.toString()}`);\n      this.currentTransaction = nextTransaction;\n      nextTransaction.fire();\n    }\n\n    return Promise.resolve();\n  }\n}\n\n// Set the custom lock as the default\nTransaction.setLock(new LoggingTransactionLock());\n",
      "import { Lock } from '@decaf-ts/transactional-decorators';\n\n// Create a lock for a shared resource\nconst resourceLock = new Lock();\n\n// Execute a function with exclusive access to the resource\nasync function accessSharedResource() {\n  const result = await resourceLock.execute(async () => {\n    // This code will run with exclusive access to the resource\n    const data = await fetchDataFromDatabase();\n    const processedData = processData(data);\n    await saveDataToDatabase(processedData);\n    return processedData;\n  });\n\n  return result;\n}\n\n// Alternatively, you can manually acquire and release the lock\nasync function manualLockHandling() {\n  await resourceLock.acquire();\n  try {\n    // Critical section with exclusive access\n    const data = await fetchDataFromDatabase();\n    const processedData = processData(data);\n    await saveDataToDatabase(processedData);\n    return processedData;\n  } finally {\n    // Always release the lock, even if an error occurs\n    resourceLock.release();\n  }\n}\n"
    ],
    "base_path": "transactional-decorators"
  },
  {
    "name": "core",
    "title": "core",
    "description": "# Core Package — Detailed Description\n\nThe Decaf Core package provides a cohesive set of primitives for building strongly-typed data-access layers in TypeScript. It centers around:\n\n- Models (from @decaf-ts/decorator-validation) enhanced with identity and persistence metadata\n- A Repository abstraction that encapsulates CRUD, querying, and observation\n- Adapters that bridge repositories to underlying storage (in-memory, HTTP, TypeORM, etc.)\n- A fluent Query DSL (Statement/Condition) with pagination\n- Lightweight dependency injection utilities to auto-resolve repositories\n\nBelow is an overview of the main modules and their public APIs exposed by core.\n\n1) Repository module\n- Repository<M>\n  - Constructor: new Repository(adapter: Adapter, clazz: Constructor<M>, ...)\n  - CRUD: create, read, update, delete\n  - Bulk ops: createAll, readAll, updateAll, deleteAll\n  - Hooks: createPrefix/createSuffix, updateAllPrefix, readAllPrefix, deleteAllPrefix (internal orchestration helpers)\n  - Query: select(...selectors?), query(condition?, orderBy?, order?, limit?, skip?)\n  - Observation: observe(observer, filter?), unObserve(observer), updateObservers(...), refresh(...)\n  - Repository registry helpers:\n    - static for(config, ...args): Proxy factory for building repositories with specific adapter config\n    - static forModel(model, alias?, ...args): returns a Repository instance or repository constructor registered for the model\n    - static get(model, alias?): low-level retrieval of a registered repository constructor\n    - static register(model, repoCtor, alias?)\n    - static getMetadata/setMetadata/removeMetadata(model)\n    - static getSequenceOptions(model)\n    - static indexes(model): reads index definitions for model\n    - static relations(model)\n    - static table(model), static column(model, attribute)\n- Decorators (repository/decorators)\n  - repository(modelCtor, flavour?):\n    - As property decorator: injects the repository instance for the annotated model\n    - As class decorator: registers the annotated class as the repository for the model; integrates with Injectables\n- Injectables registry (repository/injectables)\n  - InjectablesRegistry extends InjectableRegistryImp\n  - get<T>(name | token | ctor, flavour?): resolves a registered injectable; if not registered, attempts to infer the model and construct or fetch the appropriate repository based on adapter flavour or metadata (falling back to current adapter)\n- Types/utilities (repository/types, repository/utils)\n  - IndexMetadata, OrderDirection, generateInjectableNameForRepository, and other helpers/constants\n\n2) Persistence module\n- Adapter<N = any, Q = any, R = any, Ctx = Context>\n  - Base bridge between repository and the back-end. Offers:\n    - initialize(...), flags(...), context(...)\n    - prepare(model, pk): model -> record mapping using model metadata\n    - revert(record, clazz, pk, id, transient?): record -> model mapping\n    - CRUD: create, createAll, read, readAll, update, updateAll, delete, deleteAll\n    - raw(rawInput): pass-through for back-end specific commands\n    - Observation: observe/unObserve, updateObservers, refresh\n    - Flavour/alias management: current(), get(flavour), setCurrent(flavour), alias(), models(flavour), flavourOf(model)\n    - Factory helpers: Statement(), Dispatch(), ObserverHandler(), Sequence(options)\n    - for(config, ...args): proxy-bound adapter for a given configuration\n- Dispatch: batching/dispatch helpers used by Adapter\n- Sequence: provides identity/sequence generation based on SequenceOptions (see interfaces)\n- ObserverHandler: internal observer list and filtering logic used by repositories/adapters\n- constants, errors, types: PersistenceKeys, EventIds, ObserverFilter, etc.\n\n3) Query module\n- Statement<M extends Model>\n  - Fluent DSL to build and execute queries via the configured Adapter\n  - Methods:\n    - select(...keys?), distinct(key), count(key), max(key), min(key)\n    - from(modelCtor), where(Condition), orderBy([key, OrderDirection]), groupBy(key)\n    - limit(n), offset(n), execute(), raw(input), paginate(size)\n- Condition<M extends Model>\n  - Composable condition tree with a builder API and logical combinators\n  - Methods:\n    - and(cond), or(cond), not(cond)\n    - attribute/attr(name): switch attribute under construction\n    - hasErrors(exceptions?): validation helper\n    - group(cond1, GroupOperator, cond2)\n    - builder(): ConditionBuilder\n  - ConditionBuilder methods: eq, dif, gt, lt, gte, lte, in, regexp, build\n- Paginator<M>\n  - Abstract pagination helper returned by Statement.paginate(size)\n  - Properties: current, total, count, size\n  - Methods: page(n?), next(), previous(); requires an Adapter-specific concrete implementation\n\n4) Interfaces module\n- Observable<T>, Observer<T>: basic observer pattern primitives\n- Executor, RawExecutor: contracts for query execution\n- Queriable: minimal interface for types that can return a Statement\n- Paginatable: marks types that can paginate\n- SequenceOptions and defaults: sequence/generator configuration presets\n\n5) Model & Identity modules\n- BaseModel and supporting types: base class all models extend from\n- identity/decorators and identity/utils: helpers to derive table names, etc.\n- model/decorators: e.g., @model and other persistence-related metadata (provided by @decaf-ts/decorator-validation and enriched here)\n\n6) RAM runtime (core/src/ram)\n- RamAdapter, RamRepository, RamStatement, RamPaginator (in-memory implementations used by tests and examples)\n- Useful for local testing and reference behavior of the core abstractions.\n\nDesign intent\n- Provide a consistent, typed data access layer decoupled from any particular storage or framework\n- Allow adapters to plug into multiple backends while preserving a uniform repository and query API\n- Make querying expressive but type-safe through fluent builders and model metadata\n- Enable DI and decorators for ergonomic repository wiring and testing\n",
    "examples": [
      "import { Model, model } from \"@decaf-ts/decorator-validation\";\nimport type { ModelArg } from \"@decaf-ts/decorator-validation\";\nimport {\n  Adapter,\n  OrderDirection,\n  Paginator,\n  Repository,\n  repository,\n  uses,\n  pk,\n  column,\n  table,\n} from \"@decaf-ts/core\";\nimport { RamAdapter, RamRepository } from \"@decaf-ts/core/ram\";\n\n@table(\"tst_user\")\n@model()\nclass User extends Model {\n  @pk() id!: string;\n  @column(\"tst_name\") name!: string;\n  @column(\"tst_nif\") nif!: string;\n  constructor(arg?: ModelArg<User>) { super(arg); }\n}\n",
      "import { NotFoundError } from \"@decaf-ts/db-decorators\";\n\nasync function crudExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // CREATE\n  const created = await repo.create(\n    new User({ id: Date.now().toString(), name: \"Alice\", nif: \"123456789\" })\n  );\n\n  // READ\n  const read = await repo.read(created.id);\n  console.log(read.equals(created)); // true (same data, different instance)\n\n  // UPDATE\n  const updated = await repo.update(Object.assign(read, {name: \"Alice 2\" }));\n\n  // DELETE\n  const deleted = await repo.delete(created.id);\n  console.log(deleted.equals(updated)); // true\n}\n",
      "\n@model()\nclass Managed extends Model { constructor(arg?: ModelArg<Managed>) { super(arg); } }\n\n@repository(Managed)\n@uses(\"ram\")\nclass ManagedRepository extends Repository<Managed> {\n  // Concrete adapter-backed methods would be provided by adapter implementation\n  // For quick test or demo, use a RamAdapter\n}\n\nasync function adapterRegistryExample() {\n  const adapter = new RamAdapter();\n\n  Adapter.setCurrent(\"ram\"); // set current flavour\n  console.log(Adapter.current === Adapter.get(\"ram\")); // true\n\n  // Models managed by current or specific adapter flavour\n  const managed = Adapter.models(\"ram\");\n  console.log(Array.isArray(managed));\n}\n",
      "async function queryExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // Seed data\n  await repo.createAll(\n    Array.from({ length: 5 }).map((_, i) =>\n      new User({ id: (i + 1).toString(), name: `u${i + 1}`, nif: \"123456789\" })\n    )\n  );\n\n  const results = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.ASC])\n    .execute();\n\n  console.log(results.map((u) => u.id)); // [\"1\",\"2\",\"3\",\"4\",\"5\"]\n}\n",
      "async function paginationExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  // Seed data\n  const size = 25;\n  await repo.createAll(\n    Array.from({ length: size }).map((_, i) =>\n      new User({ id: (i + 1).toString(), name: `u${i + 1}`, nif: \"123456789\" })\n    )\n  );\n\n  const paginator: Paginator<User> = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.DSC])\n    .paginate(10);\n\n  const page1 = await paginator.page(); // first page by default\n  const page2 = await paginator.next();\n  const page3 = await paginator.next();\n\n  console.log(page1.length, page2.length, page3.length); // 10, 10, 5\n}\n",
      "import { Condition } from \"@decaf-ts/core\";\n\nasync function conditionExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  await repo.createAll([\n    new User({ id: \"1\", name: \"Alice\", nif: \"111111111\" }),\n    new User({ id: \"2\", name: \"Bob\", nif: \"222222222\" }),\n  ]);\n\n  const cond = Condition.attr<User>(\"name\")\n    .eq(\"Alice\")\n    .build();\n\n  const results = await repo.select().where(cond).execute();\n  console.log(results.length); // 1\n}\n",
      "async function mappingExample() {\n  const adapter = new RamAdapter();\n  const repo: RamRepository<User> = new Repository(adapter, User);\n\n  const toCreate = new User({ id: \"abc\", name: \"Test\", nif: \"123456789\" });\n\n  // prepare: model -> record\n  const pk = \"id\"; // infer with findPrimaryKey(toCreate).id if available\n  const { record, id } = adapter.prepare(toCreate, pk);\n  console.log(id === toCreate.id); // true\n\n  // revert: record -> model instance\n  const model = adapter.revert(record, User, pk, id) as User;\n  console.log(model instanceof User); // true\n}\n",
      "import { Injectables } from \"@decaf-ts/injectable-decorators\";\nimport { InjectablesRegistry } from \"@decaf-ts/core\";\n\nasync function injectablesExample() {\n  // Register current adapter so repositories can be created\n  new RamAdapter();\n  Adapter.setCurrent(\"ram\");\n\n  // Resolve by constructor\n  const userRepo = Injectables.get<Repository<User>>(User);\n  if (userRepo) {\n    const u = await userRepo.create(\n      new User({ id: \"1\", name: \"A\", nif: \"123456789\" })\n    );\n    console.log(!!u);\n  }\n}\n"
    ],
    "base_path": "core"
  },
  {
    "name": "for-http",
    "title": "for-http",
    "description": "# decaf-ts/for-http — Detailed Description\n\nThis package provides a small, focused HTTP integration for decaf-ts. It introduces a generic HttpAdapter abstraction that maps REST semantics (create/read/update/delete and bulk variants) onto decaf-ts repositories and services, plus minimal configuration and flags. A ready-to-use Axios adapter is included.\n\nCore goals\n- Keep HTTP concerns decoupled from models and repositories.\n- Provide a consistent CRUD surface over REST endpoints.\n- Allow custom clients (via subclassing HttpAdapter) while shipping an Axios implementation.\n- Offer simple configuration (protocol/host) and request-scoped headers via flags/context.\n\nKey building blocks\n- HttpConfig: A minimal connection config with protocol and host.\n- HttpFlags: Extends RepositoryFlags to include optional HTTP headers.\n- HttpAdapter<Y, CON, Q, F, C>:\n  - Extends the core Adapter to focus on HTTP.\n  - Adds default flags() with headers support.\n  - Provides URL building (protected url()) and error parsing (parseError()).\n  - Declares abstract request(), create(), read(), update(), delete().\n  - Declares optional/unsupported-by-default raw(), Sequence(), Statement(), parseCondition() that concrete adapters may implement if needed.\n  - repository() returns RestService as the default repository/service implementation for this adapter type.\n- RestService<M, Q, A, F, C>:\n  - Lightweight, model-centric service that delegates to the HttpAdapter for CRUD and bulk operations.\n  - Converts between model instances and plain records using adapter.prepare() and adapter.revert().\n  - Manages a list of observers (observe/unObserve/updateObservers) that can be refreshed after changes.\n- RestRepository<M, Q, A, F, C>:\n  - A Repository that works with an HttpAdapter; use it if you need decaf-ts repository decoration/logic before sending to the backend.\n  - Not the default repository for the HTTP adapter (that role is fulfilled by RestService); intended for cases where repository lifecycle logic matters.\n- AxiosHttpAdapter:\n  - Concrete implementation of HttpAdapter built on Axios.\n  - Implements request and CRUD operations using Axios.request/get/post/put/delete.\n  - Uses HttpConfig for base URL construction and inherits header flag behavior.\n\nFlow overview\n1. Instantiate a concrete adapter (e.g., AxiosHttpAdapter) with an HttpConfig.\n2. Get a repository/service for a given model (the default is RestService via adapter.getRepository(), or instantiate RestService/RestRepository directly).\n3. Call CRUD methods (create/read/update/delete) or their bulk equivalents (createAll/readAll/updateAll/deleteAll) on the service or repository. The service:\n   - Derives the table/collection name from the model’s decaf-ts metadata.\n   - Uses adapter.prepare() to serialize the model and extract its ID.\n   - Invokes the adapter’s HTTP methods.\n   - Uses adapter.revert() to rehydrate responses back into model instances.\n4. Optionally provide HttpFlags (e.g., headers) in the Context to influence requests.\n\nURL building and error handling\n- HttpAdapter.url() builds URLs as `${protocol}://${host}/${tableName}` and appends encoded query parameters when provided, ensuring spaces are encoded as %20.\n- HttpAdapter.parseError() currently returns the error unchanged (as BaseError) but is intended to be overridden/extended by concrete adapters to normalize HTTP/client errors.\n\nBulk operations\n- RestService implements createAll, readAll, updateAll, deleteAll. These delegate to similarly named adapter methods (which are expected to exist on the base Adapter implementation from @decaf-ts/core), allowing efficient batched operations where supported by the backend.\n\nUnsupported APIs by default\n- Some persistence APIs from the core (raw, Sequence, Statement, parseCondition) are not meaningful out of the box for a generic HTTP adapter, so HttpAdapter throws UnsupportedError for them. Concrete adapters targeting specific backends can choose to implement these.\n\nWhen to use RestService vs RestRepository\n- Use RestService by default for straightforward CRUD over REST endpoints.\n- Use RestRepository if you need repository-level decoration logic (e.g., hooks, rules) to run on your models before hitting the HTTP layer.\n\nExtending with another HTTP client\n- Subclass HttpAdapter and implement request(), create(), read(), update(), delete().\n- Override parseError() to translate client-specific errors to your app’s BaseError.\n- Optionally implement raw(), Sequence(), Statement(), parseCondition() if your backend/client supports those features.\n",
    "examples": [
      "import { HttpConfig, HttpFlags } from \"@decaf-ts/for-http\";\n\nconst config: HttpConfig = {\n  protocol: \"https\",\n  host: \"api.example.com\",\n};\n\n// You can pass headers via flags (typically through a Context)\nconst flags: HttpFlags = {\n  headers: {\n    Authorization: \"Bearer <token>\",\n  },\n};\n",
      "import { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\nconst config: HttpConfig = { protocol: \"https\", host: \"api.example.com\" };\nconst adapter = new AxiosHttpAdapter(config);\n",
      "import { RestService } from \"@decaf-ts/for-http\";\nimport { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\n// Example model (assumes proper decaf-ts decorations elsewhere)\nclass User {\n  id!: string;\n  name!: string;\n}\n\nconst config: HttpConfig = { protocol: \"https\", host: \"api.example.com\" };\nconst adapter = new AxiosHttpAdapter(config);\n\n// Create a service bound to the User model\nconst users = new RestService<User, any, typeof adapter>(adapter, User);\n\n// Create\nconst created = await users.create({ id: \"u1\", name: \"Alice\" } as User);\n\n// Read\nconst found = await users.read(\"u1\");\n\n// Update\nconst updated = await users.update({ id: \"u1\", name: \"Alice Cooper\" } as User);\n\n// Delete\nconst removed = await users.delete(\"u1\");\n\n// Bulk create\nconst many = await users.createAll([\n  { id: \"u2\", name: \"Bob\" } as User,\n  { id: \"u3\", name: \"Carol\" } as User,\n]);\n\n// Bulk read\nconst foundMany = await users.readAll([\"u2\", \"u3\"]);\n\n// Bulk update\nconst updatedMany = await users.updateAll([\n  { id: \"u2\", name: \"Bobby\" } as User,\n  { id: \"u3\", name: \"Caroline\" } as User,\n]);\n\n// Bulk delete\nconst removedMany = await users.deleteAll([\"u2\", \"u3\"]);\n",
      "import { RestRepository } from \"@decaf-ts/for-http\";\nimport { AxiosHttpAdapter } from \"@decaf-ts/for-http/axios\";\nimport { HttpConfig } from \"@decaf-ts/for-http\";\n\nclass Product {\n  id!: number;\n  title!: string;\n}\n\nconst cfg: HttpConfig = { protocol: \"https\", host: \"store.example.com\" };\nconst http = new AxiosHttpAdapter(cfg);\n\n// Create a repository for Product\nconst products = new RestRepository<Product, any, typeof http>(http, Product);\n\n// Typical repository interactions\nconst p = await products.findById(101);\n// ... other repository APIs as provided by @decaf-ts/core Repository\n",
      "import { Context } from \"@decaf-ts/db-decorators\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { AxiosHttpAdapter, AxiosFlags } from \"@decaf-ts/for-http/axios\";\nimport { RestService } from \"@decaf-ts/for-http\";\n\nclass User { id!: string; name!: string; }\n\nconst adapter = new AxiosHttpAdapter({ protocol: \"https\", host: \"api.example.com\" });\nconst users = new RestService<User, any, typeof adapter>(adapter, User);\n\n// Generate flags for a READ operation (adds an empty headers obj you can override)\nconst flags = adapter.flags<User>(OperationKeys.READ, User, { headers: { Authorization: \"Bearer <token>\" } });\n\n// Place flags into a context (shape depends on @decaf-ts/db-decorators; we cast here for example purposes)\nconst ctx = { flags } as unknown as Context<AxiosFlags>;\n\n// Many decaf-ts operations accept an optional context/flags as the last argument\nconst user = await users.read(\"u1\", ctx);\n",
      "import { HttpAdapter, HttpConfig, HttpFlags } from \"@decaf-ts/for-http\";\nimport { Context } from \"@decaf-ts/db-decorators\";\n\n// Hypothetical client types\ntype MyClient = { request: <T>(config: any) => Promise<T>; get: <T>(url: string) => Promise<T>; post: <T>(url: string, body: any) => Promise<T>; put: <T>(url: string, body: any) => Promise<T>; delete: <T>(url: string) => Promise<T>; };\n\ntype MyRequestConfig = { url: string; method: \"GET\"|\"POST\"|\"PUT\"|\"DELETE\"; data?: any; headers?: Record<string,string>; };\n\ntype MyFlags = HttpFlags;\n\ntype MyContext = Context<MyFlags>;\n\nclass MyHttpAdapter extends HttpAdapter<HttpConfig, MyClient, MyRequestConfig, MyFlags, MyContext> {\n  constructor(config: HttpConfig, alias?: string) { super(config, \"my-client\", alias); }\n\n  protected override getClient(): MyClient {\n    // create and return your HTTP client instance\n    return {\n      request: async <T>(c: any) => ({} as T),\n      get: async <T>(url: string) => ({} as T),\n      post: async <T>(url: string, body: any) => ({} as T),\n      put: async <T>(url: string, body: any) => ({} as T),\n      delete: async <T>(url: string) => ({} as T),\n    };\n  }\n\n  override async request<V>(details: MyRequestConfig): Promise<V> {\n    // bridge to your client’s request API\n    return this.client.request<V>(details);\n  }\n\n  async create(table: string, id: string|number, model: Record<string, any>): Promise<Record<string, any>> {\n    const url = this.url(table);\n    return this.client.post(url, model);\n  }\n\n  async read(table: string, id: string|number|bigint): Promise<Record<string, any>> {\n    const url = this.url(table, { id: id as string|number });\n    return this.client.get(url);\n  }\n\n  async update(table: string, id: string|number, model: Record<string, any>): Promise<Record<string, any>> {\n    const url = this.url(table);\n    return this.client.put(url, model);\n  }\n\n  async delete(table: string, id: string|number|bigint): Promise<Record<string, any>> {\n    const url = this.url(table, { id: id as string|number });\n    return this.client.delete(url);\n  }\n\n  // Optionally override parseError(err) to normalize client-specific errors\n}\n",
      "import { AxiosFlavour, AxiosFlags } from \"@decaf-ts/for-http/axios\";\n\n// AxiosFlavour is the adapter flavour identifier string: \"axios\"\nconsole.log(AxiosFlavour);\n\n// AxiosFlags is a type alias of HttpFlags; useful for contexts with Axios\nconst f: AxiosFlags = { headers: { \"X-Trace\": \"1\" } };\n"
    ],
    "base_path": "for-http"
  },
  {
    "name": "ui-decorators",
    "title": "ui-decorators",
    "description": "### Description\n\nThe UI Decorators library is an extension of `@decaf-ts/decorator-validation` and `@decaf-ts/db-decorators` that provides a comprehensive framework for automatic model rendering in user interfaces. It enables a declarative approach to UI development by allowing developers to define how their data models should be rendered directly on the model classes and properties.\n\n#### Core Functionality\n\n- **Model Rendering**: Extends the Model class with the ability to render itself as a UI component\n- **Flexible Rendering Engine**: Provides an abstract RenderingEngine class that can be implemented for different UI frameworks\n- **Validation Integration**: Automatically applies validation rules from `@decaf-ts/decorator-validation` to UI elements\n- **CRUD Operation Support**: Controls element visibility and behavior based on the current CRUD operation (Create, Read, Update, Delete)\n- **List Rendering**: Special support for rendering collections of models as lists with customizable item templates\n\n#### Class Decorators\n\n- **`@uimodel(tag?, props?)`**: Marks a class as a UI model and specifies how it should be rendered, including the HTML tag to use and additional properties\n- **`@renderedBy(engine)`**: Specifies which rendering engine implementation should be used for a particular model\n- **`@uilistitem(tag?, props?)`**: Defines how a model should be rendered when it appears as an item in a list\n\n#### Property Decorators\n\n- **`@uiprop(propName?, stringify?)`**: Maps a model property to a UI component property, optionally with a different name or stringified\n- **`@uielement(tag, props?, serialize?)`**: Maps a model property to a specific UI element with custom properties\n- **`@uilistprop(propName?, props?)`**: Maps a model property containing a list to a list container component\n- **`@hideOn(...operations)`**: Hides a property during specific CRUD operations\n- **`@hidden()`**: Completely hides a property in all UI operations\n\n#### Rendering Engine\n\nThe abstract `RenderingEngine` class provides the foundation for implementing rendering strategies for different UI frameworks:\n\n- **Type Translation**: Converts between model types and HTML input types\n- **Validation Handling**: Applies validation rules from the model to UI elements\n- **Field Definition Generation**: Converts model metadata into UI field definitions\n- **Engine Management**: Registers and retrieves rendering engine implementations\n- **Extensibility**: Can be extended to support any UI framework or rendering strategy\n\n#### Integration with Validation\n\nThe library seamlessly integrates with the validation system from `@decaf-ts/decorator-validation`, automatically applying validation rules to UI elements:\n\n- Required fields\n- Minimum and maximum values\n- Minimum and maximum length\n- Pattern matching\n- Type-specific validation (email, URL, date, password)\n- Custom validation rules\n\nThis integration ensures that UI components not only display data correctly but also enforce the same validation rules defined in the model.\n",
    "examples": [
      "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel()\nclass UserProfile extends Model {\n  @attribute()\n  @uielement('input', { type: 'text', placeholder: 'Enter your name' })\n  name: string;\n\n  @attribute()\n  @uielement('input', { type: 'email', placeholder: 'Enter your email' })\n  email: string;\n}\n\n// Create an instance\nconst user = new UserProfile();\nuser.name = 'John Doe';\nuser.email = 'john@example.com';\n\n// Render the model (the actual rendering depends on the registered rendering engine)\nconst renderedUI = user.render();\n",
      "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('div', { class: 'user-card', style: 'border: 1px solid #ccc; padding: 16px;' })\nclass UserCard extends Model {\n  @attribute()\n  @uielement('h2', { class: 'user-name' })\n  name: string;\n\n  @attribute()\n  @uielement('p', { class: 'user-bio' })\n  bio: string;\n}\n",
      "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, renderedBy, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel()\n@renderedBy('react')\nclass ReactComponent extends Model {\n  @attribute()\n  @uielement('input', { type: 'text' })\n  title: string;\n}\n",
      "import { Model, attribute, required, minLength, maxLength } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('form')\nclass LoginForm extends Model {\n  @attribute()\n  @required()\n  @minLength(3)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'Username', \n    class: 'form-control' \n  })\n  username: string;\n\n  @attribute()\n  @required()\n  @minLength(8)\n  @uielement('input', { \n    type: 'password', \n    placeholder: 'Password', \n    class: 'form-control' \n  })\n  password: string;\n\n  @attribute()\n  @uielement('button', { \n    type: 'submit', \n    class: 'btn btn-primary' \n  })\n  submitButton: string = 'Login';\n}\n",
      "import { Model, attribute } from '@decaf-ts/decorator-validation';\nimport { uimodel, uiprop } from '@decaf-ts/ui-decorators';\n\n@uimodel('user-profile-component')\nclass UserProfile extends Model {\n  @attribute()\n  @uiprop() // Will be passed as 'fullName' to the component\n  fullName: string;\n\n  @attribute()\n  @uiprop('userEmail') // Will be passed as 'userEmail' to the component\n  email: string;\n\n  @attribute()\n  @uiprop('userData', true) // Will be passed as stringified JSON\n  userData: Record<string, any>;\n}\n",
      "import { Model } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement, hideOn, hidden } from '@decaf-ts/ui-decorators';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\n\n@uimodel()\nclass User extends Model {\n  @uielement('input', { type: 'text' })\n  username: string;\n\n  @uielement('input', { type: 'password' })\n  @hideOn(OperationKeys.READ) // Hide during READ operations\n  password: string;\n\n  @uielement('input', { type: 'text' })\n  @hidden() // Completely hidden in all operations\n  internalId: string;\n}\n",
      "import { Model, list } from '@decaf-ts/decorator-validation';\nimport { uimodel, uilistitem, uilistprop, uielement } from '@decaf-ts/ui-decorators';\n\n// Define a list item model\n@uimodel()\n@uilistitem('li', { class: 'todo-item' })\nclass TodoItem extends Model {\n  @uielement('span', { class: 'todo-text' })\n  text: string;\n\n  @uielement('input', { type: 'checkbox' })\n  completed: boolean;\n}\n\n// Define a list container model\n@uimodel('div', { class: 'todo-app' })\nclass TodoList extends Model {\n  @uielement('h1')\n  title: string = 'My Todo List';\n\n  @list(TodoItem)\n  @uilistprop('items', { class: 'todo-items-container' })\n  items: TodoItem[];\n}\n\n// Usage\nconst todoList = new TodoList();\ntodoList.items = [\n  new TodoItem({ text: 'Learn TypeScript', completed: true }),\n  new TodoItem({ text: 'Build a UI with decorators', completed: false })\n];\n\nconst renderedList = todoList.render();\n",
      "import { Model } from '@decaf-ts/decorator-validation';\nimport { RenderingEngine, FieldDefinition } from '@decaf-ts/ui-decorators';\n\n// Define the output type for your rendering engine\ntype ReactElement = any; // Replace with actual React element type\n\n// Create a custom rendering engine for React\nclass ReactRenderingEngine extends RenderingEngine<ReactElement> {\n  constructor() {\n    super('react'); // Specify the engine flavor\n  }\n\n  // Initialize the engine (required abstract method)\n  async initialize(...args: any[]): Promise<void> {\n    // Import React or perform any other initialization\n    this.initialized = true;\n  }\n\n  // Implement the render method (required abstract method)\n  render<M extends Model>(\n    model: M,\n    globalProps: Record<string, unknown> = {},\n    ...args: any[]\n  ): ReactElement {\n    // Convert the model to a field definition\n    const fieldDef = this.toFieldDefinition(model, globalProps);\n\n    // Convert the field definition to a React element\n    return this.createReactElement(fieldDef);\n  }\n\n  // Helper method to create React elements\n  private createReactElement(fieldDef: FieldDefinition<ReactElement>): ReactElement {\n    // Implementation would use React.createElement or JSX\n    // This is just a placeholder\n    return {\n      type: fieldDef.tag,\n      props: {\n        ...fieldDef.props,\n        children: fieldDef.children?.map(child => this.createReactElement(child))\n      }\n    };\n  }\n}\n\n// Register the custom rendering engine\nnew ReactRenderingEngine();\n\n// Now models can specify to use this engine\n@uimodel()\n@renderedBy('react')\nclass ReactComponent extends Model {\n  // ...\n}\n",
      "import { Model, required, email, minLength, pattern } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement } from '@decaf-ts/ui-decorators';\n\n@uimodel('form', { class: 'registration-form' })\nclass RegistrationForm extends Model {\n  @required()\n  @minLength(3)\n  @uielement('input', { type: 'text', placeholder: 'Username' })\n  username: string;\n\n  @required()\n  @email()\n  @uielement('input', { type: 'email', placeholder: 'Email' })\n  email: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d).*$/) // Requires lowercase, uppercase, and digit\n  @uielement('input', { type: 'password', placeholder: 'Password' })\n  password: string;\n\n  // Validation will be automatically applied to the rendered UI elements\n}\n",
      "import { Model, attribute, required, email, minLength, maxLength, pattern } from '@decaf-ts/decorator-validation';\nimport { uimodel, uielement, renderedBy } from '@decaf-ts/ui-decorators';\n\n@uimodel('form', { class: 'registration-form', id: 'user-registration' })\n@renderedBy('html5') // Use the HTML5 rendering engine\nclass UserRegistration extends Model {\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'First Name',\n    class: 'form-control'\n  })\n  firstName: string;\n\n  @required()\n  @minLength(2)\n  @maxLength(50)\n  @uielement('input', { \n    type: 'text', \n    placeholder: 'Last Name',\n    class: 'form-control'\n  })\n  lastName: string;\n\n  @required()\n  @email()\n  @uielement('input', { \n    type: 'email', \n    placeholder: 'Email Address',\n    class: 'form-control'\n  })\n  email: string;\n\n  @required()\n  @minLength(8)\n  @pattern(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$/)\n  @uielement('input', { \n    type: 'password', \n    placeholder: 'Password (min 8 chars, include uppercase, lowercase, number, and special char)',\n    class: 'form-control'\n  })\n  password: string;\n\n  @required()\n  @uielement('select', { class: 'form-control' })\n  country: string;\n\n  @attribute()\n  @uielement('textarea', { \n    placeholder: 'Tell us about yourself',\n    class: 'form-control',\n    rows: 4\n  })\n  bio: string;\n\n  @uielement('input', { \n    type: 'checkbox',\n    class: 'form-check-input'\n  })\n  acceptTerms: boolean = false;\n\n  @uielement('button', { \n    type: 'submit',\n    class: 'btn btn-primary'\n  })\n  submitButton: string = 'Register';\n}\n\n// Create an instance\nconst registration = new UserRegistration();\n\n// Render the form\nconst form = registration.render();\n\n// Check for validation errors\nconst errors = registration.hasErrors();\nif (errors) {\n  console.error('Validation errors:', errors);\n}\n"
    ],
    "base_path": "ui-decorators"
  },
  {
    "name": "cli",
    "title": "cli",
    "description": "### Description\n\nThe Decaf-ts CLI is a powerful and extensible command-line interface framework designed to provide a unified entry point for all Decaf-ts modules. It enables developers to create modular CLI commands that can be discovered and executed through a single command-line tool.\n\n#### Core Components\n\n1. **CliWrapper**: The central class that manages the discovery, loading, and execution of CLI modules. It:\n   - Crawls the filesystem to find CLI module files\n   - Dynamically loads modules using JavaScript's import system\n   - Registers commands with Commander.js\n   - Provides a simple API for running commands\n\n2. **CLIUtils**: A utility class that provides helper methods for:\n   - Loading modules from files\n   - Normalizing imports between ESM and CommonJS formats\n   - Retrieving package information (name, version)\n   - Initializing Commander.js commands\n\n3. **CLI Module System**: A standardized way for Decaf-ts packages to expose CLI functionality:\n   - Modules are discovered by filename (cli-module.js)\n   - Each module exports a function that returns a Commander.js Command object\n   - Modules can define their own subcommands and options\n\n#### Key Features\n\n- **Dynamic Discovery**: Automatically finds CLI modules in the project and its dependencies\n- **Modular Architecture**: Each module can define its own commands independently\n- **Extensible**: New commands can be added without modifying the core CLI code\n- **Unified Interface**: All commands are accessible through the single `decaf` command\n- **Self-documenting**: Leverages Commander.js to provide help text and usage information\n\n#### Technical Details\n\nThe CLI uses a recursive filesystem crawler to find modules up to a configurable depth. It handles both ESM and CommonJS module formats, making it compatible with various JavaScript environments. The command structure follows the pattern:\n\n```\ndecaf <module> <command> [options]\n```\n\nWhere `<module>` is the name of a Decaf-ts module and `<command>` is a specific command provided by that module.\n",
    "examples": [
      "decaf <module> <command> [options]\n",
      "# Get general help\nnpx decaf help\n\n# List all available modules\nnpx decaf list\n\n# Get help for a specific module\nnpx decaf help <module-name>\n\n# Run a command from a specific module\nnpx decaf <module-name> <command> [options]\n",
      "import { Command } from \"commander\";\n\nexport default function myModule(): Command {\n  return new Command()\n    .command(\"hello <name>\")\n    .description(\"Say hello to someone\")\n    .action((name: string) => {\n      console.log(`Hello, ${name}!`);\n    });\n}\n",
      "// tsconfig.cli.json\n{\n  \"extends\": \"./tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist/cli\"\n  },\n  \"include\": [\"src/cli-module.ts\"]\n}\n",
      "\"scripts\": {\n  \"build:cli\": \"tsc --project tsconfig.cli.json\"\n}\n",
      "import { CliWrapper } from \"@decaf-ts/cli\";\n\n// Create a new CLI wrapper with custom options\nconst cli = new CliWrapper(\"./src\", 2);\n\n// Run the CLI with custom arguments\ncli.run(process.argv)\n  .then(() => {\n    console.log(\"CLI commands executed successfully\");\n  })\n  .catch((error) => {\n    console.error(\"Error executing CLI commands:\", error);\n  });\n",
      "import { CLIUtils } from \"@decaf-ts/cli\";\nimport { Command } from \"commander\";\n\n// Initialize a Command object with package information\nconst command = new Command();\nCLIUtils.initialize(command, \"./path/to/package\");\n\n// Get package information\nconst version = CLIUtils.packageVersion(\"./path/to/package\");\nconst name = CLIUtils.packageName(\"./path/to/package\");\n\n// Load a CLI module from a file\nconst modulePath = \"./path/to/cli-module.js\";\nCLIUtils.loadFromFile(modulePath)\n  .then((module) => {\n    const command = module();\n    console.log(\"Loaded command:\", command.name());\n  })\n  .catch((error) => {\n    console.error(\"Error loading module:\", error);\n  });\n",
      "// Run the demo command\nnpx decaf demo command \"hello world\"\n\n// Output:\n// executed demo command with type variable: hello world\n"
    ],
    "base_path": "cli"
  },
  {
    "name": "for-couchdb",
    "title": "for-couchdb",
    "description": "### Description\n\nThe Decaf CouchDB Module is a versatile persistence layer designed to provide seamless integration between the Decaf.ts framework and CouchDB databases. It offers a comprehensive set of tools and abstractions that simplify working with CouchDB's unique features while maintaining type safety and following best practices.\n\n#### Core Components\n\n1. **CouchDBAdapter**: An abstract base class that provides the foundation for CouchDB database operations. It handles CRUD operations, sequence management, and error handling. Developers can extend this class to create custom adapters tailored to their specific needs.\n\n2. **Query System**: A powerful query builder with support for CouchDB's Mango queries:\n   - **CouchDBStatement**: Provides a fluent interface for building type-safe Mango queries\n   - **CouchDBPaginator**: Implements pagination for query results using CouchDB's bookmark system\n   - **Operator Translation**: Converts Decaf.ts core operators to CouchDB Mango operators\n\n3. **Indexing**: Tools for creating and managing CouchDB indexes:\n   - **Index Generation**: Automatically generates appropriate index configurations based on model metadata\n   - **Index Management**: Utilities for creating and maintaining indexes\n\n4. **Sequence Management**: A robust system for generating sequential IDs:\n   - **CouchDBSequence**: Implements the Sequence interface for CouchDB\n   - **Sequence Model**: Provides a data model for storing sequence information\n\n5. **Error Handling**: Specialized error types and utilities for handling CouchDB-specific errors:\n   - **Error Translation**: Converts CouchDB error codes and messages to appropriate Decaf.ts error types\n   - **IndexError**: Specialized error for index-related issues\n\n6. **Utilities**: Helper functions for common CouchDB operations:\n   - **Authentication**: Functions for handling CouchDB authentication\n   - **Connection Management**: Utilities for managing database connections\n   - **Document Processing**: Tools for processing CouchDB documents\n\nThis module serves as a bridge between your application and CouchDB, abstracting away the complexities of the database while providing a type-safe, consistent API that integrates seamlessly with the rest of the Decaf.ts ecosystem.\n",
    "examples": [
      "import { CouchDBAdapter } from '@decaf-ts/for-couchdb';\nimport { Constructor, Model } from '@decaf-ts/decorator-validation';\nimport { MangoQuery } from '@decaf-ts/for-couchdb';\nimport { generateIndexes } from '@decaf-ts/for-couchdb';\nimport * as nano from 'nano';\n\n// Define your scope, flags, and context types\ninterface MyScope {\n  config: {\n    couchdb: {\n      url: string;\n      username: string;\n      password: string;\n      database: string;\n    }\n  }\n}\n\nclass MyCouchDBAdapter extends CouchDBAdapter<MyScope, MyFlags, MyContext> {\n  private db: any;\n\n  constructor(scope: MyScope) {\n    super(scope, 'my-couchdb', 'my-alias');\n\n    // Initialize connection to CouchDB\n    const { url, username, password, database } = scope.config.couchdb;\n    const connection = nano(url);\n    this.db = wrapDocumentScope(connection, database, username, password);\n  }\n\n  // Implement abstract methods\n  async index<M extends Model>(...models: Constructor<M>[]): Promise<void> {\n    const indexes = generateIndexes(models);\n    for (const index of indexes) {\n      try {\n        await this.db.createIndex(index);\n      } catch (error) {\n        throw this.parseError(error);\n      }\n    }\n  }\n\n  async raw<R>(rawInput: MangoQuery, docsOnly: boolean): Promise<R> {\n    try {\n      const result = await this.db.find(rawInput);\n      return docsOnly ? result.docs : result;\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async create(tableName: string, id: string | number, model: Record<string, any>, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const result = await this.db.insert(model);\n      return this.assignMetadata(model, result.rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async read(tableName: string, id: string | number, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const docId = this.generateId(tableName, id);\n      const doc = await this.db.get(docId);\n      return this.assignMetadata(doc, doc._rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async update(tableName: string, id: string | number, model: Record<string, any>, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const result = await this.db.insert(model);\n      return this.assignMetadata(model, result.rev);\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n\n  async delete(tableName: string, id: string | number, ...args: any[]): Promise<Record<string, any>> {\n    try {\n      const docId = this.generateId(tableName, id);\n      const doc = await this.db.get(docId);\n      const result = await this.db.destroy(docId, doc._rev);\n      return { id, _deleted: true };\n    } catch (error) {\n      throw this.parseError(error);\n    }\n  }\n}\n",
      "import { model, required, validate } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk, index, table } from '@decaf-ts/core';\n\n@table('users')\n@model()\nexport class User extends BaseModel {\n  @pk()\n  id!: string;\n\n  @required()\n  @index()\n  email!: string;\n\n  @required()\n  firstName!: string;\n\n  @required()\n  lastName!: string;\n\n  @index()\n  age?: number;\n\n  constructor(data?: Partial<User>) {\n    super(data);\n  }\n}\n",
      "import { Repository } from '@decaf-ts/core';\nimport { CouchDBRepository } from '@decaf-ts/for-couchdb';\nimport { User } from './models/User';\nimport { MyCouchDBAdapter } from './adapters/MyCouchDBAdapter';\n\n// Get the adapter instance\nconst adapter = new MyCouchDBAdapter(myScope);\n\n// Create a repository for the User model\nconst userRepository: CouchDBRepository<User, MyScope, MyFlags, MyContext> = \n  Repository.forModel(User, adapter.flavour);\n",
      "// Create a new user\nconst newUser = new User({\n  id: '123',\n  email: 'john.doe@example.com',\n  firstName: 'John',\n  lastName: 'Doe',\n  age: 30\n});\n\n// Create\nconst createdUser = await userRepository.create(newUser);\n\n// Read\nconst user = await userRepository.read('123');\n\n// Update\nuser.age = 31;\nconst updatedUser = await userRepository.update(user);\n\n// Delete\nawait userRepository.delete('123');\n",
      "import { Condition } from '@decaf-ts/core';\n\n// Create a statement\nconst statement = adapter.Statement<User>();\n\n// Build a query to find users older than 25, sorted by lastName\nconst users = await statement\n  .from(User)\n  .where(Condition.attribute<User>('age').gt(25))\n  .orderBy('lastName', 'asc')\n  .limit(10)\n  .execute<User[]>();\n\n// Query with multiple conditions\nconst johnDoes = await statement\n  .from(User)\n  .where(\n    Condition.and(\n      Condition.attribute<User>('lastName').eq('Doe'),\n      Condition.attribute<User>('age').gt(18)\n    )\n  )\n  .execute<User[]>();\n\n// Select specific fields\nconst userEmails = await statement\n  .from(User)\n  .select(['email', 'firstName'])\n  .where(Condition.attribute<User>('age').gt(25))\n  .execute<Array<Pick<User, 'email' | 'firstName'>>>();\n",
      "// Create a paginator\nconst paginator = await adapter\n  .Statement<User>()\n  .from(User)\n  .where(Condition.attribute<User>('age').gt(18))\n  .orderBy('lastName', 'asc')\n  .paginate<User[]>(10); // 10 items per page\n\n// Get the first page\nconst page1 = await paginator.page(1);\n\n// Get the next page\nconst page2 = await paginator.page(2);\n",
      "import { SequenceOptions } from '@decaf-ts/core';\n\n// Create a sequence\nconst sequenceOptions: SequenceOptions = {\n  name: 'user-sequence',\n  startWith: 1000,\n  incrementBy: 1,\n  type: 'Number'\n};\n\nconst sequence = await adapter.Sequence(sequenceOptions);\n\n// Get the next value\nconst nextId = await sequence.next();\n\n// Get a range of values\nconst idRange = await sequence.range(5); // Returns 5 sequential IDs\n",
      "import { generateIndexDoc } from '@decaf-ts/for-couchdb';\n\n// Generate an index configuration\nconst indexConfig = generateIndexDoc(\n  'email',     // attribute\n  'users',     // tableName\n  ['firstName'], // compositions\n  'asc'        // order\n);\n\n// Create the index\nawait adapter.db.createIndex(indexConfig);\n\n// Initialize indexes for all models\nawait adapter.initialize();\n",
      "import { IndexError, ConflictError, NotFoundError } from '@decaf-ts/for-couchdb';\n\ntry {\n  // Some operation that might fail\n  await userRepository.read('non-existent-id');\n} catch (error) {\n  if (error instanceof NotFoundError) {\n    console.error('Document not found:', error.message);\n  } else if (error instanceof ConflictError) {\n    console.error('Document conflict:', error.message);\n  } else if (error instanceof IndexError) {\n    console.error('Index error:', error.message);\n  } else {\n    console.error('Unexpected error:', error);\n  }\n}\n",
      "import { MangoQuery } from '@decaf-ts/for-couchdb';\n\n// Define a raw Mango query\nconst rawQuery: MangoQuery = {\n  selector: {\n    '??table': 'users',\n    age: { $gt: 25 },\n    lastName: { $eq: 'Doe' }\n  },\n  fields: ['_id', 'firstName', 'lastName', 'email'],\n  sort: [{ lastName: 'asc' }],\n  limit: 20\n};\n\n// Execute the raw query\nconst results = await adapter.raw(rawQuery, true);\n",
      "import { reAuth, wrapDocumentScope, generateIndexName } from '@decaf-ts/for-couchdb';\n\n// Re-authenticate a connection\nawait reAuth(connection, 'username', 'password');\n\n// Wrap a document scope with automatic re-authentication\nconst db = wrapDocumentScope(connection, 'my-database', 'username', 'password');\n\n// Generate an index name\nconst indexName = generateIndexName('email', 'users', ['firstName'], 'asc');\n"
    ],
    "base_path": "for-couchdb"
  },
  {
    "name": "for-nano",
    "title": "for-nano",
    "description": "### Description\n\nThis package integrates CouchDB via the Nano client into the decaf-ts data stack. It exposes a focused set of primitives that make CouchDB usage consistent with other decaf-ts backends (TypeORM, HTTP, Pouch, etc.), while retaining Nano’s flexibility.\n\nCore elements and their intents:\n\n- NanoAdapter\n  - Bridges decaf-ts Repository operations with Nano’s DocumentScope API.\n  - Implements repository-friendly CRUD: create, read, update, delete, plus bulk variants (createAll, readAll, updateAll, deleteAll).\n  - Preserves and manages CouchDB revision metadata transparently via PersistenceKeys.METADATA and CouchDBKeys.REV.\n  - Provides raw Mango query capability (raw) and index management (index).\n  - Offers connection and administration helpers: connect, createDatabase, deleteDatabase, createUser, deleteUser.\n  - Exposes Dispatch() to construct a NanoDispatch for change feed observation.\n  - Normalizes operation flags via flags(), ensuring user context is propagated from NanoFlags to the underlying operations.\n\n- NanoDispatch\n  - A Dispatch implementation that subscribes to CouchDB’s continuous changes feed through Nano.\n  - Parses change feed frames, groups them by table and operation (CREATE/UPDATE/DELETE), and notifies observers through updateObservers.\n  - Handles reconnection attempts and keeps track of the last processed update step (observerLastUpdate) for resilience.\n\n- NanoRepository\n  - A typed alias that binds Repository to the Nano-specific types: MangoQuery, NanoAdapter, NanoFlags, and Context.\n  - Enables consumers to use a familiar Repository API with CouchDB when paired with NanoAdapter.\n\n- Types and constants\n  - NanoFlags extends RepositoryFlags with a required user object (name, roles?) for consistent auth context propagation.\n  - NanoConfig captures the minimal connection shape (user, password, host, dbName) for setting up adapters.\n  - NanoFlavour identifies this backend for selection in multi-backend setups.\n  - VERSION exposes the package version string.\n\nDesign considerations:\n\n- Predictable metadata management: CouchDB’s _rev is captured in internal metadata, avoiding accidental leakage into domain models.\n- Bulk operations are error-aware: mixed success/failure responses are aggregated and surfaced as InternalError, preserving the failing reasons from Nano.\n- Testability: All core behaviors (CRUD, bulk, raw, admin helpers, dispatch) are covered by unit tests and written to be easily mocked.\n- Interop-first: Reuses shared types from @decaf-ts/for-couchdb (e.g., MangoQuery, CouchDBKeys) so that query building and index generation are consistent across CouchDB-based adapters.\n\n",
    "examples": [
      "import {\n  BaseModel,\n  Repository,\n  pk,\n  uses,\n} from \"@decaf-ts/core\";\nimport { model, Model, ModelArg, required } from \"@decaf-ts/decorator-validation\";\nimport type { NanoRepository } from \"@decaf-ts/for-nano\";\n\n@uses(\"nano\")\n@model()\nclass UserModel extends BaseModel implements Model {\n  @pk({ type: \"String\" })\n  id!: string; // primary key\n\n  @required()\n  name!: string;\n\n  constructor(arg?: ModelArg<UserModel>) {\n    super(arg);\n  }\n}\n\nconst repo: NanoRepository<UserModel> = Repository.forModel<UserModel, NanoRepository<UserModel>>(UserModel);\n",
      "import type { NanoFlags } from \"@decaf-ts/for-nano\";\n\nconst flags: NanoFlags = {\n  user: { name: \"tester\", roles: [\"writer\"] },\n};\n",
      "import { PersistenceKeys } from \"@decaf-ts/core\";\n\nconst created = await repo.create(new UserModel({ id: \"user:1\", name: \"Ada\" }));\n// created[PersistenceKeys.METADATA] contains the new revision string, e.g., \"1-a\"\n\nconst loaded = await repo.read(\"user:1\");\nconsole.log(loaded.name);\n",
      "const users = [\n  new UserModel({ id: \"user:2\", name: \"Lin\" }),\n  new UserModel({ id: \"user:3\", name: \"Grace\" }),\n];\nconst createdMany = await repo.createAll(users);\n\nconst fetchedMany = await repo.readAll([\"user:2\", \"user:3\"]);\n",
      "let u = await repo.read(\"user:1\");\n// ... mutate\nu.name = \"Ada Lovelace\";\n// u already has PersistenceKeys.METADATA from read()\nu = await repo.update(u);\n\n// Bulk update requires each model to carry its matching metadata\nconst u2 = await repo.read(\"user:2\");\nconst u3 = await repo.read(\"user:3\");\nconst updatedMany = await repo.updateAll([u2, u3]);\n",
      "const deleted = await repo.delete(\"user:3\");\n\nconst deletedMany = await repo.deleteAll([\"user:1\", \"user:2\"]);\n",
      "import { Condition, OrderDirection } from \"@decaf-ts/core\";\n\n// Select all as full UserModel objects\nconst all = await repo.select().execute();\n\n// Select only specific attributes\nconst projected = await repo.select([\"name\"]).execute();\n\n// Conditional queries\nconst nameEq = Condition.attribute<UserModel>(\"name\").eq(\"Ada Lovelace\");\nconst named = await repo.select().where(nameEq).execute();\n\n// Ordering (requires proper indexes configured for CouchDB)\nconst ordered = await repo.select().orderBy([\"name\", OrderDirection.ASC]).execute();\n",
      "import type { Observer } from \"@decaf-ts/core\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\n\nconst observer: Observer = {\n  async refresh(table: string, operation: OperationKeys | string, ids: string[]) {\n    if (operation.toString() === OperationKeys.DELETE.toString()) {\n      console.log(`Deleted from ${table}:`, ids);\n    }\n  },\n};\n\nawait repo.observe(observer);\n// ... later\nawait repo.unObserve(observer);\n",
      "import { NanoFlavour } from \"@decaf-ts/for-nano\";\nconsole.log(NanoFlavour); // \"nano\"\n",
      "import type { NanoRepository } from \"@decaf-ts/for-nano\";\nimport type { Model } from \"@decaf-ts/decorator-validation\";\n\nclass MyModel implements Model {\n  _id!: string;\n}\n\nlet myRepo!: NanoRepository<MyModel>;\n",
      "import { VERSION } from \"@decaf-ts/for-nano\";\nconsole.log(\"for-nano version:\", VERSION);\n",
      "import { NanoAdapter } from \"@decaf-ts/for-nano\";\n\n// Build a Nano (CouchDB) connection\nconst url = NanoAdapter.connect(\"admin\", \"secret\", \"localhost:5984\", \"http\");\n\n// Ensure a database exists / manage users\nawait NanoAdapter.createDatabase(url, \"mydb\");\n// ... createUser/deleteUser, deleteDatabase, etc.\n"
    ],
    "base_path": "for-nano"
  },
  {
    "name": "for-pouch",
    "title": "for-pouch",
    "description": "# decaf-ts / for-pouch — Detailed Description\n\nThis package integrates PouchDB with the decaf-ts data and decorator ecosystem. It provides:\n- A concrete PouchAdapter that implements persistence against a PouchDB backend (local or remote CouchDB-compatible server).\n- A typed PouchRepository alias for convenience when working with decaf-ts Repository and Mango queries.\n- Configuration and flag types tailored for PouchDB usage.\n- A module entry that wires flavour-specific decorations for createdBy/updatedBy when the module is loaded.\n\nThe intent of this library is to offer an ergonomic, type-safe repository pattern on top of PouchDB/CouchDB, including:\n- CRUD operations (single and bulk) with proper error mapping.\n- Query support via Mango queries, sorting with defined indexes, and pagination via core utilities.\n- Support for multiple databases and aliases.\n- Seamless model decoration with decaf-ts decorators, including created/updated metadata and relation handling.\n\n\nAPI Inventory by File\n\n1) src/constants.ts\n- PouchFlavour: string = \"pouch\" — Flavour identifier used by the decorator system and Repository.forModel resolution.\n- DefaultLocalStoragePath: string = \"local_dbs\" — Default path for local PouchDB storage when running without a remote host.\n\n2) src/types.ts\n- interface PouchFlags extends RepositoryFlags\n  - UUID: string — a per-operation/user identifier injected in Context and used by createdBy/updatedBy decoration.\n- type PouchConfig\n  - user?: string — remote username.\n  - password?: string — remote password.\n  - host?: string — remote host.\n  - protocol?: \"http\" | \"https\" — remote protocol.\n  - port?: number — remote port (optional if in host).\n  - dbName: string — database name.\n  - storagePath?: string — base path for local databases.\n  - plugins: any[] — list of PouchDB plugins to register before client creation.\n\n3) src/PouchRepository.ts\n- type PouchRepository<M extends Model> = Repository<M, MangoQuery, PouchAdapter>\n  - Convenience alias that binds the decaf-ts Repository with MangoQuery and the PouchAdapter backend.\n\n4) src/adapter.ts\n- function createdByOnPouchCreateUpdate<M, R, V>(this: R, context: Context<PouchFlags>, data: V, key: keyof M, model: M): Promise<void>\n  - Decorator handler: copies context UUID into the model[key]. Throws UnsupportedError when unavailable.\n- class PouchAdapter extends CouchDBAdapter<PouchConfig, PouchDB.Database, PouchFlags, Context<PouchFlags>>\n  - constructor(config: PouchConfig, alias?: string)\n    - Initializes the adapter with configuration and optional alias.\n  - getClient(): PouchDB.Database\n    - Lazy client getter; registers provided plugins; creates local or remote client.\n  - flags(operation, model, flags?): Context<PouchFlags>\n    - Prepares operation context and attaches Pouch-specific flags when required.\n  - index(models: Constructor<Model>[]): Promise<CreateIndexResponse[]>\n    - Generates remote/local indexes based on @index decorators in the given models.\n  - initialize(): Promise<CreateIndexResponse[]>\n    - Inherited via CouchDBAdapter; here used in tests to create indexes for sorting. (Called on the adapter instance.)\n  - create(tableName: string, id: Id, model: Model): Promise<Model>\n  - createAll(tableName: string, ids: Id[], models: Model[]): Promise<Model[]>\n  - read(tableName: string, id: Id): Promise<Model>\n  - readAll(tableName: string, ids: Id[]): Promise<Model[]>\n  - update(tableName: string, id: Id, model: Model): Promise<Model>\n  - updateAll(tableName: string, ids: Id[], models: Model[]): Promise<Model[]>\n  - delete(tableName: string, id: Id): Promise<Model>\n  - deleteAll(tableName: string, ids: Id[]): Promise<Model[]>\n    - Bulk variants aggregate item-level errors and throw a mapped BaseError when any failures occur.\n  - raw<T = any>(rawInput: any, process: boolean): Promise<T>\n    - Executes a raw Mango find request. When process=true, returns docs array; otherwise returns full find response.\n  - static parseError(err: unknown): BaseError\n    - Maps PouchDB/HTTP errors and messages into decaf-ts BaseError subtypes, including ConflictError/NotFoundError/ConnectionError.\n    - The instance method parseError delegates to the static implementation.\n  - static decoration(): void\n    - Registers createdByOnPouchCreateUpdate for the pouch flavour so createdBy/updatedBy fields are managed automatically.\n\n5) src/index.ts\n- Side-effect call: PouchAdapter.decoration() — ensures flavour-specific decorator handler is registered upon import.\n- Re-exports: constants, PouchRepository, types, adapter.\n- VERSION: string — package version placeholder replaced at build time.\n\n\nBehavioral Notes and Design Intent\n\n- Multiple DB support: A PouchAdapter can be constructed with an alias; Repository.forModel(Model, alias) resolves the repository for that specific adapter/DB. This enables working with multiple databases concurrently.\n- Decorator-driven modeling: Use @model, @pk, @index, @readonly, and other decaf-ts decorators to describe schemas and constraints. The adapter interprets indexes through @index and can generate them via initialize() or index().\n- Querying: The core Repository composes Mango queries via select().where(Condition...).orderBy(...). PouchAdapter translates and executes these queries with PouchDB Find.\n- Pagination: Use core Paginator returned by paginate(size) on a selection. Sorting requires proper indexes.\n- Error translation: PouchAdapter.parseError normalizes errors from PouchDB/CouchDB and HTTP status codes into a stable error hierarchy for consistent handling.\n- Raw access: raw() allows advanced Mango usage or debugging by running low-level queries and choosing between processed docs or the full response.\n",
    "examples": [
      "import { PouchAdapter, DefaultLocalStoragePath, VERSION } from \"@decaf-ts/for-pouch\";\n\n// Example: Local (in-memory) PouchDB using the memory adapter plugin\nasync function makeMemoryAdapter() {\n  const memory = (await import(\"pouchdb-adapter-memory\")).default as any;\n  // Alias allows multiple DBs; useful in multi-tenant scenarios\n  const adapter = new PouchAdapter({ dbName: \"local_mem_db\", plugins: [memory] }, \"mem-local\");\n  // Accessing the client verifies plugins and initializes the PouchDB instance\n  const client: any = (adapter as any).client;\n  return adapter;\n}\n\n// Example: Remote CouchDB-compatible server\nasync function makeRemoteAdapter() {\n  const adapter = new PouchAdapter(\n    {\n      protocol: \"http\",\n      host: \"localhost:5984\",\n      user: \"admin\",\n      password: \"secret\",\n      dbName: \"my_database\",\n      plugins: [],\n    },\n    \"remote-1\"\n  );\n  return adapter;\n}\n\nconsole.log(\"for-pouch version:\", VERSION);\n",
      "import {\n  BaseModel,\n  Repository,\n  OrderDirection,\n  pk,\n  index,\n  uses,\n} from \"@decaf-ts/core\";\nimport {\n  Model,\n  model,\n  required,\n  minlength,\n  min,\n  type,\n  ModelArg,\n} from \"@decaf-ts/decorator-validation\";\n\n@uses(\"pouch\")\n@model()\nclass User extends BaseModel {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @min(18)\n  @index([OrderDirection.DSC, OrderDirection.ASC])\n  age!: number;\n\n  @required()\n  @minlength(5)\n  name!: string;\n\n  @required()\n  @type([String.name])\n  sex!: \"M\" | \"F\";\n\n  constructor(arg?: ModelArg<User>) {\n    super(arg);\n  }\n}\n\nModel.setBuilder(Model.fromModel);\n",
      "import { Repository } from \"@decaf-ts/core\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function crudExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Create\n  const created = await repo.create(\n    new User({ name: \"user_name_1\", age: 20, sex: \"M\" })\n  );\n\n  // Read\n  const read = await repo.read(created.id);\n\n  // Update\n  const updated = await repo.update(new User({ ...created, name: \"new_name\" }));\n\n  // Delete\n  const deleted = await repo.delete(created.id);\n\n  return { created, read, updated, deleted };\n}\n",
      "async function bulkExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Create many\n  const models = Array.from({ length: 5 }, (_, i) =>\n    new User({ name: `user_${i + 1}`.padEnd(6, \"_\"), age: 18 + i, sex: i % 2 ? \"F\" : \"M\" })\n  );\n  const created = await repo.createAll(models);\n\n  // Read many by id\n  const ids = created.map((u) => u.id);\n  const many = await repo.readAll(ids);\n\n  // Update many\n  const updated = await repo.updateAll(\n    many.map((u) => new User({ ...u, name: u.name + \"_x\" }))\n  );\n\n  // Delete many\n  const deleted = await repo.deleteAll(updated.map((u) => u.id));\n  return { created, many, updated, deleted };\n}\n",
      "import { Condition, OrderDirection } from \"@decaf-ts/core\";\n\nasync function queryExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  // Insert sample data\n  await repo.createAll(\n    [1, 2, 3, 4, 5].map((i) => new User({ name: `user_name_${i}`, age: 18 + i % 3, sex: i % 2 ? \"F\" : \"M\" }))\n  );\n\n  // Fetch full objects\n  const all = await repo.select().execute();\n\n  // Fetch only selected attributes\n  const projected = await repo.select([\"age\", \"sex\"]).execute();\n\n  // Conditional filtering\n  const cond = Condition.attribute<User>(\"age\").eq(20);\n  const exactly20 = await repo.select().where(cond).execute();\n\n  // Sorting requires proper indexes (use adapter.initialize() to build from @index decorators)\n  await adapter.initialize();\n  const sorted = await repo.select().orderBy([\"age\", OrderDirection.DSC]).execute();\n\n  return { all, projected, exactly20, sorted };\n}\n",
      "import { Paginator } from \"@decaf-ts/core\";\n\nasync function paginationExample(adapter: PouchAdapter) {\n  const repo = new Repository(adapter, User);\n\n  await adapter.initialize();\n  const paginator: Paginator<User, any> = await repo\n    .select()\n    .orderBy([\"id\", OrderDirection.DSC])\n    .paginate(10);\n\n  const page1 = await paginator.page();\n  const page2 = await paginator.next();\n  return { page1, page2 };\n}\n",
      "import { Repository } from \"@decaf-ts/core\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function multiDbExample() {\n  const memory = (await import(\"pouchdb-adapter-memory\")).default as any;\n\n  // Two adapters with distinct aliases\n  const db1 = new PouchAdapter({ dbName: \"db1\", plugins: [memory] }, \"db1\");\n  const db2 = new PouchAdapter({ dbName: \"db2\", plugins: [memory] }, \"db2\");\n\n  // Repository.forModel can resolve by alias (after @uses(\"pouch\") on the model)\n  const repo1 = Repository.forModel(User, \"db1\");\n  const repo2 = Repository.forModel(User, \"db2\");\n\n  const u1 = await repo1.create(new User({ name: \"A_user\", age: 21, sex: \"M\" }));\n  const u2 = await repo2.create(new User({ name: \"B_user\", age: 22, sex: \"F\" }));\n\n  const again1 = await repo1.read(u1.id);\n  const again2 = await repo2.read(u2.id);\n  return { again1, again2 };\n}\n",
      "import { CouchDBKeys } from \"@decaf-ts/for-couchdb\";\n\nasync function rawExample(adapter: PouchAdapter) {\n  const client: any = (adapter as any).client;\n  await client.put({ [CouchDBKeys.ID]: \"r1\", type: \"row\", x: 1 });\n  await client.put({ [CouchDBKeys.ID]: \"r2\", type: \"row\", x: 2 });\n\n  // process=true -> returns docs array only\n  const docsOnly = await adapter.raw<any[]>({ selector: { type: { $eq: \"row\" } } }, true);\n\n  // process=false -> returns the full FindResponse\n  const full = await adapter.raw<any>({ selector: { type: { $eq: \"row\" } } }, false);\n\n  return { docsOnly, full };\n}\n",
      "import { BaseError } from \"@decaf-ts/db-decorators\";\nimport { PouchAdapter } from \"@decaf-ts/for-pouch\";\n\nasync function parseErrorExample(adapter: PouchAdapter) {\n  try {\n    await adapter.read(\"tbl\", \"no-such-id\");\n  } catch (e) {\n    // Convert low-level errors to decaf-ts BaseError shape\n    const parsed = PouchAdapter.parseError(e);\n    if (parsed instanceof BaseError) {\n      // handle known error types (ConflictError, NotFoundError, etc.)\n      console.warn(\"Handled decaf error:\", parsed.message);\n    } else {\n      throw e;\n    }\n  }\n}\n",
      "import { createdByOnPouchCreateUpdate, PouchFlags } from \"@decaf-ts/for-pouch\";\nimport { Context } from \"@decaf-ts/db-decorators\";\n\nclass ExampleModel { createdBy?: string }\n\nasync function createdByExample() {\n  const ctx = new Context<PouchFlags>().accumulate({ UUID: \"user-123\" });\n  const model = new ExampleModel();\n  await createdByOnPouchCreateUpdate.call(\n    {} as any,\n    ctx,\n    {} as any,\n    \"createdBy\" as any,\n    model as any\n  );\n  // model.createdBy === \"user-123\"\n  return model;\n}\n",
      "import type { PouchConfig, PouchFlags } from \"@decaf-ts/for-pouch\";\nimport { PouchFlavour, DefaultLocalStoragePath } from \"@decaf-ts/for-pouch\";\n\nconst flavour: string = PouchFlavour; // \"pouch\"\nconst defaultPath: string = DefaultLocalStoragePath; // \"local_dbs\"\n\nconst cfg: PouchConfig = {\n  dbName: \"sample\",\n  plugins: [],\n};\n\nconst flags: PouchFlags = {\n  UUID: \"user-xyz\",\n};\n"
    ],
    "base_path": "for-pouch"
  },
  {
    "name": "for-typeorm",
    "title": "for-typeorm",
    "description": "# Decaf.ts for TypeORM — Detailed Description\n\nDecaf.ts for TypeORM provides a complete implementation of Decaf.ts' data access abstractions backed by a TypeORM DataSource. It bridges Decaf models, repositories, and query primitives with TypeORM's ORM facilities, while keeping a consistent API across different database adapters in the Decaf.ts ecosystem.\n\nCore capabilities include:\n- An Adapter (TypeORMAdapter) that encapsulates connection management, CRUD operations, schema creation helpers, index generation, raw execution, error translation, and wiring of decorators.\n- A Repository (TypeORMRepository) that exposes typed CRUD and batch operations for a given Model, validating data via @decaf-ts/db-decorators and @decaf-ts/decorator-validation.\n- Query composition via TypeORMStatement, which converts the Decaf.ts core Statement API into TypeORM Find options and QueryBuilder calls. Combined with TypeORMPaginator to paginate results.\n- Decorator overrides that mirror TypeORM’s decorators (Entity, Column, PrimaryColumn, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, JoinColumn, OneToOne, OneToMany, ManyToOne) ensuring compatible metadata is emitted for the adapter.\n- Sequence utilities (TypeORMSequence) for generating and reading database sequence values.\n- Index generation helpers (generateIndexes) to produce SQL index creation statements based on model metadata.\n- Typed constants, enums, and helper types for SQL operators, query containers, and PostgreSQL result shapes.\n\nArchitecture and responsibilities\n\n1. Adapter layer\n   - TypeORMAdapter is the central integration point. It:\n     - Holds a TypeORM DataSource and provides dataSource(), connect(), createDatabase(), createUser(), and related helpers.\n     - Implements CRUD over entities: create, read, update, delete, and their batch counterparts (createAll, readAll, updateAll, deleteAll).\n     - Provides Statement(), Sequence(), Repository() factories returning TypeORM-specific implementations.\n     - Indexing support via index(models) which uses generateIndexes to build SQL statements for indexes.\n     - Raw execution via raw({ query, values }).\n     - Error translation through parseError() mapping DB errors to Decaf.ts errors.\n     - Schema creation helpers: parseTypeToPostgres, parseValidationToPostgres, parseRelationsToPostgres, createTable.\n     - Decoration() static initializer: wires Decaf.ts model decorators and relation metadata to TypeORM’s metadata storage using the overrides in src/overrides.\n\n2. Repository layer\n   - TypeORMRepository<M> extends the Decaf.ts core Repository and provides:\n     - Validation enforcement (enforceDBDecorators) and Context propagation.\n     - Standard CRUD and batch operations that delegate to the adapter, applying OperationKeys flags and TypeORMFlags.\n     - Query builder access via queryBuilder() to get a TypeORMStatement for fluent querying.\n\n3. Query layer\n   - TypeORMStatement<M, R> extends core Statement and composes queries as TypeORM Find options/QueryBuilder calls.\n     - build() resolves the internal statement into a TypeORMQuery container.\n     - raw() executes a SelectQueryBuilder and returns getMany() results.\n     - paginate(size) returns a TypeORMPaginator bound to this statement.\n     - translateOperators() maps Decaf.ts Operator/GroupOperator to SQL via TypeORMOperator/TypeORMGroupOperator.\n   - TypeORMPaginator<M, R> implements page navigation using TypeORM’s repository.findAndCount with take/skip and maps rows back to models via the adapter’s revert().\n\n4. Decorator overrides\n   - Functions mirroring TypeORM decorators but routed through our overrides/utilities to control metadata aggregation:\n     - Entity, Column, PrimaryColumn, PrimaryGeneratedColumn.\n     - CreateDateColumn, UpdateDateColumn.\n     - JoinColumn.\n     - OneToOne, OneToMany, ManyToOne.\n   - These register metadata through getMetadataArgsStorage() and the helper aggregateOrNewColumn to avoid duplicates and merge options.\n\n5. Sequences\n   - TypeORMSequence implements the Decaf.ts Sequence abstraction using Adapter.raw to query and increment PostgreSQL sequences, parsing values according to the configured type.\n\n6. Index generation\n   - generateIndexes(models) inspects Repository.indexes metadata and returns a list of TypeORMQuery statements to create indexes. The Adapter can execute them via raw().\n\n7. Dispatching and events\n   - TypeORMDispatch extends core Dispatch to subscribe a TypeORM DataSource to a TypeORMEventSubscriber, translating TypeORM entity events (insert/update/delete) into OperationKeys notifications for Decaf.ts observers.\n   - TypeORMEventSubscriber listens to afterInsert/afterUpdate/afterRemove, resolves the model/table via Repository.table, and calls adapter.updateObservers.\n\n8. Constants, types, and utilities\n   - constants: reservedAttributes regex, TypeORMFlavour identifier, TypeORMKeys for common DB keys.\n   - query/constants: TypeORMQueryLimit and mappings for TypeORMOperator (comparison operators) and TypeORMGroupOperator (logical operators), plus TypeORMConst.\n   - types: SQLOperator enum; TypeORMQuery container; TypeORMFlags; TypeORMTableSpec.\n   - raw/postgres: FieldDef, QueryResultBase, QueryResult, QueryArrayResult for typing raw Postgres results.\n   - utils: convertJsRegexToPostgres() to transform JS RegExp into PostgreSQL POSIX pattern strings.\n\nTypical usage flow\n\n1. Initialize and decorate\n   - Import from `@decaf-ts/for-typeorm` index. It calls TypeORMAdapter.decoration() on import to ensure decorators are wired.\n2. Configure adapter and data source\n   - Construct a TypeORMAdapter with DataSourceOptions, then initialize/connect.\n3. Define models with decaf-ts decorators, keeping it consistent decorators:\n   - use @table() instead of @Entity();\n   - use @column() instead of @Column();\n   - always use decaf-ts decorators instead of TypeORM decorators. Decaf's will be wired to TypeORM's metadata storage.\n4. Use repositories\n   - Use Repository.forModel to get a decaf repository for your model.\n   - Get a TypeORMRepository native features use repository.nativeRepository().\n5. Build queries\n   - Using the decaf query api, all queries are guaranteed to use prepared statements via repository.select()\n   - Use repository.queryBuilder() to use native typeorm query builder for edge cases or advanced queries.\n6. Sequences and indexes\n   - Use TypeORMSequence for sequence values and generateIndexes to pre-create DB indexes.\n7. Observe changes\n   - Use TypeORMDispatch to subscribe to entity events and update observers in real time.\n\nError handling\n\n- IndexError signals issues with index generation/handling.\n- Adapter.parseError translates TypeORM/DB errors into Decaf.ts error types (ConflictError, NotFoundError, etc.) for consistent error semantics across adapters.\n\nDatabase and compatibility notes\n\n- The adapter targets TypeORM; many helper utilities assume PostgreSQL (e.g., regex operators, sequence queries). The code converts JS regex to PostgreSQL-compatible patterns and defines raw result typings for Postgres.\n\nExports overview (primary)\n\n- Classes: TypeORMAdapter, TypeORMRepository, TypeORMDispatch, TypeORMEventSubscriber, TypeORMStatement, TypeORMPaginator, TypeORMSequence, IndexError.\n- Decorators and helpers: Entity, Column, PrimaryColumn, PrimaryGeneratedColumn, CreateDateColumn, UpdateDateColumn, JoinColumn, OneToOne, OneToMany, ManyToOne, aggregateOrNewColumn.\n- Query utilities: TypeORMQueryLimit, TypeORMOperator, TypeORMGroupOperator, TypeORMConst, translateOperators.\n- Types: SQLOperator, TypeORMQuery, TypeORMFlags, TypeORMTableSpec.\n- Constants: reservedAttributes, TypeORMKeys, TypeORMFlavour.\n- Utils: convertJsRegexToPostgres.\n- Raw typing: FieldDef, QueryResultBase, QueryResult, QueryArrayResult.\n",
    "examples": [
      "import { TypeORMAdapter, TypeORMFlavour } from \"@decaf-ts/for-typeorm\";\nimport { DataSource, DataSourceOptions } from \"typeorm\";\n\n// Admin connection (used to create db/user)\nconst adminOptions: DataSourceOptions = {\n  type: \"postgres\",\n  host: \"localhost\",\n  port: 5432,\n  username: \"postgres\",\n  password: \"password\",\n  database: \"postgres\",\n};\n\n// App database name and user\nconst dbName = \"app_db\";\nconst appUser = \"app_user\";\nconst appPass = \"password\";\n\n// 1) Connect as admin and prepare database and user\nconst admin = await TypeORMAdapter.connect(adminOptions);\ntry {\n  await TypeORMAdapter.createDatabase(admin, dbName);\n  await TypeORMAdapter.createUser(admin, dbName, appUser, appPass);\n  await TypeORMAdapter.createNotifyFunction(admin, appUser);\n} finally {\n  await admin.destroy();\n}\n\n// 2) Application DataSource and adapter\nconst appOptions: DataSourceOptions = {\n  type: \"postgres\",\n  host: \"localhost\",\n  port: 5432,\n  username: appUser,\n  password: appPass,\n  database: dbName,\n  synchronize: true,\n  logging: false,\n};\n\nconst adapter = new TypeORMAdapter(appOptions);\n// Optionally inject an existing DataSource instance\nadapter[\"_dataSource\"] = new DataSource(appOptions);\n",
      "import { model, ModelArg } from \"@decaf-ts/decorator-validation\";\nimport {\n  table,\n  pk,\n  column,\n  required,\n  oneToOne,\n  oneToMany,\n  manyToOne,\n  manyToMany,\n  Repository,\n  uses,\n} from \"@decaf-ts/core\";\nimport { TypeORMFlavour, TypeORMRepository } from \"@decaf-ts/for-typeorm\";\nimport { Cascade } from \"@decaf-ts/db-decorators\";\n\n/**\n * User ↔ Profile: one-to-one\n * User → Post: one-to-many\n * Post → User: many-to-one\n * Post ↔ Tag: many-to-many\n */\n\n@uses(TypeORMFlavour)\n@table(\"app_user\")\n@model()\nclass AppUser extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column(\"name\")\n  @minlength(3)\n  @maxlength(255)\n  @index()\n  name!: string;\n\n  @required()\n  @column(\"email\")\n  @email()\n  @index()\n  email!: string;\n\n  @column(\"is_active\")\n  isActive: boolean = true;\n\n  @column(\"created_at\")\n  @createdAt()\n  createdAt: Date;\n\n  // oneToOne: each user has exactly one profile\n  @oneToOne(\n    () => UserProfile,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.SET_NULL,\n    },\n    true // populate\n  )\n  @required()\n  profile!: UserProfile;\n\n  // oneToMany: user has many posts (inverse in Post.author as manyToOne)\n  @oneToMany(\n    () => Post,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.CASCADE,\n    },\n    true // populate\n  )\n  posts?: Post[];\n\n  constructor(arg?: ModelArg<AppUser>) {\n    super(arg);\n  }\n}\n\n@uses(TypeORMFlavour)\n@table(\"user_profile\")\n@model()\nclass UserProfile extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @column(\"bio\")\n  bio?: string;\n\n  @column(\"age\")\n  @min(0)\n  @max(150)\n  @step(1)\n  @required()\n  age!: number;\n  \n  @column(\"avatar_url\")\n  @url()\n  avatarUrl?: string;\n\n  @column(\"phone\")\n  @index()\n  phone?: string;\n  \n  @column(\"created_at\")\n  @createdAt()\n  updatedAt: Date;\n  \n  @column(\"updated_at\")\n  @updatedAt()\n  updatedAt: Date;\n\n  // Optional back-reference to the user (many projects omit the reverse one-to-one)\n  @oneToOne(\n    () => AppUser,\n    {\n      update: Cascade.CASCADE,\n      delete: Cascade.CASCADE,\n    },\n    true\n  )\n  @required()\n  user!: AppUser;\n\n  constructor(arg?: ModelArg<UserProfile>) {\n    super(arg)\n  }\n}\n\n@uses(TypeORMFlavour)\n@table(\"post\")\n@model()\nclass Post extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column(\"title\")\n  @index()\n  title!: string;\n\n  @required()\n  @column(\"body\")\n  body!: string;\n\n  @column(\"published_at\")\n  publishedAt?: Date;\n\n  @column(\"is_published\")\n  isPublished: boolean = false;\n\n  // manyToOne: each post belongs to a single user (inverse of AppUser.posts)\n  @manyToOne(\n    () => AppUser,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.SET_NULL,\n    },\n    false // only one side of the relation can be eager\n  )\n  author!: AppUser;\n\n  // manyToMany: posts can have many tags and tags can belong to many posts\n  @manyToMany(\n    () => Tag,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.NONE,\n    },\n    true // populate\n  )\n  tags?: Tag[];\n\n  constructor(arg?: ModelArg<Post>) {\n    super(arg)\n  }\n}\n\n@uses(TypeORMFlavour)\n@table()\n@model()\nclass Tag extends Model {\n  @pk({ type: \"Number\" })\n  id!: number;\n\n  @required()\n  @column()\n  @index()\n  name!: string;\n\n  @column()\n  color?: string;\n\n  // Optional reverse manyToMany side\n  @manyToMany(\n    () => Post,\n    {\n      update: Cascade.NONE,\n      delete: Cascade.NONE,\n    },\n    true\n  )\n  posts?: Post[];\n\n  constructor(arg?: ModelArg<Tag>) {\n    super(arg)\n  }\n}\n\n// Example: create a user with profile, posts and tags in one go\nconst userRepo: TypeORMRepository<AppUser> = Repository.forModel(AppUser);\nconst tagRepo: TypeORMRepository<Tag> = Repository.forModel(Tag);\n\nconst t1 = await tagRepo.create(new Tag({ name: \"typescript\", color: \"#3178C6\" }));\nconst t2 = await tagRepo.create(new Tag({ name: \"orm\" }));\n\nconst createdUser = await userRepo.create(\n  new AppUser({\n    name: \"Alice\",\n    email: \"alice@example.com\",\n    profile: { \n      bio: \"Full-stack dev\", \n      phone: \"+1-555-1234\" \n    },\n    posts: [\n      {\n        title: \"Hello World\",\n        body: \"My first post\",\n        isPublished: true,\n        tags: [t1, t2],\n      },\n      {\n        title: \"TypeORM Tips\",\n        body: \"Relations and cascading\",\n        tags: [t1],\n      },\n    ],\n  })\n);\n\n// Read back with relations populated (populate=true in decorators)\nconst fetched = await userRepo.read(createdUser.id);\n",
      "import { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { Observer } from \"@decaf-ts/core\";\n\n// Observe changes\nconst mock = jest.fn(); // or any function\nconst observer: Observer = { refresh: (...args) => Promise.resolve(mock(...args)) };\nrepo.observe(observer);\n\n// Create\nconst created = await repo.create(new User({ name: \"Alice\", nif: \"123456789\" }));\n// Read\nconst fetched = await repo.read(created.id);\n// Update\ncreated.name = \"Alice Doe\";\nconst updated = await repo.update(created);\n// Delete\nawait repo.delete(updated.id);\n\n// Bulk operations\nconst many = [\n  new User({ name: \"u1\", nif: \"111111111\" }),\n  new User({ name: \"u2\", nif: \"222222222\" }),\n];\nconst createdAll = await repo.createAll(many);\nconst readAll = await repo.readAll(createdAll.map(u => u.id));\nconst updatedAll = await repo.updateAll(readAll.map(u => ({ ...u, name: u.name + \"!\" }) as User));\nawait repo.deleteAll(updatedAll.map(u => u.id));\n",
      "import { TypeORMRepository } from \"@decaf-ts/for-typeorm\"\n// Access the underlying TypeORM Repository\nconst repo: TypeORMRepository = Repository.forModel(User);\nconst nativeRepo = repo.nativeRepository();\n\n// Or build a TypeORM query using queryBuilder()\nconst qb = repo.queryBuilder<User>(); // returns a QueryBuilder<User>\nconst rows = await qb.select(\"user\").where({ name: \"Alice\" }).getMany();\n",
      "import { Operator, Condition, Repository } from \"@decaf-ts/core\";\nconst repo: TypeORMRepository = Repository.forModel(User);\n\n// Build a Decaf statement and paginate\nconst stmt = repo\n  .select()\n  .where(Condition.attr<User>(\"name\").eq(\"Alice\"))\n  .orderBy(\"id\")\n  .paginate(10); // TypeORMPaginator under the hood\n\nconst page1 = await stmt.page(1); // User[]\n",
      "import { TypeORMDispatch, TypeORMAdapter } from \"@decaf-ts/for-typeorm\";\nimport { Repository, Observer } from \"@decaf-ts/core\";\nimport { OperationKeys } from \"@decaf-ts/db-decorators\";\nimport { DataSourceOptions } from \"typeorm\";\n\n// Assume you already created the DB and user\nconst options: DataSourceOptions = { /* postgres options */ } as any;\nconst adapter = new TypeORMAdapter(options);\n\n// Observe repository changes\nconst repo = Repository.forModel(User);\nconst spy = jest.fn();\nconst observer: Observer = { refresh: (t, op, ids) => Promise.resolve(spy(t, op, ids)) };\nrepo.observe(observer);\n\n// Start dispatch\nconst dispatch = new TypeORMDispatch();\nawait dispatch.observe(adapter, options);\n\n// After create/update/delete through the repo, your observer will be notified\nawait repo.create(new User({ name: \"Bob\", nif: \"999999990\" }));\nexpect(spy).toHaveBeenCalledWith(repo.table, OperationKeys.CREATE, expect.any(Array));\n",
      "import { TypeORMEventSubscriber } from \"@decaf-ts/for-typeorm\";\nimport { DataSource, DataSourceOptions } from \"typeorm\";\n\nconst options: DataSourceOptions = { /* postgres options */ } as any;\nconst ds = new DataSource({ ...options, subscribers: [new TypeORMEventSubscriber((table, op, ids) => {\n  console.log(\"Changed:\", table, op, ids);\n})] });\nawait ds.initialize();\n",
      "import { translateOperators } from \"@decaf-ts/for-typeorm\";\nimport { Operator, GroupOperator } from \"@decaf-ts/core\";\n\nconst eq = translateOperators(Operator.EQUAL);      // \"=\"\nconst ne = translateOperators(Operator.DIFFERENT);  // \"<>\"\nconst and = translateOperators(GroupOperator.AND);  // \"AND\"\n",
      "import { convertJsRegexToPostgres } from \"@decaf-ts/for-typeorm\";\n\nconvertJsRegexToPostgres(/foo.*/i); // \"foo.*\"\nconvertJsRegexToPostgres(\"/bar.+/g\"); // \"bar.+\"\n",
      "import { splitEagerRelations } from \"@decaf-ts/for-typeorm\";\n\nconst { relations, nonEager } = splitEagerRelations(User);\n// relations might include [\"posts\", \"profile\", \"posts.tags\"] depending on your decorators\n",
      "import { TypeORMSequence } from \"@decaf-ts/for-typeorm\";\n\nconst seq = new TypeORMSequence({ name: \"user_id_seq\", type: \"Number\", startWith: 1, incrementBy: 1 }, adapter);\nconst nextValue = await seq.next();\nconst batch = await seq.range(5); // e.g., [2,3,4,5,6]\n",
      "import { generateIndexes, TypeORMAdapter } from \"@decaf-ts/for-typeorm\";\n\nconst stmts = generateIndexes([User, Post]); // returns TypeORMQuery[] with raw SQL and values\nfor (const st of stmts) {\n  await adapter.raw(st);\n}\n"
    ],
    "base_path": "for-typeorm"
  },
  {
    "name": "for-fabric",
    "title": "for-fabric",
    "description": "### Description\n\nThis module focuses on the chaincode (contracts) side of @decaf-ts/for-fabric. It adapts DECAF’s Repository/Model/Adapter abstractions to Hyperledger Fabric’s world state and execution context so you can implement smart contracts with familiar patterns and minimal boilerplate.\n\nKey ideas:\n- Keep your domain models as annotated classes (using @decaf-ts/decorator-validation).\n- Use a Repository to persist/read/query models through a Fabric-aware Adapter.\n- Compose reusable CRUD contracts and utilities instead of hand-writing stub calls.\n- Emit first-class Fabric events from repository operations.\n- Leverage context-aware logging and typed flags during execution.\n\nContracts building blocks identified in src/contracts:\n\n1) Core context and types\n- FabricContractContext: Extends the generic Context to expose Fabric-specific properties (stub, clientIdentity, logger) and timestamp resolution from the ledger.\n- FabricContractFlags: Interface extending RepositoryFlags with stub, clientIdentity and logger for contract calls.\n\n2) Logging\n- ContractLogger: MiniLogger-compatible logger bound to the Fabric contract Context. It honors log levels and forwards to the underlying Fabric logger.\n\n3) Adapter and repository\n- FabricContractAdapter: Chaincode-side Adapter that implements CRUD, bulk operations, raw Mango queries, result iteration, model preparation/reversion, composite-key prefixes, and sequence creation. Bridges DECAF abstractions to Fabric (ChaincodeStub, ClientIdentity) and CouchDB-style queries.\n- FabricContractRepository<M>: Repository for models inside chaincode. Supports create, update, createAll, updateAll, read/readAll, raw queries (Mango), select projections, prefix-based bulk ops, and event emission through an ObserverHandler.\n- FabricContractRepositoryObservableHandler: ObserverHandler that emits Fabric events via stub.setEvent using names generated by generateFabricEventName.\n\n4) Sequences\n- FabricContractDBSequence: Fabric-backed implementation of Sequence with current, next and range. Stores values in the world state via FabricContractRepository and supports Number or BigInt sequences with configurable startWith and incrementBy.\n\n5) CRUD contracts\n- FabricCrudContract<M>: Base smart contract exposing CRUD endpoints (create, read, update, delete, createAll, readAll, updateAll, deleteAll, raw, init, healthcheck) for a model type. Uses DeterministicSerializer and the FabricContractAdapter/Repository behind the scenes and provides logFor(ctx).\n- SerializedCrudContract<M>: Same endpoints as FabricCrudContract but takes/returns JSON strings (de)serialized to the model class. This simplifies client interactions and is used in tests.\n\n6) ERC20 sample\n- ERC20Token, ERC20Wallet, Allowance: Sample domain models for an ERC20-like token, wallets and allowances.\n- FabricStatement<M,R>: A CouchDBStatement bridge that runs Mango queries through FabricContractAdapter, handling primary key projection when needed.\n- FabricERC20Contract: A full ERC20 smart contract showcasing repository-based persistence and arithmetic helpers. Implements Initialize, CheckInitialized, TokenName, Symbol, Decimals, TotalSupply, BalanceOf, Transfer, TransferFrom, Approve, Allowance, Mint, Burn, BurnFrom, ClientAccountBalance, ClientAccountID and an internal _transfer helper.\n\nDesign notes:\n- Deterministic serialization is used to ensure stable bytes for world-state writes.\n- onCreate/onCreateUpdate hooks from db-decorators are leveraged by the adapter to set primary keys and creator/owner metadata.\n- Mango queries (CouchDB) are used for rich queries via getQueryResultWithPagination.\n- Event emission is opt-in per operation type through FabricContractRepositoryObservableHandler’s supportedEvents list.\n\nWith these components you can build robust chaincode while keeping code concise, testable, and aligned with DECAF’s architecture.\n",
    "examples": [
      "npm install @decaf-ts/for-fabric\n",
      "import { FabricAdapter, PeerConfig } from '@decaf-ts/for-fabric';\n\n// Configure connection to a Fabric peer\nconst config: PeerConfig = {\n  mspId: 'Org1MSP',\n  peerEndpoint: 'localhost:7051',\n  channelName: 'mychannel',\n  chaincodeName: 'mycc',\n  contractName: 'mycontract',\n  tlsCertPath: '/path/to/tls/cert',\n  certDirectoryPath: '/path/to/cert/dir',\n  keyDirectoryPath: '/path/to/key/dir',\n  cryptoPath: '/path/to/crypto',\n  peerHostAlias: 'peer0.org1.example.com',\n  caEndpoint: 'localhost:7054',\n  caTlsCertificate: '/path/to/ca/tls/cert',\n  caCert: '/path/to/ca/cert',\n  caKey: '/path/to/ca/key',\n  ca: 'ca.org1.example.com'\n};\n\n// Create an adapter instance\nconst adapter = new FabricAdapter(config, 'org1-adapter');\n\n// Use the adapter to interact with the Fabric network\nasync function createAsset() {\n  const asset = { id: 'asset1', value: 'Asset 1 Value' };\n  return await adapter.create('assets', 'asset1', asset, {}, mySerializer);\n}\n\nasync function readAsset(id: string) {\n  return await adapter.read('assets', id, mySerializer);\n}\n\nasync function updateAsset(id: string, newValue: string) {\n  const asset = await readAsset(id);\n  asset.value = newValue;\n  return await adapter.update('assets', id, asset, {}, mySerializer);\n}\n\nasync function deleteAsset(id: string) {\n  return await adapter.delete('assets', id, mySerializer);\n}\n\nasync function queryAssets(owner: string) {\n  const query = {\n    selector: {\n      owner: owner\n    }\n  };\n  return await adapter.raw(query, true);\n}\n",
      "import { FabricAdapter, FabricDispatch } from '@decaf-ts/for-fabric';\n\nasync function setupEventListener(config: PeerConfig) {\n  // Create a client\n  const client = await FabricAdapter.getClient(config);\n\n  // Create a dispatch instance\n  const dispatch = new FabricDispatch(client);\n\n  // Configure the dispatch with peer configuration\n  dispatch.configure(config);\n\n  // Register an observer for a specific table and event\n  dispatch.observe('assets', 'create', (id) => {\n    console.log(`Asset created: ${id}`);\n    // Fetch the new asset or update UI\n  });\n\n  // Start listening for events\n  await dispatch.start();\n\n  // When done, close the connection\n  // await dispatch.close();\n}\n",
      "import { \n  getIdentity, \n  getSigner, \n  readFile, \n  getCAUser \n} from '@decaf-ts/for-fabric';\n\nasync function setupIdentity() {\n  // Read a certificate file\n  const tlsCert = await readFile('/path/to/tls/cert');\n\n  // Get an identity from a certificate directory\n  const identity = await getIdentity('Org1MSP', '/path/to/cert/dir');\n\n  // Get a signer from a key directory\n  const signer = await getSigner('/path/to/key/dir');\n\n  // Create a CA user\n  const user = await getCAUser(\n    'user1', \n    privateKeyPem, \n    certificatePem, \n    'Org1MSP'\n  );\n\n  return { identity, signer, user };\n}\n",
      "import { Model, id, property, table } from '@decaf-ts/decorator-validation';\n\n@table('assets')\nexport class Asset extends Model {\n  @id()\n  id: string;\n\n  @property()\n  value: string;\n\n  @property()\n  owner: string;\n\n  @property()\n  createdAt: number;\n}\n",
      "import { FabricCrudContract } from '@decaf-ts/for-fabric';\nimport { Context, Contract, Info, Transaction } from 'fabric-contract-api';\nimport { Asset } from './asset';\n\n@Info({ title: 'AssetContract', description: 'Smart contract for trading assets' })\nexport class AssetContract extends FabricCrudContract<Asset> {\n  constructor() {\n    super('AssetContract', Asset);\n  }\n\n  // The base class already provides standard CRUD operations:\n  // create, read, update, delete, createAll, readAll, updateAll, deleteAll\n\n  // Add custom methods as needed\n  @Transaction()\n  async getAssetHistory(ctx: Context, id: string): Promise<any[]> {\n    const stub = ctx.stub;\n    const iterator = await stub.getHistoryForKey(id);\n\n    const results = [];\n    let result = await iterator.next();\n\n    while (!result.done) {\n      const value = result.value;\n      results.push({\n        txId: value.txId,\n        timestamp: value.timestamp,\n        value: JSON.parse(value.value.toString('utf8'))\n      });\n\n      result = await iterator.next();\n    }\n\n    await iterator.close();\n    return results;\n  }\n\n  @Transaction()\n  async transferAsset(ctx: Context, id: string, newOwner: string): Promise<Asset> {\n    const asset = await this.read(ctx, id);\n    asset.owner = newOwner;\n    return await this.update(ctx, asset);\n  }\n}\n",
      "import { FabricContractAdapter } from '@decaf-ts/for-fabric';\nimport { Context, Contract, Transaction } from 'fabric-contract-api';\n\nexport class CustomContract extends Contract {\n  private adapter: FabricContractAdapter;\n\n  constructor() {\n    super('CustomContract');\n    this.adapter = new FabricContractAdapter();\n  }\n\n  @Transaction()\n  async createRecord(ctx: Context, id: string, data: string): Promise<any> {\n    const record = { id, data, timestamp: Date.now() };\n    return await this.adapter.create(\n      'records',\n      id,\n      record,\n      {},\n      { stub: ctx.stub, logger: ctx.logging }\n    );\n  }\n\n  @Transaction(false)\n  async queryRecords(ctx: Context, owner: string): Promise<any[]> {\n    const query = {\n      selector: {\n        owner: owner\n      }\n    };\n\n    return await this.adapter.raw(\n      query,\n      true,\n      { stub: ctx.stub, logger: ctx.logging }\n    );\n  }\n}\n",
      "import { \n  FabricContractRepositoryObservableHandler,\n  generateFabricEventName,\n  parseEventName\n} from '@decaf-ts/for-fabric';\nimport { Context } from 'fabric-contract-api';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\n\n// In chaincode: Emit an event\nasync function emitEvent(ctx: Context, tableName: string, id: string) {\n  const handler = new FabricContractRepositoryObservableHandler();\n  const logger = ctx.logging.getLogger('EventHandler');\n\n  await handler.updateObservers(\n    logger,\n    tableName,\n    OperationKeys.CREATE,\n    id,\n    { stub: ctx.stub }\n  );\n}\n\n// In client: Parse an event name\nfunction handleEvent(eventName: string, payload: Buffer) {\n  const { table, event, owner } = parseEventName(eventName);\n  const data = JSON.parse(payload.toString());\n\n  console.log(`Received ${event} event for ${table} with ID ${data.id}`);\n  if (owner) {\n    console.log(`Event owner: ${owner}`);\n  }\n}\n",
      "import { Context, Transaction, Contract } from 'fabric-contract-api';\nimport { model, ModelArg, required } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { FabricCrudContract } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass Person extends BaseModel {\n  @pk({ type: 'Number' })\n  id!: number;\n  @required() name!: string;\n  constructor(arg?: ModelArg<Person>) { super(arg); }\n}\n\nexport class PersonContract extends FabricCrudContract<Person> {\n  constructor() {\n    super('PersonContract', Person);\n  }\n\n  @Transaction(false)\n  async ping(ctx: Context): Promise<string> {\n    // Uses FabricCrudContract.logFor\n    this.logFor(ctx).info('ping');\n    return 'pong';\n  }\n}\n",
      "import { Context } from 'fabric-contract-api';\nimport { model, ModelArg, required } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { SerializedCrudContract } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass TestModel extends BaseModel {\n  @pk({ type: 'Number' }) id!: number;\n  @required() name!: string;\n  @required() nif!: string;\n  constructor(arg?: ModelArg<TestModel>) { super(arg); }\n}\n\nexport class TestModelContract extends SerializedCrudContract<TestModel> {\n  constructor() {\n    super('TestModelContract', TestModel);\n  }\n}\n\n// Example invocation (mirrors unit test usage)\nasync function createExample(contract: TestModelContract, ctx: Context) {\n  const payload = new TestModel({ name: 'Alice', nif: '123456789' }).serialize();\n  const resultJson = await contract.create(ctx, payload);\n  const created = new TestModel(JSON.parse(resultJson));\n  return created;\n}\n",
      "import { Context } from 'fabric-contract-api';\nimport { Repo } from '@decaf-ts/core';\nimport { model, required, ModelArg } from '@decaf-ts/decorator-validation';\nimport { BaseModel, pk } from '@decaf-ts/core';\nimport { FabricContractRepository } from '@decaf-ts/for-fabric/contracts';\n\n@model()\nclass Asset extends BaseModel {\n  @pk() id!: string;\n  @required() owner!: string;\n  constructor(arg?: ModelArg<Asset>) { super(arg); }\n}\n\nexport class AssetContract extends Contract {\n  private repo: Repo<Asset, any, any, any, any>;\n  constructor() {\n    super('AssetContract');\n    this.repo = new FabricContractRepository<Asset>(new (require('@decaf-ts/for-fabric').contracts.FabricContractAdapter)(), Asset);\n  }\n\n  @Transaction()\n  async Create(ctx: Context, id: string, owner: string): Promise<void> {\n    const m = new Asset({ id, owner });\n    await this.repo.create(m, ctx as any);\n  }\n\n  @Transaction(false)\n  async Read(ctx: Context, id: string): Promise<Asset> {\n    return this.repo.read(id, ctx as any);\n  }\n\n  @Transaction(false)\n  async QueryByOwner(ctx: Context, owner: string): Promise<Asset[]> {\n    return this.repo.raw({ selector: { owner } } as any, true, ctx as any);\n  }\n}\n",
      "import { Context } from 'fabric-contract-api';\nimport { FabricContractDBSequence } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractAdapter } from '@decaf-ts/for-fabric/contracts';\n\nconst adapter = new FabricContractAdapter();\n\nexport class OrderContract extends Contract {\n  private orderSeq = new FabricContractDBSequence({\n    name: 'orderSeq',\n    type: 'Number',\n    startWith: 1,\n    incrementBy: 1,\n  }, adapter);\n\n  @Transaction()\n  async CreateOrder(ctx: Context): Promise<number> {\n    const next = await this.orderSeq.next(ctx as any);\n    // use next as order id\n    return next as number;\n  }\n\n  @Transaction(false)\n  async NextRange(ctx: Context, count: number): Promise<number[]> {\n    return (await this.orderSeq.range(count, ctx as any)) as number[];\n  }\n}\n",
      "import { FabricStatement } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractAdapter } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\nimport { MangoQuery } from '@decaf-ts/for-couchdb';\nimport { Model } from '@decaf-ts/decorator-validation';\n\nclass MyModel extends Model {}\n\nconst adapter = new FabricContractAdapter();\n\nasync function query(ctx: FabricContractContext) {\n  const stmt = new FabricStatement<MyModel, MyModel[]>(adapter, ctx);\n  const models = await stmt.raw<MyModel[]>({ selector: { type: 'MyModel' } } as MangoQuery);\n  return models;\n}\n",
      "import { Context, Transaction } from 'fabric-contract-api';\nimport { Contract } from 'fabric-contract-api';\nimport { ContractLogger } from '@decaf-ts/for-fabric/contracts';\n\nexport class LoggableContract extends Contract {\n  @Transaction()\n  async DoWork(ctx: Context): Promise<void> {\n    const log = new ContractLogger('LoggableContract', { level: 'info' }, ctx as any);\n    log.info('Starting work');\n    // ... work ...\n    log.debug('Finished');\n  }\n}\n",
      "import { FabricContractRepositoryObservableHandler } from '@decaf-ts/for-fabric/contracts';\nimport { OperationKeys } from '@decaf-ts/db-decorators';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\nimport { MiniLogger } from '@decaf-ts/logging';\n\nasync function emitExample(ctx: FabricContractContext) {\n  const handler = new FabricContractRepositoryObservableHandler();\n  const log = new MiniLogger('obs');\n  await handler.updateObservers(log as any, 'assets', OperationKeys.CREATE, 'asset1', ctx);\n}\n",
      "import { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\n\nfunction readContext(ctx: FabricContractContext) {\n  const ts = ctx.timestamp; // Date from stub.getDateTimestamp()\n  const id = ctx.identity.getID();\n  ctx.logger.info(`Tx by ${id} at ${ts.toISOString()}`);\n}\n",
      "import { FabricERC20Contract } from '@decaf-ts/for-fabric/contracts';\nimport { FabricContractContext } from '@decaf-ts/for-fabric/contracts';\n\nconst contract = new FabricERC20Contract('TestToken');\n\nasync function initAndRead(ctx: FabricContractContext) {\n  const created = await contract.Initialize(ctx, 'TestToken', 'TT', 18);\n  if (created) {\n    const name = await contract.TokenName(ctx);\n    const decimals = await contract.Decimals(ctx);\n    return { name, decimals };\n  }\n  throw new Error('Init failed');\n}\n"
    ],
    "base_path": "for-fabric"
  },
  {
    "name": "for-nest",
    "title": "for-nest",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "examples": [],
    "base_path": "for-nest"
  },
  {
    "name": "styles",
    "title": "styles",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "examples": [],
    "base_path": "styles"
  },
  {
    "name": "for-angular",
    "title": "for-angular",
    "description": "### Description\n\nA very versatile persistence layer. from smart contracts, Digital wallets or just regular database access\n\n",
    "examples": [],
    "base_path": "for-angular"
  },
  {
    "name": "mcp-server",
    "title": "mcp-server",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "examples": [],
    "base_path": "mcp-server"
  },
  {
    "name": "for-react-native",
    "title": "for-react-native",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "examples": [],
    "base_path": "for-react-native"
  },
  {
    "name": "demo",
    "title": "demo",
    "description": "### Description\n\nNo one needs the hassle of setting up new repos every time.\n\nNow you can create new repositories from this template and enjoy having everything set up for you.\n\n",
    "examples": [],
    "base_path": "demo"
  }
]